#!/usr/bin/env tsx
/**
 * REST API Generator from Proto Definitions
 *
 * This script reads proto files and generates type-safe REST API methods
 * that work with Vercel/serverless environments.
 */

import * as fs from "fs";
import * as path from "path";
import { fileURLToPath } from "url";

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Configuration
const CONFIG = {
  protoDir: path.join(__dirname, "../protobuf/v1"),
  outputDir: path.join(__dirname, "../../src/wj-client/utils/generated"),
  baseURL: process.env.NEXT_PUBLIC_API_URL || "/api/v1",
};

// Type mappings from proto to TypeScript REST API
interface ProtoMessage {
  name: string;
  fields: ProtoField[];
  comment?: string;
}

interface ProtoField {
  name: string;
  type: string;
  optional: boolean;
  comment?: string;
}

interface ProtoMethod {
  name: string;
  requestType: string;
  responseType: string;
  comment?: string;
}

interface ProtoService {
  name: string;
  comment?: string;
  methods: ProtoMethod[];
  fileName: string;
}

// HTTP method mapping based on gRPC method naming convention
function getHTTPMethod(methodName: string): string {
  const upper = methodName.toUpperCase();
  if (upper.startsWith("CREATE") || upper.startsWith("ADD")) return "post";
  if (upper.startsWith("UPDATE") || upper.startsWith("SET")) return "put";
  if (upper.startsWith("DELETE") || upper.startsWith("REMOVE")) return "delete";
  if (upper.startsWith("LIST") || upper.startsWith("GET") || upper.startsWith("FIND")) return "get";
  return "post"; // Default to POST
}

// Convert PascalCase to camelCase
function toCamelCase(str: string): string {
  return str.charAt(0).toLowerCase() + str.slice(1);
}

// Parse proto file to extract service definitions
function parseProtoFile(filePath: string): ProtoService[] {
  const content = fs.readFileSync(filePath, "utf-8");
  const lines = content.split("\n");

  const services: ProtoService[] = [];
  let currentService: ProtoService | null = null;
  let currentComment: string[] = [];

  for (const line of lines) {
    const trimmed = line.trim();

    // Capture comments
    if (trimmed.startsWith("//")) {
      currentComment.push(trimmed.substring(2).trim());
      continue;
    }

    // Start of service
    const serviceMatch = trimmed.match(/service\s+(\w+)\s*{/);
    if (serviceMatch) {
      currentService = {
        name: serviceMatch[1],
        fileName: path.basename(filePath, ".proto"),
        comment: currentComment.pop(),
        methods: [],
      };
      currentComment = [];
      continue;
    }

    // End of service
    if (trimmed === "}" && currentService) {
      services.push(currentService);
      currentService = null;
      continue;
    }

    // RPC method
    const rpcMatch = trimmed.match(/rpc\s+(\w+)\s*\((\w+)\)\s*returns\s*\((\w+)\)/);
    if (rpcMatch && currentService) {
      const [, name, requestType, responseType] = rpcMatch;
      currentService.methods.push({
        name,
        requestType,
        responseType,
        comment: currentComment.pop(),
      });
      currentComment = [];
    }
  }

  return services;
}

// Get HTTP path based on method name and request type
function getHTTPPath(serviceName: string, methodName: string, requestType: string): string {
  const lcServiceName = toCamelCase(serviceName.replace("Service", ""));
  const lcMethodName = toCamelCase(methodName);

  // Special cases for specific patterns
  if (methodName === "GetAuth" || methodName === "GetUser") {
    return `/v1/${lcServiceName}/${lcMethodName}`;
  }
  if (methodName === "ListUsers" || methodName === "ListWallets") {
    return `/v1/${lcServiceName}`;
  }

  // For methods ending with "ById" or similar
  if (lcMethodName.endsWith("ById")) {
    return `/v1/${lcServiceName}/:id`;
  }

  // Default: use service name + method name (for Create, Update, Delete)
  const httpMethod = getHTTPMethod(methodName);
  if (httpMethod === "post" || httpMethod === "put") {
    return `/v1/${lcServiceName}`;
  }
  if (httpMethod === "delete" || httpMethod === "get") {
    return `/v1/${lcServiceName}/:id`;
  }

  return `/v1/${lcServiceName}/${lcMethodName}`;
}

// Generate the API client code
function generateAPIClient(services: ProtoService[]): string {
  const imports = new Set<string>();
  const apiCode: string[] = [];

  apiCode.push(`// Auto-generated REST API Client from Protobuf Definitions`);
  apiCode.push(`// DO NOT EDIT - This file is generated by api/scripts/generate-rest-api.ts`);
  apiCode.push(`// Generated at: ${new Date().toISOString()}`);
  apiCode.push("");
  apiCode.push(`import { apiClient } from "../api-client";`);
  apiCode.push("");

  // Generate imports for each service
  for (const service of services) {
    const protoFileName = service.fileName;
    imports.add(`import type {`);

    const typeImports: string[] = [];
    for (const method of service.methods) {
      typeImports.push(method.requestType);
      typeImports.push(method.responseType);
    }
    imports.add(typeImports.join(", "));
    imports.add(`} from "@/gen/protobuf/v1/${protoFileName}";`);
  }

  apiCode.push(...Array.from(imports));
  apiCode.push("");
  apiCode.push(`// ============================================================================`);
  apiCode.push(`// REST API CLIENT (Auto-generated)`);
  apiCode.push(`// ============================================================================`);
  apiCode.push("");

  // Generate API object
  apiCode.push(`export const api = {`);

  for (const service of services) {
    const apiName = toCamelCase(service.name.replace("Service", ""));
    apiCode.push(`  /**`);
    apiCode.push(`   * ${service.comment || service.name} API`);
    apiCode.push(`   */`);
    apiCode.push(`  ${apiName}: {`);

    for (const method of service.methods) {
      const httpMethod = getHTTPMethod(method.name);
      const httpPath = getHTTPPath(service.name, method.name, method.requestType);

      apiCode.push(`    /**`);
      apiCode.push(`     * ${method.comment || method.name}`);
      apiCode.push(`     * ${httpMethod.toUpperCase()} ${httpPath}`);
      apiCode.push(`     */`);
      apiCode.push(
        `    async ${toCamelCase(method.name)}(request: ${method.requestType}): Promise<${method.responseType}> {`
      );

      // Handle different HTTP methods
      if (httpMethod === "get") {
        // Build query params for GET requests
        apiCode.push(`      const params = new URLSearchParams();`);
        apiCode.push(`      if (request) {`);
        apiCode.push(`        Object.entries(request).forEach(([key, value]) => {`);
        apiCode.push(`          if (value !== undefined && value !== null) {`);
        apiCode.push(`            params.append(key, String(value));`);
        apiCode.push(`          }`);
        apiCode.push(`        });`);
        apiCode.push(`      }`);
        apiCode.push(`      const queryString = params.toString();`);
        apiCode.push(
          `      const endpoint = \`${httpPath}\${queryString ? \`?\${queryString}\` : ""}\`;`
        );
        apiCode.push(`      return apiClient.get<${method.responseType}["data"]>(endpoint);`);
      } else if (httpMethod === "delete") {
        // DELETE with potential URL params
        apiCode.push(`      return apiClient.delete<${method.responseType}["data"]>(\`${httpPath}\`);`);
      } else if (httpMethod === "post" || httpMethod === "put") {
        // POST/PUT with body
        apiCode.push(`      return apiClient.${httpMethod}<${method.responseType}["data"]>(\`${httpPath}\`, request);`);
      }

      apiCode.push(`    },`);
      apiCode.push("");
    }

    apiCode.push(`  },`);
    apiCode.push("");
  }

  apiCode.push(`};`);
  apiCode.push("");
  apiCode.push(`export default api;`);

  return apiCode.join("\n");
}

// Main function
function main() {
  console.log("üöÄ Generating REST API client from proto files...");

  // Ensure output directory exists
  if (!fs.existsSync(CONFIG.outputDir)) {
    fs.mkdirSync(CONFIG.outputDir, { recursive: true });
  }

  // Read all proto files
  const protoFiles = fs.readdirSync(CONFIG.protoDir).filter((f) => f.endsWith(".proto"));

  console.log(`üìÅ Found ${protoFiles.length} proto files`);

  // Parse all services from proto files
  const allServices: ProtoService[] = [];
  for (const file of protoFiles) {
    const filePath = path.join(CONFIG.protoDir, file);
    const services = parseProtoFile(filePath);
    allServices.push(...services);
    console.log(`  ‚úÖ Parsed ${file}: ${services.length} service(s)`);
  }

  if (allServices.length === 0) {
    console.warn("‚ö†Ô∏è  No services found in proto files!");
    return;
  }

  // Generate the API client code
  const code = generateAPIClient(allServices);

  // Write to output file
  const outputFile = path.join(CONFIG.outputDir, "api.ts");
  fs.writeFileSync(outputFile, code);

  console.log(`‚ú® Generated API client: ${outputFile}`);
  console.log("");
  console.log("üì¶ Generated APIs:");
  for (const service of allServices) {
    console.log(`   - ${toCamelCase(service.name.replace("Service", ""))} (${service.methods.length} methods)`);
  }
}

main();
