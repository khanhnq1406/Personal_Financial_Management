#!/usr/bin/env node
/**
 * REST API Generator from Proto Definitions
 *
 * This script reads proto files and generates type-safe REST API methods
 * and React Query hooks.
 */

const fs = require("fs");
const path = require("path");

// Configuration
const CONFIG = {
  protoDir: path.join(__dirname, "../protobuf/v1"),
  outputDir: path.join(__dirname, "../../src/wj-client/utils/generated"),
};

// HTTP method mapping based on gRPC method naming convention
function getHTTPMethod(methodName) {
  const upper = methodName.toUpperCase();
  if (upper.startsWith("CREATE") || upper.startsWith("ADD") || upper.startsWith("REGISTER")) return "post";
  if (upper.startsWith("UPDATE") || upper.startsWith("SET")) return "put";
  if (upper.startsWith("DELETE") || upper.startsWith("REMOVE")) return "delete";
  if (upper.startsWith("LIST") || upper.startsWith("GET") || upper.startsWith("FIND") || upper.startsWith("VERIFY")) return "get";
  return "post";
}

// Convert PascalCase to camelCase
function toCamelCase(str) {
  return str.charAt(0).toLowerCase() + str.slice(1);
}

// Parse proto file to extract service definitions
function parseProtoFile(filePath) {
  const content = fs.readFileSync(filePath, "utf-8");
  const lines = content.split("\n");

  const services = [];
  let currentService = null;
  let currentComment = [];

  for (const line of lines) {
    const trimmed = line.trim();

    // Capture comments
    if (trimmed.startsWith("//")) {
      currentComment.push(trimmed.substring(2).trim());
      continue;
    }

    // Start of service
    const serviceMatch = trimmed.match(/service\s+(\w+)\s*{/);
    if (serviceMatch) {
      currentService = {
        name: serviceMatch[1],
        fileName: path.basename(filePath, ".proto"),
        comment: currentComment.pop(),
        methods: [],
      };
      currentComment = [];
      continue;
    }

    // End of service
    if (trimmed === "}" && currentService) {
      services.push(currentService);
      currentService = null;
      continue;
    }

    // RPC method
    const rpcMatch = trimmed.match(/rpc\s+(\w+)\s*\((\w+)\)\s*returns\s*\((\w+)\)/);
    if (rpcMatch && currentService) {
      const [, name, requestType, responseType] = rpcMatch;
      currentService.methods.push({
        name,
        requestType,
        responseType,
        comment: currentComment.pop(),
      });
      currentComment = [];
    }
  }

  return services;
}

// Get HTTP path based on method name
function getHTTPPath(serviceName, methodName, requestType) {
  const lcServiceName = toCamelCase(serviceName.replace("Service", ""));

  // Auth endpoints
  if (methodName === "Login") return `/v1/auth/login`;
  if (methodName === "Register") return `/v1/auth/register`;
  if (methodName === "Logout") return `/v1/auth/logout`;
  if (methodName === "VerifyAuth") return `/v1/auth/verify`;
  if (methodName === "GetAuth") return `/v1/auth/by-email`;

  // Wallet endpoints
  if (methodName === "GetWallet") return `/v1/wallets/:id`;
  if (methodName === "ListWallets") return `/v1/wallets`;
  if (methodName === "CreateWallet") return `/v1/wallets`;
  if (methodName === "UpdateWallet") return `/v1/wallets/:id`;
  if (methodName === "DeleteWallet") return `/v1/wallets/:id`;
  if (methodName === "AddFunds") return `/v1/wallets/:id/add`;
  if (methodName === "WithdrawFunds") return `/v1/wallets/:id/withdraw`;
  if (methodName === "TransferFunds") return `/v1/wallets/transfer`;

  // User endpoints
  if (methodName === "GetUser") return `/v1/users/:id`;
  if (methodName === "ListUsers") return `/v1/users`;
  if (methodName === "UpdateUser") return `/v1/users/profile`;
  if (methodName === "DeleteUser") return `/v1/users/:id`;
  if (methodName === "GetUserByEmail") return `/v1/users/by-email`;

  // Default pattern
  const httpMethod = getHTTPMethod(methodName);
  if (httpMethod === "get" && methodName.toLowerCase().startsWith("list")) {
    return `/v1/${lcServiceName}`;
  }
  return `/v1/${lcServiceName}/${toCamelCase(methodName)}`;
}

// Generate the API client code
function generateAPIClient(services) {
  const imports = new Set();
  const apiCode = [];

  apiCode.push(`// Auto-generated REST API Client from Protobuf Definitions`);
  apiCode.push(`// DO NOT EDIT - This file is generated by api/scripts/generate-rest-api.js`);
  apiCode.push(`// Generated at: ${new Date().toISOString()}`);
  apiCode.push("");
  apiCode.push(`import { apiClient } from "../api-client";`);
  apiCode.push("");

  // Generate imports for each service
  for (const service of services) {
    const protoFileName = service.fileName;
    const typeImports = new Set();
    for (const method of service.methods) {
      typeImports.add(method.requestType);
      typeImports.add(method.responseType);
    }
    imports.add(`import type { ${Array.from(typeImports).join(", ")} } from "@/gen/protobuf/v1/${protoFileName}";`);
  }

  apiCode.push(...Array.from(imports));
  apiCode.push("");
  apiCode.push(`// ============================================================================`);
  apiCode.push(`// REST API CLIENT (Auto-generated)`);
  apiCode.push(`// ============================================================================`);
  apiCode.push("");

  // Generate API object
  apiCode.push(`export const api = {`);

  for (const service of services) {
    const apiName = toCamelCase(service.name.replace("Service", ""));
    apiCode.push(`  /**`);
    apiCode.push(`   * ${service.comment || service.name} API`);
    apiCode.push(`   */`);
    apiCode.push(`  ${apiName}: {`);

    for (const method of service.methods) {
      const httpMethod = getHTTPMethod(method.name);
      const httpPath = getHTTPPath(service.name, method.name, method.requestType);

      apiCode.push(`    /**`);
      apiCode.push(`     * ${method.comment || method.name}`);
      apiCode.push(`     * ${httpMethod.toUpperCase()} ${httpPath}`);
      apiCode.push(`     */`);
      apiCode.push(
        `    async ${toCamelCase(method.name)}(request: ${method.requestType}): Promise<${method.responseType}> {`
      );

      // Handle different HTTP methods
      if (httpMethod === "get") {
        if (method.name === "VerifyAuth") {
          apiCode.push(`      const endpoint = \`/v1/auth/verify?token=\${encodeURIComponent(request.token)}\`;`);
          apiCode.push(`      return apiClient.get<any>(endpoint) as Promise<${method.responseType}>;`);
        } else if (method.name === "GetAuth") {
          apiCode.push(`      const endpoint = \`/v1/auth/by-email?email=\${encodeURIComponent(request.email)}\`;`);
          apiCode.push(`      return apiClient.get<any>(endpoint) as Promise<${method.responseType}>;`);
        } else if (method.name === "GetUser") {
          apiCode.push(`      return apiClient.get<any>(\`/v1/users/\${request.userId}\`) as Promise<${method.responseType}>;`);
        } else if (method.name === "GetUserByEmail") {
          apiCode.push(`      const endpoint = \`/v1/users/by-email?email=\${encodeURIComponent(request.email)}\`;`);
          apiCode.push(`      return apiClient.get<any>(endpoint) as Promise<${method.responseType}>;`);
        } else if (method.name === "GetWallet") {
          apiCode.push(`      return apiClient.get<any>(\`/v1/wallets/\${request.walletId}\`) as Promise<${method.responseType}>;`);
        } else if (method.name === "ListUsers" || method.name === "ListWallets") {
          apiCode.push(`      const params = new URLSearchParams();`);
          apiCode.push(`      if (request?.pagination) {`);
          apiCode.push(`        params.append("page", String(request.pagination.page));`);
          apiCode.push(`        params.append("pageSize", String(request.pagination.pageSize));`);
          apiCode.push(`        if (request.pagination.orderBy) params.append("orderBy", request.pagination.orderBy);`);
          apiCode.push(`        if (request.pagination.order) params.append("order", request.pagination.order);`);
          apiCode.push(`      }`);
          apiCode.push(`      const queryString = params.toString();`);
          apiCode.push(`      const endpoint = \`${httpPath}\${queryString ? \`?\${queryString}\` : ""}\`;`);
          apiCode.push(`      return apiClient.get<any>(endpoint) as Promise<${method.responseType}>;`);
        } else {
          apiCode.push(`      const params = new URLSearchParams();`);
          apiCode.push(`      if (request) {`);
          apiCode.push(`        (Object.entries(request) as [string, any][]).forEach(([key, value]) => {`);
          apiCode.push(`          if (value !== undefined && value !== null) {`);
          apiCode.push(`            params.append(key, String(value));`);
          apiCode.push(`          }`);
          apiCode.push(`        });`);
          apiCode.push(`      }`);
          apiCode.push(`      const queryString = params.toString();`);
          apiCode.push(`      const endpoint = \`${httpPath}\${queryString ? \`?\${queryString}\` : ""}\`;`);
          apiCode.push(`      return apiClient.get<any>(endpoint) as Promise<${method.responseType}>;`);
        }
      } else if (httpMethod === "delete") {
        if (method.name === "DeleteWallet") {
          apiCode.push(`      return apiClient.delete<any>(\`/v1/wallets/\${request.walletId}\`) as Promise<${method.responseType}>;`);
        } else if (method.name === "DeleteUser") {
          apiCode.push(`      return apiClient.delete<any>(\`/v1/users/\${request.userId}\`) as Promise<${method.responseType}>;`);
        } else {
          apiCode.push(`      return apiClient.delete<any>(\`${httpPath}\`) as Promise<${method.responseType}>;`);
        }
      } else if (httpMethod === "post" || httpMethod === "put") {
        if (method.name === "Login" || method.name === "Register") {
          apiCode.push(`      const body = { token: request.googleToken || (request as any).token };`);
          apiCode.push(`      return apiClient.${httpMethod}<any>(\`${httpPath}\`, body) as Promise<${method.responseType}>;`);
        } else if (method.name === "Logout") {
          apiCode.push(`      const body = { token: (request as any).token };`);
          apiCode.push(`      return apiClient.${httpMethod}<any>(\`${httpPath}\`, body) as Promise<${method.responseType}>;`);
        } else if (method.name === "UpdateWallet") {
          apiCode.push(`      const body = { walletName: request.walletName };`);
          apiCode.push(`      return apiClient.${httpMethod}<any>(\`/v1/wallets/\${request.walletId}\`, body) as Promise<${method.responseType}>;`);
        } else if (method.name === "UpdateUser") {
          apiCode.push(`      const body = { name: request.name, picture: request.picture };`);
          apiCode.push(`      return apiClient.${httpMethod}<any>(\`/v1/users/profile\`, body) as Promise<${method.responseType}>;`);
        } else if (method.name === "AddFunds") {
          apiCode.push(`      const body = { amount: request.amount };`);
          apiCode.push(`      return apiClient.post<any>(\`/v1/wallets/\${request.walletId}/add\`, body) as Promise<${method.responseType}>;`);
        } else if (method.name === "WithdrawFunds") {
          apiCode.push(`      const body = { amount: request.amount };`);
          apiCode.push(`      return apiClient.post<any>(\`/v1/wallets/\${request.walletId}/withdraw\`, body) as Promise<${method.responseType}>;`);
        } else if (method.name === "TransferFunds") {
          apiCode.push(`      const body = { fromWalletId: request.fromWalletId, toWalletId: request.toWalletId, amount: request.amount };`);
          apiCode.push(`      return apiClient.post<any>(\`/v1/wallets/transfer\`, body) as Promise<${method.responseType}>;`);
        } else {
          apiCode.push(`      return apiClient.${httpMethod}<any>(\`${httpPath}\`, request) as Promise<${method.responseType}>;`);
        }
      }

      apiCode.push(`    },`);
      apiCode.push("");
    }

    apiCode.push(`  },`);
    apiCode.push("");
  }

  apiCode.push(`};`);
  apiCode.push("");
  apiCode.push(`export default api;`);

  return apiCode.join("\n");
}

// Generate React Query hooks
function generateReactQueryHooks(services) {
  const imports = new Set();
  const hooksCode = [];

  hooksCode.push(`// Auto-generated React Query Hooks from Protobuf Definitions`);
  hooksCode.push(`// DO NOT EDIT - This file is generated by api/scripts/generate-rest-api.js`);
  hooksCode.push(`// Generated at: ${new Date().toISOString()}`);
  hooksCode.push("");
  hooksCode.push(`import { useQuery, useMutation } from '@tanstack/react-query';`);
  hooksCode.push(`import { api } from './api';`);
  hooksCode.push(`import type { CustomUseQueryOptions, CustomUseMutationOptions, ResponseType, ErrorType } from './hooks.types';`);

  // Generate imports for each service
  for (const service of services) {
    const protoFileName = service.fileName;
    const typeImports = new Set();
    for (const method of service.methods) {
      typeImports.add(method.requestType);
      typeImports.add(method.responseType);
    }
    imports.add(`import type { ${Array.from(typeImports).join(", ")} } from "@/gen/protobuf/v1/${protoFileName}";`);
  }

  hooksCode.push(...Array.from(imports));
  hooksCode.push("");
  hooksCode.push(`// ============================================================================`);
  hooksCode.push(`// REACT QUERY HOOKS (Auto-generated)`);
  hooksCode.push(`// ============================================================================`);
  hooksCode.push("");

  // Generate hooks for each service
  for (const service of services) {
    const apiName = toCamelCase(service.name.replace("Service", ""));
    hooksCode.push(`// ${service.comment || service.name} Hooks`);
    hooksCode.push("");

    for (const method of service.methods) {
      const httpMethod = getHTTPMethod(method.name);
      const camelMethodName = toCamelCase(method.name);
      const queryConstant = `${apiName.charAt(0).toUpperCase() + apiName.slice(1)}${method.name}`;

      hooksCode.push(`// Event name constants for ${method.name}`);
      hooksCode.push(`export const EVENT_${queryConstant} = "api.${apiName}.${camelMethodName}";`);
      hooksCode.push("");

      // Generate base async function
      hooksCode.push(`/**`);
      hooksCode.push(` * ${method.comment || method.name}`);
      hooksCode.push(` */`);
      hooksCode.push(
        `export async function ${camelMethodName}(request: ${method.requestType}): Promise<${method.responseType}> {`
      );
      hooksCode.push(`  return await api.${apiName}.${camelMethodName}(request);`);
      hooksCode.push(`}`);
      hooksCode.push("");

      // Generate useQuery hook (for GET requests)
      if (httpMethod === "get") {
        hooksCode.push(
          `export function useQuery${method.name}<TransformedType = ${method.responseType}>(`
        );
        hooksCode.push(`  payload: ${method.requestType},`);
        hooksCode.push(`  ops?: CustomUseQueryOptions<ResponseType<${method.responseType}>, TransformedType>`
        );
        hooksCode.push(`) {`);
        hooksCode.push(`  return useQuery<ResponseType<${method.responseType}>, ErrorType, TransformedType, any>({`);
        hooksCode.push(`    queryKey: [EVENT_${queryConstant}, payload],`);
        hooksCode.push(`    queryFn: async () => {`);
        hooksCode.push(`      const data = await ${camelMethodName}(payload);`);
        hooksCode.push(`      return { data };`);
        hooksCode.push(`    },`);
        hooksCode.push(`    retry: false,`);
        hooksCode.push(`    select: (response) => response.data as TransformedType,`);
        hooksCode.push(`    ...ops`);
        hooksCode.push(`  });`);
        hooksCode.push(`}`);
        hooksCode.push("");
      }

      // Generate useMutation hook (for all methods)
      hooksCode.push(
        `export function useMutation${method.name}(opts?: CustomUseMutationOptions<ResponseType<${method.responseType}>, ${method.requestType}, any>) {`
      );
      hooksCode.push(`  return useMutation<ResponseType<${method.responseType}>, ErrorType, ${method.requestType}, any>({`);
      hooksCode.push(`    mutationFn: async (request) => {`);
      hooksCode.push(`      const data = await ${camelMethodName}(request);`);
      hooksCode.push(`      return { data };`);
      hooksCode.push(`    },`);
      hooksCode.push(`    retry: false,`);
      hooksCode.push(`    ...opts`);
      hooksCode.push(`  });`);
      hooksCode.push(`}`);
      hooksCode.push("");
    }

    hooksCode.push("");
  }

  return hooksCode.join("\n");
}

// Main function
function main() {
  console.log("üöÄ Generating REST API client and React Query hooks from proto files...");

  // Ensure output directory exists
  if (!fs.existsSync(CONFIG.outputDir)) {
    fs.mkdirSync(CONFIG.outputDir, { recursive: true });
  }

  // Read all proto files
  const protoFiles = fs.readdirSync(CONFIG.protoDir).filter((f) => f.endsWith(".proto"));

  console.log(`üìÅ Found ${protoFiles.length} proto files`);

  // Parse all services from proto files
  const allServices = [];
  for (const file of protoFiles) {
    const filePath = path.join(CONFIG.protoDir, file);
    const services = parseProtoFile(filePath);
    allServices.push(...services);
    console.log(`  ‚úÖ Parsed ${file}: ${services.length} service(s)`);
  }

  if (allServices.length === 0) {
    console.warn("‚ö†Ô∏è  No services found in proto files!");
    process.exit(1);
  }

  // Generate the API client code
  const apiCode = generateAPIClient(allServices);
  const apiOutputFile = path.join(CONFIG.outputDir, "api.ts");
  fs.writeFileSync(apiOutputFile, apiCode);
  console.log(`‚ú® Generated API client: ${apiOutputFile}`);

  // Generate the React Query hooks code
  const hooksCode = generateReactQueryHooks(allServices);
  const hooksOutputFile = path.join(CONFIG.outputDir, "hooks.ts");
  fs.writeFileSync(hooksOutputFile, hooksCode);
  console.log(`‚ú® Generated React Query hooks: ${hooksOutputFile}`);

  console.log("");
  console.log("üì¶ Generated APIs:");
  for (const service of allServices) {
    console.log(`   - ${toCamelCase(service.name.replace("Service", ""))} (${service.methods.length} methods)`);
  }
}

main();
