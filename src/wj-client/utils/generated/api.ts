// Auto-generated REST API Client from Protobuf Definitions
// DO NOT EDIT - This file is generated by api/scripts/generate-rest-api.js
// Generated at: 2026-02-11T04:38:54.277Z

import { apiClient } from "../api-client";
import type { ResponseType } from "./hooks.types";

import type { RegisterRequest, RegisterResponse, LoginData, LoginRequest, LoginResponse, LogoutRequest, LogoutResponse, VerifyAuthRequest, VerifyAuthResponse, User, GetAuthRequest, GetAuthResponse } from "@/gen/protobuf/v1/auth";
import type { GetBudgetRequest, GetBudgetResponse, Budget, ListBudgetsRequest, ListBudgetsResponse, CreateBudgetRequest, CreateBudgetResponse, UpdateBudgetRequest, UpdateBudgetResponse, DeleteBudgetRequest, DeleteBudgetResponse, GetBudgetItemsRequest, GetBudgetItemsResponse, CreateBudgetItemRequest, CreateBudgetItemResponse, BudgetItem, UpdateBudgetItemRequest, UpdateBudgetItemResponse, DeleteBudgetItemRequest, DeleteBudgetItemResponse } from "@/gen/protobuf/v1/budget";
import type { ListInvestmentsRequest, ListInvestmentsResponse, Investment, GetInvestmentRequest, GetInvestmentResponse, CreateInvestmentRequest, CreateInvestmentResponse, UpdateInvestmentRequest, UpdateInvestmentResponse, DeleteInvestmentRequest, DeleteInvestmentResponse, AddTransactionRequest, AddTransactionResponse, InvestmentTransaction, ListInvestmentTransactionsRequest, ListInvestmentTransactionsResponse, EditInvestmentTransactionRequest, EditInvestmentTransactionResponse, DeleteInvestmentTransactionRequest, DeleteInvestmentTransactionResponse, GetPortfolioSummaryRequest, GetPortfolioSummaryResponse, PortfolioSummary, UpdatePricesRequest, UpdatePricesResponse, SearchSymbolsRequest, SearchSymbolsResponse, SearchResult, ListUserInvestmentsRequest, ListUserInvestmentsResponse, GetAggregatedPortfolioSummaryRequest, GetGoldTypeCodesRequest, GetGoldTypeCodesResponse, GoldTypeCode, GetSilverTypeCodesRequest, GetSilverTypeCodesResponse, SilverTypeCode, GetHistoricalPortfolioValuesRequest, GetHistoricalPortfolioValuesResponse, HistoricalPortfolioValue, GetMarketPriceRequest, GetMarketPriceResponse, MarketPrice } from "@/gen/protobuf/v1/investment";
import type { ListSessionsRequest, ListSessionsResponse, RevokeSessionRequest, RevokeSessionResponse, RevokeAllSessionsRequest, RevokeAllSessionsResponse } from "@/gen/protobuf/v1/session";
import type { GetTransactionRequest, GetTransactionResponse, Transaction, ListTransactionsRequest, ListTransactionsResponse, CreateTransactionRequest, CreateTransactionResponse, UpdateTransactionRequest, UpdateTransactionResponse, DeleteTransactionRequest, DeleteTransactionResponse, GetAvailableYearsRequest, GetAvailableYearsResponse, GetFinancialReportRequest, GetFinancialReportResponse, GetCategoryBreakdownRequest, GetCategoryBreakdownResponse, GetCategoryRequest, GetCategoryResponse, Category, ListCategoriesRequest, ListCategoriesResponse, CreateCategoryRequest, CreateCategoryResponse, UpdateCategoryRequest, UpdateCategoryResponse, DeleteCategoryRequest, DeleteCategoryResponse } from "@/gen/protobuf/v1/transaction";
import type { GetUserRequest, GetUserResponse, GetUserByEmailRequest, GetUserByEmailResponse, ListUsersRequest, ListUsersResponse, CreateUserRequest, CreateUserResponse, UpdateUserRequest, UpdateUserResponse, DeleteUserRequest, DeleteUserResponse, UpdatePreferencesRequest, UpdatePreferencesResponse } from "@/gen/protobuf/v1/user";
import type { GetWalletRequest, GetWalletResponse, Wallet, ListWalletsRequest, ListWalletsResponse, CreateWalletRequest, CreateWalletResponse, UpdateWalletRequest, UpdateWalletResponse, DeleteWalletRequest, DeleteWalletResponse, AddFundsRequest, AddFundsResponse, WithdrawFundsRequest, WithdrawFundsResponse, TransferFundsRequest, TransferFundsResponse, AdjustBalanceRequest, AdjustBalanceResponse, GetTotalBalanceRequest, GetTotalBalanceResponse, GetBalanceHistoryRequest, GetBalanceHistoryResponse, BalanceDataPoint, GetMonthlyDominanceRequest, GetMonthlyDominanceResponse, WalletMonthlyData } from "@/gen/protobuf/v1/wallet";
import type { Money } from "@/gen/protobuf/v1/common";

// ============================================================================
// REST API CLIENT (Auto-generated)
// ============================================================================

export const api = {
  /**
   * Auth service for user authentication operations. API
   */
  auth: {
    /**
     * Register a new user using Google OAuth token
     * POST /api/v1/auth/register
     */
    async register(request: RegisterRequest): Promise<RegisterResponse> {
      return apiClient.post(`/api/v1/auth/register`, request) as unknown as RegisterResponse;
    },

    /**
     * Login using Google OAuth token
     * POST /api/v1/auth/login
     */
    async login(request: LoginRequest): Promise<LoginResponse> {
      return apiClient.post(`/api/v1/auth/login`, request) as unknown as LoginResponse;
    },

    /**
     * Logout and invalidate token
     * POST /api/v1/auth/logout
     */
    async logout(request: LogoutRequest): Promise<LogoutResponse> {
      return apiClient.post(`/api/v1/auth/logout`, request) as unknown as LogoutResponse;
    },

    /**
     * Verify authentication status
     * GET /api/v1/auth/verify
     */
    async verifyAuth(request: VerifyAuthRequest): Promise<VerifyAuthResponse> {
      function toQueryParams(obj: any, parentKey = ''): string {
        const params: string[] = [];
        for (const [key, value] of Object.entries(obj)) {
          if (value === undefined || value === null) continue;
          if (typeof value === 'object' && !Array.isArray(value)) {
            // For nested objects like 'filter' and 'pagination', flatten them
            if (key === 'filter' || key === 'pagination') {
              params.push(toQueryParams(value, ''));
            } else {
              params.push(toQueryParams(value, key));
            }
          } else {
            // Convert camelCase to snake_case
            const snakeKey = key.replace(/([A-Z])/g, '_$1').toLowerCase();
            const fullKey = parentKey ? `${parentKey}.${snakeKey}` : snakeKey;
            let paramValue: string | number;
            // For numeric enums, pass as-is (backend handles numeric values)
            // For string enums (if any), convert to simplified form
            if (typeof value === 'string') {
              // Convert enum values like CATEGORY_TYPE_INCOME -> INCOME
              paramValue = value
                .replace(/^CATEGORY_TYPE_/, '')
                .replace(/^TRANSACTION_TYPE_/, '')
                .replace(/^SORT_FIELD_/, '');
            } else if (typeof value === 'boolean') {
              paramValue = value ? 'true' : 'false';
            } else {
              paramValue = value as string | number;
            }
            params.push(`${fullKey}=${encodeURIComponent(paramValue)}`);
          }
        }
        return params.join('&');
      }
      const queryString = request ? toQueryParams(request) : '';
      const endpoint = `/api/v1/auth/verify${queryString ? `?${queryString}` : ""}`;
      return apiClient.get(endpoint) as unknown as VerifyAuthResponse;
    },

    /**
     * Get authenticated user information
     * GET /api/v1/auth
     */
    async getAuth(request: GetAuthRequest): Promise<GetAuthResponse> {
      function toQueryParams(obj: any, parentKey = ''): string {
        const params: string[] = [];
        for (const [key, value] of Object.entries(obj)) {
          if (value === undefined || value === null) continue;
          if (typeof value === 'object' && !Array.isArray(value)) {
            // For nested objects like 'filter' and 'pagination', flatten them
            if (key === 'filter' || key === 'pagination') {
              params.push(toQueryParams(value, ''));
            } else {
              params.push(toQueryParams(value, key));
            }
          } else {
            // Convert camelCase to snake_case
            const snakeKey = key.replace(/([A-Z])/g, '_$1').toLowerCase();
            const fullKey = parentKey ? `${parentKey}.${snakeKey}` : snakeKey;
            let paramValue: string | number;
            // For numeric enums, pass as-is (backend handles numeric values)
            // For string enums (if any), convert to simplified form
            if (typeof value === 'string') {
              // Convert enum values like CATEGORY_TYPE_INCOME -> INCOME
              paramValue = value
                .replace(/^CATEGORY_TYPE_/, '')
                .replace(/^TRANSACTION_TYPE_/, '')
                .replace(/^SORT_FIELD_/, '');
            } else if (typeof value === 'boolean') {
              paramValue = value ? 'true' : 'false';
            } else {
              paramValue = value as string | number;
            }
            params.push(`${fullKey}=${encodeURIComponent(paramValue)}`);
          }
        }
        return params.join('&');
      }
      const queryString = request ? toQueryParams(request) : '';
      const endpoint = `/api/v1/auth${queryString ? `?${queryString}` : ""}`;
      return apiClient.get(endpoint) as unknown as GetAuthResponse;
    },

  },

  /**
   * Budget service for budget management operations API
   */
  budget: {
    /**
     * Get a budget by ID
     * GET /api/v1/budgets/{budgetId}
     */
    async getBudget(request: GetBudgetRequest): Promise<GetBudgetResponse> {
      const endpoint = `/api/v1/budgets/${request.budgetId}`;
      return apiClient.get(endpoint) as unknown as GetBudgetResponse;
    },

    /**
     * List all budgets for authenticated user with pagination
     * GET /api/v1/budgets
     */
    async listBudgets(request: ListBudgetsRequest): Promise<ListBudgetsResponse> {
      function toQueryParams(obj: any, parentKey = ''): string {
        const params: string[] = [];
        for (const [key, value] of Object.entries(obj)) {
          if (value === undefined || value === null) continue;
          if (typeof value === 'object' && !Array.isArray(value)) {
            // For nested objects like 'filter' and 'pagination', flatten them
            if (key === 'filter' || key === 'pagination') {
              params.push(toQueryParams(value, ''));
            } else {
              params.push(toQueryParams(value, key));
            }
          } else {
            // Convert camelCase to snake_case
            const snakeKey = key.replace(/([A-Z])/g, '_$1').toLowerCase();
            const fullKey = parentKey ? `${parentKey}.${snakeKey}` : snakeKey;
            let paramValue: string | number;
            // For numeric enums, pass as-is (backend handles numeric values)
            // For string enums (if any), convert to simplified form
            if (typeof value === 'string') {
              // Convert enum values like CATEGORY_TYPE_INCOME -> INCOME
              paramValue = value
                .replace(/^CATEGORY_TYPE_/, '')
                .replace(/^TRANSACTION_TYPE_/, '')
                .replace(/^SORT_FIELD_/, '');
            } else if (typeof value === 'boolean') {
              paramValue = value ? 'true' : 'false';
            } else {
              paramValue = value as string | number;
            }
            params.push(`${fullKey}=${encodeURIComponent(paramValue)}`);
          }
        }
        return params.join('&');
      }
      const queryString = request ? toQueryParams(request) : '';
      const endpoint = `/api/v1/budgets${queryString ? `?${queryString}` : ""}`;
      return apiClient.get(endpoint) as unknown as ListBudgetsResponse;
    },

    /**
     * Create a new budget
     * POST /api/v1/budgets
     */
    async createBudget(request: CreateBudgetRequest): Promise<CreateBudgetResponse> {
      return apiClient.post(`/api/v1/budgets`, request) as unknown as CreateBudgetResponse;
    },

    /**
     * Update budget information
     * PUT /api/v1/budgets/{budgetId}
     */
    async updateBudget(request: UpdateBudgetRequest): Promise<UpdateBudgetResponse> {
      const endpoint = `/api/v1/budgets/${request.budgetId}`;
      return apiClient.put(endpoint, request) as unknown as UpdateBudgetResponse;
    },

    /**
     * Delete a budget
     * DELETE /api/v1/budgets/{budgetId}
     */
    async deleteBudget(request: DeleteBudgetRequest): Promise<DeleteBudgetResponse> {
      const endpoint = `/api/v1/budgets/${request.budgetId}`;
      return apiClient.delete(endpoint) as unknown as DeleteBudgetResponse;
    },

    /**
     * Get budget items for a budget
     * GET /api/v1/budgets/{budgetId}/items
     */
    async getBudgetItems(request: GetBudgetItemsRequest): Promise<GetBudgetItemsResponse> {
      const endpoint = `/api/v1/budgets/${request.budgetId}/items`;
      return apiClient.get(endpoint) as unknown as GetBudgetItemsResponse;
    },

    /**
     * Create a budget item
     * POST /api/v1/budgets/{budgetId}/items
     */
    async createBudgetItem(request: CreateBudgetItemRequest): Promise<CreateBudgetItemResponse> {
      const endpoint = `/api/v1/budgets/${request.budgetId}/items`;
      return apiClient.post(endpoint, request) as unknown as CreateBudgetItemResponse;
    },

    /**
     * Update a budget item
     * PUT /api/v1/budgets/{budgetId}/items/{itemId}
     */
    async updateBudgetItem(request: UpdateBudgetItemRequest): Promise<UpdateBudgetItemResponse> {
      const endpoint = `/api/v1/budgets/${request.budgetId}/items/${request.itemId}`;
      return apiClient.put(endpoint, request) as unknown as UpdateBudgetItemResponse;
    },

    /**
     * Delete a budget item
     * DELETE /api/v1/budgets/{budgetId}/items/{itemId}
     */
    async deleteBudgetItem(request: DeleteBudgetItemRequest): Promise<DeleteBudgetItemResponse> {
      const endpoint = `/api/v1/budgets/${request.budgetId}/items/${request.itemId}`;
      return apiClient.delete(endpoint) as unknown as DeleteBudgetItemResponse;
    },

  },

  /**
   * Service definition API
   */
  investment: {
    /**
     * List all investments in a wallet
     * GET /api/v1/wallets/{walletId}/investments
     */
    async listInvestments(request: ListInvestmentsRequest): Promise<ListInvestmentsResponse> {
      const endpoint = `/api/v1/wallets/${request.walletId}/investments`;
      return apiClient.get(endpoint) as unknown as ListInvestmentsResponse;
    },

    /**
     * Get a specific investment
     * GET /api/v1/investments/{id}
     */
    async getInvestment(request: GetInvestmentRequest): Promise<GetInvestmentResponse> {
      const endpoint = `/api/v1/investments/${request.id}`;
      return apiClient.get(endpoint) as unknown as GetInvestmentResponse;
    },

    /**
     * Create a new investment holding
     * POST /api/v1/investments
     */
    async createInvestment(request: CreateInvestmentRequest): Promise<CreateInvestmentResponse> {
      return apiClient.post(`/api/v1/investments`, request) as unknown as CreateInvestmentResponse;
    },

    /**
     * Update investment details
     * PUT /api/v1/investments/{id}
     */
    async updateInvestment(request: UpdateInvestmentRequest): Promise<UpdateInvestmentResponse> {
      const endpoint = `/api/v1/investments/${request.id}`;
      return apiClient.put(endpoint, request) as unknown as UpdateInvestmentResponse;
    },

    /**
     * Delete an investment
     * DELETE /api/v1/investments/{id}
     */
    async deleteInvestment(request: DeleteInvestmentRequest): Promise<DeleteInvestmentResponse> {
      const endpoint = `/api/v1/investments/${request.id}`;
      return apiClient.delete(endpoint) as unknown as DeleteInvestmentResponse;
    },

    /**
     * Add a buy/sell transaction
     * POST /api/v1/investments/{investmentId}/transactions
     */
    async addInvestmentTransaction(request: AddTransactionRequest): Promise<AddTransactionResponse> {
      const endpoint = `/api/v1/investments/${request.investmentId}/transactions`;
      return apiClient.post(endpoint, request) as unknown as AddTransactionResponse;
    },

    /**
     * List transactions for an investment
     * GET /api/v1/investments/{investmentId}/transactions
     */
    async listInvestmentTransactions(request: ListInvestmentTransactionsRequest): Promise<ListInvestmentTransactionsResponse> {
      const endpoint = `/api/v1/investments/${request.investmentId}/transactions`;
      return apiClient.get(endpoint) as unknown as ListInvestmentTransactionsResponse;
    },

    /**
     * Edit a transaction
     * PUT /api/v1/investment-transactions/{id}
     */
    async editInvestmentTransaction(request: EditInvestmentTransactionRequest): Promise<EditInvestmentTransactionResponse> {
      const endpoint = `/api/v1/investment-transactions/${request.id}`;
      return apiClient.put(endpoint, request) as unknown as EditInvestmentTransactionResponse;
    },

    /**
     * Delete a transaction
     * DELETE /api/v1/investment-transactions/{id}
     */
    async deleteInvestmentTransaction(request: DeleteInvestmentTransactionRequest): Promise<DeleteInvestmentTransactionResponse> {
      const endpoint = `/api/v1/investment-transactions/${request.id}`;
      return apiClient.delete(endpoint) as unknown as DeleteInvestmentTransactionResponse;
    },

    /**
     * Get portfolio summary
     * GET /api/v1/wallets/{walletId}/portfolio-summary
     */
    async getPortfolioSummary(request: GetPortfolioSummaryRequest): Promise<GetPortfolioSummaryResponse> {
      const endpoint = `/api/v1/wallets/${request.walletId}/portfolio-summary`;
      return apiClient.get(endpoint) as unknown as GetPortfolioSummaryResponse;
    },

    /**
     * Update current prices (manual or automatic)
     * POST /api/v1/investments/update-prices
     */
    async updatePrices(request: UpdatePricesRequest): Promise<UpdatePricesResponse> {
      return apiClient.post(`/api/v1/investments/update-prices`, request) as unknown as UpdatePricesResponse;
    },

    /**
     * SearchSymbols searches for investment symbols by query
     * GET /api/v1/investments/symbols/search
     */
    async searchSymbols(request: SearchSymbolsRequest): Promise<SearchSymbolsResponse> {
      function toQueryParams(obj: any, parentKey = ''): string {
        const params: string[] = [];
        for (const [key, value] of Object.entries(obj)) {
          if (value === undefined || value === null) continue;
          if (typeof value === 'object' && !Array.isArray(value)) {
            // For nested objects like 'filter' and 'pagination', flatten them
            if (key === 'filter' || key === 'pagination') {
              params.push(toQueryParams(value, ''));
            } else {
              params.push(toQueryParams(value, key));
            }
          } else {
            // Convert camelCase to snake_case
            const snakeKey = key.replace(/([A-Z])/g, '_$1').toLowerCase();
            const fullKey = parentKey ? `${parentKey}.${snakeKey}` : snakeKey;
            let paramValue: string | number;
            // For numeric enums, pass as-is (backend handles numeric values)
            // For string enums (if any), convert to simplified form
            if (typeof value === 'string') {
              // Convert enum values like CATEGORY_TYPE_INCOME -> INCOME
              paramValue = value
                .replace(/^CATEGORY_TYPE_/, '')
                .replace(/^TRANSACTION_TYPE_/, '')
                .replace(/^SORT_FIELD_/, '');
            } else if (typeof value === 'boolean') {
              paramValue = value ? 'true' : 'false';
            } else {
              paramValue = value as string | number;
            }
            params.push(`${fullKey}=${encodeURIComponent(paramValue)}`);
          }
        }
        return params.join('&');
      }
      const queryString = request ? toQueryParams(request) : '';
      const endpoint = `/api/v1/investments/symbols/search${queryString ? `?${queryString}` : ""}`;
      return apiClient.get(endpoint) as unknown as SearchSymbolsResponse;
    },

    /**
     * List all user investments across all wallets (or filtered by wallet)
     * GET /api/v1/investments
     */
    async listUserInvestments(request: ListUserInvestmentsRequest): Promise<ListUserInvestmentsResponse> {
      function toQueryParams(obj: any, parentKey = ''): string {
        const params: string[] = [];
        for (const [key, value] of Object.entries(obj)) {
          if (value === undefined || value === null) continue;
          if (typeof value === 'object' && !Array.isArray(value)) {
            // For nested objects like 'filter' and 'pagination', flatten them
            if (key === 'filter' || key === 'pagination') {
              params.push(toQueryParams(value, ''));
            } else {
              params.push(toQueryParams(value, key));
            }
          } else {
            // Convert camelCase to snake_case
            const snakeKey = key.replace(/([A-Z])/g, '_$1').toLowerCase();
            const fullKey = parentKey ? `${parentKey}.${snakeKey}` : snakeKey;
            let paramValue: string | number;
            // For numeric enums, pass as-is (backend handles numeric values)
            // For string enums (if any), convert to simplified form
            if (typeof value === 'string') {
              // Convert enum values like CATEGORY_TYPE_INCOME -> INCOME
              paramValue = value
                .replace(/^CATEGORY_TYPE_/, '')
                .replace(/^TRANSACTION_TYPE_/, '')
                .replace(/^SORT_FIELD_/, '');
            } else if (typeof value === 'boolean') {
              paramValue = value ? 'true' : 'false';
            } else {
              paramValue = value as string | number;
            }
            params.push(`${fullKey}=${encodeURIComponent(paramValue)}`);
          }
        }
        return params.join('&');
      }
      const queryString = request ? toQueryParams(request) : '';
      const endpoint = `/api/v1/investments${queryString ? `?${queryString}` : ""}`;
      return apiClient.get(endpoint) as unknown as ListUserInvestmentsResponse;
    },

    /**
     * Get aggregated portfolio summary across all wallets (or for specific wallet)
     * GET /api/v1/portfolio-summary
     */
    async getAggregatedPortfolioSummary(request: GetAggregatedPortfolioSummaryRequest): Promise<GetPortfolioSummaryResponse> {
      function toQueryParams(obj: any, parentKey = ''): string {
        const params: string[] = [];
        for (const [key, value] of Object.entries(obj)) {
          if (value === undefined || value === null) continue;
          if (typeof value === 'object' && !Array.isArray(value)) {
            // For nested objects like 'filter' and 'pagination', flatten them
            if (key === 'filter' || key === 'pagination') {
              params.push(toQueryParams(value, ''));
            } else {
              params.push(toQueryParams(value, key));
            }
          } else {
            // Convert camelCase to snake_case
            const snakeKey = key.replace(/([A-Z])/g, '_$1').toLowerCase();
            const fullKey = parentKey ? `${parentKey}.${snakeKey}` : snakeKey;
            let paramValue: string | number;
            // For numeric enums, pass as-is (backend handles numeric values)
            // For string enums (if any), convert to simplified form
            if (typeof value === 'string') {
              // Convert enum values like CATEGORY_TYPE_INCOME -> INCOME
              paramValue = value
                .replace(/^CATEGORY_TYPE_/, '')
                .replace(/^TRANSACTION_TYPE_/, '')
                .replace(/^SORT_FIELD_/, '');
            } else if (typeof value === 'boolean') {
              paramValue = value ? 'true' : 'false';
            } else {
              paramValue = value as string | number;
            }
            params.push(`${fullKey}=${encodeURIComponent(paramValue)}`);
          }
        }
        return params.join('&');
      }
      const queryString = request ? toQueryParams(request) : '';
      const endpoint = `/api/v1/portfolio-summary${queryString ? `?${queryString}` : ""}`;
      return apiClient.get(endpoint) as unknown as GetPortfolioSummaryResponse;
    },

    /**
     * Used for frontend dropdown selection of gold investments
     * GET /api/v1/investments/gold-types
     */
    async getGoldTypeCodes(request: GetGoldTypeCodesRequest): Promise<GetGoldTypeCodesResponse> {
      function toQueryParams(obj: any, parentKey = ''): string {
        const params: string[] = [];
        for (const [key, value] of Object.entries(obj)) {
          if (value === undefined || value === null) continue;
          if (typeof value === 'object' && !Array.isArray(value)) {
            // For nested objects like 'filter' and 'pagination', flatten them
            if (key === 'filter' || key === 'pagination') {
              params.push(toQueryParams(value, ''));
            } else {
              params.push(toQueryParams(value, key));
            }
          } else {
            // Convert camelCase to snake_case
            const snakeKey = key.replace(/([A-Z])/g, '_$1').toLowerCase();
            const fullKey = parentKey ? `${parentKey}.${snakeKey}` : snakeKey;
            let paramValue: string | number;
            // For numeric enums, pass as-is (backend handles numeric values)
            // For string enums (if any), convert to simplified form
            if (typeof value === 'string') {
              // Convert enum values like CATEGORY_TYPE_INCOME -> INCOME
              paramValue = value
                .replace(/^CATEGORY_TYPE_/, '')
                .replace(/^TRANSACTION_TYPE_/, '')
                .replace(/^SORT_FIELD_/, '');
            } else if (typeof value === 'boolean') {
              paramValue = value ? 'true' : 'false';
            } else {
              paramValue = value as string | number;
            }
            params.push(`${fullKey}=${encodeURIComponent(paramValue)}`);
          }
        }
        return params.join('&');
      }
      const queryString = request ? toQueryParams(request) : '';
      const endpoint = `/api/v1/investments/gold-types${queryString ? `?${queryString}` : ""}`;
      return apiClient.get(endpoint) as unknown as GetGoldTypeCodesResponse;
    },

    /**
     * Used for frontend dropdown selection of silver investments
     * GET /api/v1/investments/silver-types
     */
    async getSilverTypeCodes(request: GetSilverTypeCodesRequest): Promise<GetSilverTypeCodesResponse> {
      function toQueryParams(obj: any, parentKey = ''): string {
        const params: string[] = [];
        for (const [key, value] of Object.entries(obj)) {
          if (value === undefined || value === null) continue;
          if (typeof value === 'object' && !Array.isArray(value)) {
            // For nested objects like 'filter' and 'pagination', flatten them
            if (key === 'filter' || key === 'pagination') {
              params.push(toQueryParams(value, ''));
            } else {
              params.push(toQueryParams(value, key));
            }
          } else {
            // Convert camelCase to snake_case
            const snakeKey = key.replace(/([A-Z])/g, '_$1').toLowerCase();
            const fullKey = parentKey ? `${parentKey}.${snakeKey}` : snakeKey;
            let paramValue: string | number;
            // For numeric enums, pass as-is (backend handles numeric values)
            // For string enums (if any), convert to simplified form
            if (typeof value === 'string') {
              // Convert enum values like CATEGORY_TYPE_INCOME -> INCOME
              paramValue = value
                .replace(/^CATEGORY_TYPE_/, '')
                .replace(/^TRANSACTION_TYPE_/, '')
                .replace(/^SORT_FIELD_/, '');
            } else if (typeof value === 'boolean') {
              paramValue = value ? 'true' : 'false';
            } else {
              paramValue = value as string | number;
            }
            params.push(`${fullKey}=${encodeURIComponent(paramValue)}`);
          }
        }
        return params.join('&');
      }
      const queryString = request ? toQueryParams(request) : '';
      const endpoint = `/api/v1/investments/silver-types${queryString ? `?${queryString}` : ""}`;
      return apiClient.get(endpoint) as unknown as GetSilverTypeCodesResponse;
    },

    /**
     * GetHistoricalPortfolioValues returns historical portfolio value snapshots
     * GET /api/v1/portfolio/historical-values
     */
    async getHistoricalPortfolioValues(request: GetHistoricalPortfolioValuesRequest): Promise<GetHistoricalPortfolioValuesResponse> {
      function toQueryParams(obj: any, parentKey = ''): string {
        const params: string[] = [];
        for (const [key, value] of Object.entries(obj)) {
          if (value === undefined || value === null) continue;
          if (typeof value === 'object' && !Array.isArray(value)) {
            // For nested objects like 'filter' and 'pagination', flatten them
            if (key === 'filter' || key === 'pagination') {
              params.push(toQueryParams(value, ''));
            } else {
              params.push(toQueryParams(value, key));
            }
          } else {
            // Convert camelCase to snake_case
            const snakeKey = key.replace(/([A-Z])/g, '_$1').toLowerCase();
            const fullKey = parentKey ? `${parentKey}.${snakeKey}` : snakeKey;
            let paramValue: string | number;
            // For numeric enums, pass as-is (backend handles numeric values)
            // For string enums (if any), convert to simplified form
            if (typeof value === 'string') {
              // Convert enum values like CATEGORY_TYPE_INCOME -> INCOME
              paramValue = value
                .replace(/^CATEGORY_TYPE_/, '')
                .replace(/^TRANSACTION_TYPE_/, '')
                .replace(/^SORT_FIELD_/, '');
            } else if (typeof value === 'boolean') {
              paramValue = value ? 'true' : 'false';
            } else {
              paramValue = value as string | number;
            }
            params.push(`${fullKey}=${encodeURIComponent(paramValue)}`);
          }
        }
        return params.join('&');
      }
      const queryString = request ? toQueryParams(request) : '';
      const endpoint = `/api/v1/portfolio/historical-values${queryString ? `?${queryString}` : ""}`;
      return apiClient.get(endpoint) as unknown as GetHistoricalPortfolioValuesResponse;
    },

    /**
     * GetMarketPrice retrieves current market price for display in forms
     * GET /api/v1/investments/market-price
     */
    async getMarketPrice(request: GetMarketPriceRequest): Promise<GetMarketPriceResponse> {
      function toQueryParams(obj: any, parentKey = ''): string {
        const params: string[] = [];
        for (const [key, value] of Object.entries(obj)) {
          if (value === undefined || value === null) continue;
          if (typeof value === 'object' && !Array.isArray(value)) {
            // For nested objects like 'filter' and 'pagination', flatten them
            if (key === 'filter' || key === 'pagination') {
              params.push(toQueryParams(value, ''));
            } else {
              params.push(toQueryParams(value, key));
            }
          } else {
            // Convert camelCase to snake_case
            const snakeKey = key.replace(/([A-Z])/g, '_$1').toLowerCase();
            const fullKey = parentKey ? `${parentKey}.${snakeKey}` : snakeKey;
            let paramValue: string | number;
            // For numeric enums, pass as-is (backend handles numeric values)
            // For string enums (if any), convert to simplified form
            if (typeof value === 'string') {
              // Convert enum values like CATEGORY_TYPE_INCOME -> INCOME
              paramValue = value
                .replace(/^CATEGORY_TYPE_/, '')
                .replace(/^TRANSACTION_TYPE_/, '')
                .replace(/^SORT_FIELD_/, '');
            } else if (typeof value === 'boolean') {
              paramValue = value ? 'true' : 'false';
            } else {
              paramValue = value as string | number;
            }
            params.push(`${fullKey}=${encodeURIComponent(paramValue)}`);
          }
        }
        return params.join('&');
      }
      const queryString = request ? toQueryParams(request) : '';
      const endpoint = `/api/v1/investments/market-price${queryString ? `?${queryString}` : ""}`;
      return apiClient.get(endpoint) as unknown as GetMarketPriceResponse;
    },

  },

  /**
   * SessionService provides session management operations API
   */
  session: {
    /**
     * ListSessions lists all active sessions for the authenticated user
     * GET /api/v1/sessions
     */
    async listSessions(request: ListSessionsRequest): Promise<ListSessionsResponse> {
      function toQueryParams(obj: any, parentKey = ''): string {
        const params: string[] = [];
        for (const [key, value] of Object.entries(obj)) {
          if (value === undefined || value === null) continue;
          if (typeof value === 'object' && !Array.isArray(value)) {
            // For nested objects like 'filter' and 'pagination', flatten them
            if (key === 'filter' || key === 'pagination') {
              params.push(toQueryParams(value, ''));
            } else {
              params.push(toQueryParams(value, key));
            }
          } else {
            // Convert camelCase to snake_case
            const snakeKey = key.replace(/([A-Z])/g, '_$1').toLowerCase();
            const fullKey = parentKey ? `${parentKey}.${snakeKey}` : snakeKey;
            let paramValue: string | number;
            // For numeric enums, pass as-is (backend handles numeric values)
            // For string enums (if any), convert to simplified form
            if (typeof value === 'string') {
              // Convert enum values like CATEGORY_TYPE_INCOME -> INCOME
              paramValue = value
                .replace(/^CATEGORY_TYPE_/, '')
                .replace(/^TRANSACTION_TYPE_/, '')
                .replace(/^SORT_FIELD_/, '');
            } else if (typeof value === 'boolean') {
              paramValue = value ? 'true' : 'false';
            } else {
              paramValue = value as string | number;
            }
            params.push(`${fullKey}=${encodeURIComponent(paramValue)}`);
          }
        }
        return params.join('&');
      }
      const queryString = request ? toQueryParams(request) : '';
      const endpoint = `/api/v1/sessions${queryString ? `?${queryString}` : ""}`;
      return apiClient.get(endpoint) as unknown as ListSessionsResponse;
    },

    /**
     * RevokeSession revokes a specific session
     * DELETE /api/v1/sessions/{session_id}
     */
    async revokeSession(request: RevokeSessionRequest): Promise<RevokeSessionResponse> {
      const endpoint = `/api/v1/sessions/${request.session_id}`;
      return apiClient.delete(endpoint) as unknown as RevokeSessionResponse;
    },

    /**
     * RevokeAllSessions revokes all sessions except the current one
     * DELETE /api/v1/sessions
     */
    async revokeAllSessions(request: RevokeAllSessionsRequest): Promise<RevokeAllSessionsResponse> {
      function toQueryParams(obj: any, parentKey = ''): string {
        const params: string[] = [];
        for (const [key, value] of Object.entries(obj)) {
          if (value === undefined || value === null) continue;
          if (typeof value === 'object' && !Array.isArray(value)) {
            // For nested objects like 'filter' and 'pagination', flatten them
            if (key === 'filter' || key === 'pagination') {
              params.push(toQueryParams(value, ''));
            } else {
              params.push(toQueryParams(value, key));
            }
          } else {
            // Convert camelCase to snake_case
            const snakeKey = key.replace(/([A-Z])/g, '_$1').toLowerCase();
            const fullKey = parentKey ? `${parentKey}.${snakeKey}` : snakeKey;
            let paramValue: string | number;
            // For numeric enums, pass as-is (backend handles numeric values)
            // For string enums (if any), convert to simplified form
            if (typeof value === 'string') {
              // Convert enum values like CATEGORY_TYPE_INCOME -> INCOME
              paramValue = value
                .replace(/^CATEGORY_TYPE_/, '')
                .replace(/^TRANSACTION_TYPE_/, '')
                .replace(/^SORT_FIELD_/, '');
            } else if (typeof value === 'boolean') {
              paramValue = value ? 'true' : 'false';
            } else {
              paramValue = value as string | number;
            }
            params.push(`${fullKey}=${encodeURIComponent(paramValue)}`);
          }
        }
        return params.join('&');
      }
      const queryString = request ? toQueryParams(request) : '';
      const endpoint = `/api/v1/sessions${queryString ? `?${queryString}` : ""}`;
      return apiClient.delete(endpoint) as unknown as RevokeAllSessionsResponse;
    },

  },

  /**
   * Transaction service for transaction management operations. API
   */
  transaction: {
    /**
     * Get a transaction by ID
     * GET /api/v1/transactions/{transactionId}
     */
    async getTransaction(request: GetTransactionRequest): Promise<GetTransactionResponse> {
      const endpoint = `/api/v1/transactions/${request.transactionId}`;
      return apiClient.get(endpoint) as unknown as GetTransactionResponse;
    },

    /**
     * List all transactions for authenticated user with advanced filtering and pagination
     * GET /api/v1/transactions
     */
    async listTransactions(request: ListTransactionsRequest): Promise<ListTransactionsResponse> {
      function toQueryParams(obj: any, parentKey = ''): string {
        const params: string[] = [];
        for (const [key, value] of Object.entries(obj)) {
          if (value === undefined || value === null) continue;
          if (typeof value === 'object' && !Array.isArray(value)) {
            // For nested objects like 'filter' and 'pagination', flatten them
            if (key === 'filter' || key === 'pagination') {
              params.push(toQueryParams(value, ''));
            } else {
              params.push(toQueryParams(value, key));
            }
          } else {
            // Convert camelCase to snake_case
            const snakeKey = key.replace(/([A-Z])/g, '_$1').toLowerCase();
            const fullKey = parentKey ? `${parentKey}.${snakeKey}` : snakeKey;
            let paramValue: string | number;
            // For numeric enums, pass as-is (backend handles numeric values)
            // For string enums (if any), convert to simplified form
            if (typeof value === 'string') {
              // Convert enum values like CATEGORY_TYPE_INCOME -> INCOME
              paramValue = value
                .replace(/^CATEGORY_TYPE_/, '')
                .replace(/^TRANSACTION_TYPE_/, '')
                .replace(/^SORT_FIELD_/, '');
            } else if (typeof value === 'boolean') {
              paramValue = value ? 'true' : 'false';
            } else {
              paramValue = value as string | number;
            }
            params.push(`${fullKey}=${encodeURIComponent(paramValue)}`);
          }
        }
        return params.join('&');
      }
      const queryString = request ? toQueryParams(request) : '';
      const endpoint = `/api/v1/transactions${queryString ? `?${queryString}` : ""}`;
      return apiClient.get(endpoint) as unknown as ListTransactionsResponse;
    },

    /**
     * Create a new transaction
     * POST /api/v1/transactions
     */
    async createTransaction(request: CreateTransactionRequest): Promise<CreateTransactionResponse> {
      return apiClient.post(`/api/v1/transactions`, request) as unknown as CreateTransactionResponse;
    },

    /**
     * Update transaction information
     * PUT /api/v1/transactions/{transactionId}
     */
    async updateTransaction(request: UpdateTransactionRequest): Promise<UpdateTransactionResponse> {
      const endpoint = `/api/v1/transactions/${request.transactionId}`;
      return apiClient.put(endpoint, request) as unknown as UpdateTransactionResponse;
    },

    /**
     * Delete a transaction
     * DELETE /api/v1/transactions/{transactionId}
     */
    async deleteTransaction(request: DeleteTransactionRequest): Promise<DeleteTransactionResponse> {
      const endpoint = `/api/v1/transactions/${request.transactionId}`;
      return apiClient.delete(endpoint) as unknown as DeleteTransactionResponse;
    },

    /**
     * Get available years from user's transactions
     * GET /api/v1/transactions/available-years
     */
    async getAvailableYears(request: GetAvailableYearsRequest): Promise<GetAvailableYearsResponse> {
      function toQueryParams(obj: any, parentKey = ''): string {
        const params: string[] = [];
        for (const [key, value] of Object.entries(obj)) {
          if (value === undefined || value === null) continue;
          if (typeof value === 'object' && !Array.isArray(value)) {
            // For nested objects like 'filter' and 'pagination', flatten them
            if (key === 'filter' || key === 'pagination') {
              params.push(toQueryParams(value, ''));
            } else {
              params.push(toQueryParams(value, key));
            }
          } else {
            // Convert camelCase to snake_case
            const snakeKey = key.replace(/([A-Z])/g, '_$1').toLowerCase();
            const fullKey = parentKey ? `${parentKey}.${snakeKey}` : snakeKey;
            let paramValue: string | number;
            // For numeric enums, pass as-is (backend handles numeric values)
            // For string enums (if any), convert to simplified form
            if (typeof value === 'string') {
              // Convert enum values like CATEGORY_TYPE_INCOME -> INCOME
              paramValue = value
                .replace(/^CATEGORY_TYPE_/, '')
                .replace(/^TRANSACTION_TYPE_/, '')
                .replace(/^SORT_FIELD_/, '');
            } else if (typeof value === 'boolean') {
              paramValue = value ? 'true' : 'false';
            } else {
              paramValue = value as string | number;
            }
            params.push(`${fullKey}=${encodeURIComponent(paramValue)}`);
          }
        }
        return params.join('&');
      }
      const queryString = request ? toQueryParams(request) : '';
      const endpoint = `/api/v1/transactions/available-years${queryString ? `?${queryString}` : ""}`;
      return apiClient.get(endpoint) as unknown as GetAvailableYearsResponse;
    },

    /**
     * Get financial report data with monthly breakdown per wallet
     * GET /api/v1/transactions/financial-report
     */
    async getFinancialReport(request: GetFinancialReportRequest): Promise<GetFinancialReportResponse> {
      function toQueryParams(obj: any, parentKey = ''): string {
        const params: string[] = [];
        for (const [key, value] of Object.entries(obj)) {
          if (value === undefined || value === null) continue;
          if (typeof value === 'object' && !Array.isArray(value)) {
            // For nested objects like 'filter' and 'pagination', flatten them
            if (key === 'filter' || key === 'pagination') {
              params.push(toQueryParams(value, ''));
            } else {
              params.push(toQueryParams(value, key));
            }
          } else {
            // Convert camelCase to snake_case
            const snakeKey = key.replace(/([A-Z])/g, '_$1').toLowerCase();
            const fullKey = parentKey ? `${parentKey}.${snakeKey}` : snakeKey;
            let paramValue: string | number;
            // For numeric enums, pass as-is (backend handles numeric values)
            // For string enums (if any), convert to simplified form
            if (typeof value === 'string') {
              // Convert enum values like CATEGORY_TYPE_INCOME -> INCOME
              paramValue = value
                .replace(/^CATEGORY_TYPE_/, '')
                .replace(/^TRANSACTION_TYPE_/, '')
                .replace(/^SORT_FIELD_/, '');
            } else if (typeof value === 'boolean') {
              paramValue = value ? 'true' : 'false';
            } else {
              paramValue = value as string | number;
            }
            params.push(`${fullKey}=${encodeURIComponent(paramValue)}`);
          }
        }
        return params.join('&');
      }
      const queryString = request ? toQueryParams(request) : '';
      const endpoint = `/api/v1/transactions/financial-report${queryString ? `?${queryString}` : ""}`;
      return apiClient.get(endpoint) as unknown as GetFinancialReportResponse;
    },

    /**
     * Get category breakdown for a date range
     * GET /api/v1/transactions/category-breakdown
     */
    async getCategoryBreakdown(request: GetCategoryBreakdownRequest): Promise<GetCategoryBreakdownResponse> {
      function toQueryParams(obj: any, parentKey = ''): string {
        const params: string[] = [];
        for (const [key, value] of Object.entries(obj)) {
          if (value === undefined || value === null) continue;
          if (typeof value === 'object' && !Array.isArray(value)) {
            // For nested objects like 'filter' and 'pagination', flatten them
            if (key === 'filter' || key === 'pagination') {
              params.push(toQueryParams(value, ''));
            } else {
              params.push(toQueryParams(value, key));
            }
          } else {
            // Convert camelCase to snake_case
            const snakeKey = key.replace(/([A-Z])/g, '_$1').toLowerCase();
            const fullKey = parentKey ? `${parentKey}.${snakeKey}` : snakeKey;
            let paramValue: string | number;
            // For numeric enums, pass as-is (backend handles numeric values)
            // For string enums (if any), convert to simplified form
            if (typeof value === 'string') {
              // Convert enum values like CATEGORY_TYPE_INCOME -> INCOME
              paramValue = value
                .replace(/^CATEGORY_TYPE_/, '')
                .replace(/^TRANSACTION_TYPE_/, '')
                .replace(/^SORT_FIELD_/, '');
            } else if (typeof value === 'boolean') {
              paramValue = value ? 'true' : 'false';
            } else {
              paramValue = value as string | number;
            }
            params.push(`${fullKey}=${encodeURIComponent(paramValue)}`);
          }
        }
        return params.join('&');
      }
      const queryString = request ? toQueryParams(request) : '';
      const endpoint = `/api/v1/transactions/category-breakdown${queryString ? `?${queryString}` : ""}`;
      return apiClient.get(endpoint) as unknown as GetCategoryBreakdownResponse;
    },

  },

  /**
   * Category service for category management operations. API
   */
  category: {
    /**
     * Get a category by ID
     * GET /api/v1/categories/{categoryId}
     */
    async getCategory(request: GetCategoryRequest): Promise<GetCategoryResponse> {
      const endpoint = `/api/v1/categories/${request.categoryId}`;
      return apiClient.get(endpoint) as unknown as GetCategoryResponse;
    },

    /**
     * List all categories for authenticated user with type filtering and pagination
     * GET /api/v1/categories
     */
    async listCategories(request: ListCategoriesRequest): Promise<ListCategoriesResponse> {
      function toQueryParams(obj: any, parentKey = ''): string {
        const params: string[] = [];
        for (const [key, value] of Object.entries(obj)) {
          if (value === undefined || value === null) continue;
          if (typeof value === 'object' && !Array.isArray(value)) {
            // For nested objects like 'filter' and 'pagination', flatten them
            if (key === 'filter' || key === 'pagination') {
              params.push(toQueryParams(value, ''));
            } else {
              params.push(toQueryParams(value, key));
            }
          } else {
            // Convert camelCase to snake_case
            const snakeKey = key.replace(/([A-Z])/g, '_$1').toLowerCase();
            const fullKey = parentKey ? `${parentKey}.${snakeKey}` : snakeKey;
            let paramValue: string | number;
            // For numeric enums, pass as-is (backend handles numeric values)
            // For string enums (if any), convert to simplified form
            if (typeof value === 'string') {
              // Convert enum values like CATEGORY_TYPE_INCOME -> INCOME
              paramValue = value
                .replace(/^CATEGORY_TYPE_/, '')
                .replace(/^TRANSACTION_TYPE_/, '')
                .replace(/^SORT_FIELD_/, '');
            } else if (typeof value === 'boolean') {
              paramValue = value ? 'true' : 'false';
            } else {
              paramValue = value as string | number;
            }
            params.push(`${fullKey}=${encodeURIComponent(paramValue)}`);
          }
        }
        return params.join('&');
      }
      const queryString = request ? toQueryParams(request) : '';
      const endpoint = `/api/v1/categories${queryString ? `?${queryString}` : ""}`;
      return apiClient.get(endpoint) as unknown as ListCategoriesResponse;
    },

    /**
     * Create a new category
     * POST /api/v1/categories
     */
    async createCategory(request: CreateCategoryRequest): Promise<CreateCategoryResponse> {
      return apiClient.post(`/api/v1/categories`, request) as unknown as CreateCategoryResponse;
    },

    /**
     * Update category information
     * PUT /api/v1/categories/{categoryId}
     */
    async updateCategory(request: UpdateCategoryRequest): Promise<UpdateCategoryResponse> {
      const endpoint = `/api/v1/categories/${request.categoryId}`;
      return apiClient.put(endpoint, request) as unknown as UpdateCategoryResponse;
    },

    /**
     * Delete a category
     * DELETE /api/v1/categories/{categoryId}
     */
    async deleteCategory(request: DeleteCategoryRequest): Promise<DeleteCategoryResponse> {
      const endpoint = `/api/v1/categories/${request.categoryId}`;
      return apiClient.delete(endpoint) as unknown as DeleteCategoryResponse;
    },

  },

  /**
   * User service for user management operations. API
   */
  user: {
    /**
     * Get the authenticated user's profile
     * GET /api/v1/users/{userId}
     */
    async getUser(request: GetUserRequest): Promise<GetUserResponse> {
      const endpoint = `/api/v1/users/${request.userId}`;
      return apiClient.get(endpoint) as unknown as GetUserResponse;
    },

    /**
     * Get a user by email
     * GET /api/v1/users/by-email/{email}
     */
    async getUserByEmail(request: GetUserByEmailRequest): Promise<GetUserByEmailResponse> {
      const endpoint = `/api/v1/users/by-email/${request.email}`;
      return apiClient.get(endpoint) as unknown as GetUserByEmailResponse;
    },

    /**
     * List all users with pagination
     * GET /api/v1/users
     */
    async listUsers(request: ListUsersRequest): Promise<ListUsersResponse> {
      function toQueryParams(obj: any, parentKey = ''): string {
        const params: string[] = [];
        for (const [key, value] of Object.entries(obj)) {
          if (value === undefined || value === null) continue;
          if (typeof value === 'object' && !Array.isArray(value)) {
            // For nested objects like 'filter' and 'pagination', flatten them
            if (key === 'filter' || key === 'pagination') {
              params.push(toQueryParams(value, ''));
            } else {
              params.push(toQueryParams(value, key));
            }
          } else {
            // Convert camelCase to snake_case
            const snakeKey = key.replace(/([A-Z])/g, '_$1').toLowerCase();
            const fullKey = parentKey ? `${parentKey}.${snakeKey}` : snakeKey;
            let paramValue: string | number;
            // For numeric enums, pass as-is (backend handles numeric values)
            // For string enums (if any), convert to simplified form
            if (typeof value === 'string') {
              // Convert enum values like CATEGORY_TYPE_INCOME -> INCOME
              paramValue = value
                .replace(/^CATEGORY_TYPE_/, '')
                .replace(/^TRANSACTION_TYPE_/, '')
                .replace(/^SORT_FIELD_/, '');
            } else if (typeof value === 'boolean') {
              paramValue = value ? 'true' : 'false';
            } else {
              paramValue = value as string | number;
            }
            params.push(`${fullKey}=${encodeURIComponent(paramValue)}`);
          }
        }
        return params.join('&');
      }
      const queryString = request ? toQueryParams(request) : '';
      const endpoint = `/api/v1/users${queryString ? `?${queryString}` : ""}`;
      return apiClient.get(endpoint) as unknown as ListUsersResponse;
    },

    /**
     * Create a new user
     * POST /api/v1/users
     */
    async createUser(request: CreateUserRequest): Promise<CreateUserResponse> {
      return apiClient.post(`/api/v1/users`, request) as unknown as CreateUserResponse;
    },

    /**
     * Update user information
     * PUT /api/v1/users/{userId}
     */
    async updateUser(request: UpdateUserRequest): Promise<UpdateUserResponse> {
      const endpoint = `/api/v1/users/${request.userId}`;
      return apiClient.put(endpoint, request) as unknown as UpdateUserResponse;
    },

    /**
     * Delete a user
     * DELETE /api/v1/users/{userId}
     */
    async deleteUser(request: DeleteUserRequest): Promise<DeleteUserResponse> {
      const endpoint = `/api/v1/users/${request.userId}`;
      return apiClient.delete(endpoint) as unknown as DeleteUserResponse;
    },

    /**
     * Update user preferences (including currency preference)
     * PUT /api/v1/users/preferences
     */
    async updatePreferences(request: UpdatePreferencesRequest): Promise<UpdatePreferencesResponse> {
      return apiClient.put(`/api/v1/users/preferences`, request) as unknown as UpdatePreferencesResponse;
    },

  },

  /**
   * Wallet service for wallet management operations. API
   */
  wallet: {
    /**
     * Get a wallet by ID
     * GET /api/v1/wallets/{walletId}
     */
    async getWallet(request: GetWalletRequest): Promise<GetWalletResponse> {
      const endpoint = `/api/v1/wallets/${request.walletId}`;
      return apiClient.get(endpoint) as unknown as GetWalletResponse;
    },

    /**
     * List all wallets for authenticated user with pagination
     * GET /api/v1/wallets
     */
    async listWallets(request: ListWalletsRequest): Promise<ListWalletsResponse> {
      function toQueryParams(obj: any, parentKey = ''): string {
        const params: string[] = [];
        for (const [key, value] of Object.entries(obj)) {
          if (value === undefined || value === null) continue;
          if (typeof value === 'object' && !Array.isArray(value)) {
            // For nested objects like 'filter' and 'pagination', flatten them
            if (key === 'filter' || key === 'pagination') {
              params.push(toQueryParams(value, ''));
            } else {
              params.push(toQueryParams(value, key));
            }
          } else {
            // Convert camelCase to snake_case
            const snakeKey = key.replace(/([A-Z])/g, '_$1').toLowerCase();
            const fullKey = parentKey ? `${parentKey}.${snakeKey}` : snakeKey;
            let paramValue: string | number;
            // For numeric enums, pass as-is (backend handles numeric values)
            // For string enums (if any), convert to simplified form
            if (typeof value === 'string') {
              // Convert enum values like CATEGORY_TYPE_INCOME -> INCOME
              paramValue = value
                .replace(/^CATEGORY_TYPE_/, '')
                .replace(/^TRANSACTION_TYPE_/, '')
                .replace(/^SORT_FIELD_/, '');
            } else if (typeof value === 'boolean') {
              paramValue = value ? 'true' : 'false';
            } else {
              paramValue = value as string | number;
            }
            params.push(`${fullKey}=${encodeURIComponent(paramValue)}`);
          }
        }
        return params.join('&');
      }
      const queryString = request ? toQueryParams(request) : '';
      const endpoint = `/api/v1/wallets${queryString ? `?${queryString}` : ""}`;
      return apiClient.get(endpoint) as unknown as ListWalletsResponse;
    },

    /**
     * Create a new wallet
     * POST /api/v1/wallets
     */
    async createWallet(request: CreateWalletRequest): Promise<CreateWalletResponse> {
      return apiClient.post(`/api/v1/wallets`, request) as unknown as CreateWalletResponse;
    },

    /**
     * Update wallet information
     * PUT /api/v1/wallets/{walletId}
     */
    async updateWallet(request: UpdateWalletRequest): Promise<UpdateWalletResponse> {
      const endpoint = `/api/v1/wallets/${request.walletId}`;
      return apiClient.put(endpoint, request) as unknown as UpdateWalletResponse;
    },

    /**
     * Delete a wallet
     * POST /api/v1/wallets/{walletId}/delete
     */
    async deleteWallet(request: DeleteWalletRequest): Promise<DeleteWalletResponse> {
      const endpoint = `/api/v1/wallets/${request.walletId}/delete`;
      return apiClient.post(endpoint, request) as unknown as DeleteWalletResponse;
    },

    /**
     * Add funds to a wallet
     * POST /api/v1/wallets/{walletId}/add
     */
    async addFunds(request: AddFundsRequest): Promise<AddFundsResponse> {
      const endpoint = `/api/v1/wallets/${request.walletId}/add`;
      return apiClient.post(endpoint, request) as unknown as AddFundsResponse;
    },

    /**
     * Withdraw funds from a wallet
     * POST /api/v1/wallets/{walletId}/withdraw
     */
    async withdrawFunds(request: WithdrawFundsRequest): Promise<WithdrawFundsResponse> {
      const endpoint = `/api/v1/wallets/${request.walletId}/withdraw`;
      return apiClient.post(endpoint, request) as unknown as WithdrawFundsResponse;
    },

    /**
     * Transfer funds between wallets
     * POST /api/v1/wallets/transfer
     */
    async transferFunds(request: TransferFundsRequest): Promise<TransferFundsResponse> {
      return apiClient.post(`/api/v1/wallets/transfer`, request) as unknown as TransferFundsResponse;
    },

    /**
     * Adjust wallet balance with audit trail
     * POST /api/v1/wallets/{walletId}/adjust
     */
    async adjustBalance(request: AdjustBalanceRequest): Promise<AdjustBalanceResponse> {
      const endpoint = `/api/v1/wallets/${request.walletId}/adjust`;
      return apiClient.post(endpoint, request) as unknown as AdjustBalanceResponse;
    },

    /**
     * Get total balance across all user wallets
     * GET /api/v1/wallets/total-balance
     */
    async getTotalBalance(request: GetTotalBalanceRequest): Promise<GetTotalBalanceResponse> {
      function toQueryParams(obj: any, parentKey = ''): string {
        const params: string[] = [];
        for (const [key, value] of Object.entries(obj)) {
          if (value === undefined || value === null) continue;
          if (typeof value === 'object' && !Array.isArray(value)) {
            // For nested objects like 'filter' and 'pagination', flatten them
            if (key === 'filter' || key === 'pagination') {
              params.push(toQueryParams(value, ''));
            } else {
              params.push(toQueryParams(value, key));
            }
          } else {
            // Convert camelCase to snake_case
            const snakeKey = key.replace(/([A-Z])/g, '_$1').toLowerCase();
            const fullKey = parentKey ? `${parentKey}.${snakeKey}` : snakeKey;
            let paramValue: string | number;
            // For numeric enums, pass as-is (backend handles numeric values)
            // For string enums (if any), convert to simplified form
            if (typeof value === 'string') {
              // Convert enum values like CATEGORY_TYPE_INCOME -> INCOME
              paramValue = value
                .replace(/^CATEGORY_TYPE_/, '')
                .replace(/^TRANSACTION_TYPE_/, '')
                .replace(/^SORT_FIELD_/, '');
            } else if (typeof value === 'boolean') {
              paramValue = value ? 'true' : 'false';
            } else {
              paramValue = value as string | number;
            }
            params.push(`${fullKey}=${encodeURIComponent(paramValue)}`);
          }
        }
        return params.join('&');
      }
      const queryString = request ? toQueryParams(request) : '';
      const endpoint = `/api/v1/wallets/total-balance${queryString ? `?${queryString}` : ""}`;
      return apiClient.get(endpoint) as unknown as GetTotalBalanceResponse;
    },

    /**
     * Get balance history for chart visualization
     * GET /api/v1/wallets/balance-history
     */
    async getBalanceHistory(request: GetBalanceHistoryRequest): Promise<GetBalanceHistoryResponse> {
      function toQueryParams(obj: any, parentKey = ''): string {
        const params: string[] = [];
        for (const [key, value] of Object.entries(obj)) {
          if (value === undefined || value === null) continue;
          if (typeof value === 'object' && !Array.isArray(value)) {
            // For nested objects like 'filter' and 'pagination', flatten them
            if (key === 'filter' || key === 'pagination') {
              params.push(toQueryParams(value, ''));
            } else {
              params.push(toQueryParams(value, key));
            }
          } else {
            // Convert camelCase to snake_case
            const snakeKey = key.replace(/([A-Z])/g, '_$1').toLowerCase();
            const fullKey = parentKey ? `${parentKey}.${snakeKey}` : snakeKey;
            let paramValue: string | number;
            // For numeric enums, pass as-is (backend handles numeric values)
            // For string enums (if any), convert to simplified form
            if (typeof value === 'string') {
              // Convert enum values like CATEGORY_TYPE_INCOME -> INCOME
              paramValue = value
                .replace(/^CATEGORY_TYPE_/, '')
                .replace(/^TRANSACTION_TYPE_/, '')
                .replace(/^SORT_FIELD_/, '');
            } else if (typeof value === 'boolean') {
              paramValue = value ? 'true' : 'false';
            } else {
              paramValue = value as string | number;
            }
            params.push(`${fullKey}=${encodeURIComponent(paramValue)}`);
          }
        }
        return params.join('&');
      }
      const queryString = request ? toQueryParams(request) : '';
      const endpoint = `/api/v1/wallets/balance-history${queryString ? `?${queryString}` : ""}`;
      return apiClient.get(endpoint) as unknown as GetBalanceHistoryResponse;
    },

    /**
     * Get monthly dominance data showing each wallet's balance over time
     * GET /api/v1/wallets/monthly-dominance
     */
    async getMonthlyDominance(request: GetMonthlyDominanceRequest): Promise<GetMonthlyDominanceResponse> {
      function toQueryParams(obj: any, parentKey = ''): string {
        const params: string[] = [];
        for (const [key, value] of Object.entries(obj)) {
          if (value === undefined || value === null) continue;
          if (typeof value === 'object' && !Array.isArray(value)) {
            // For nested objects like 'filter' and 'pagination', flatten them
            if (key === 'filter' || key === 'pagination') {
              params.push(toQueryParams(value, ''));
            } else {
              params.push(toQueryParams(value, key));
            }
          } else {
            // Convert camelCase to snake_case
            const snakeKey = key.replace(/([A-Z])/g, '_$1').toLowerCase();
            const fullKey = parentKey ? `${parentKey}.${snakeKey}` : snakeKey;
            let paramValue: string | number;
            // For numeric enums, pass as-is (backend handles numeric values)
            // For string enums (if any), convert to simplified form
            if (typeof value === 'string') {
              // Convert enum values like CATEGORY_TYPE_INCOME -> INCOME
              paramValue = value
                .replace(/^CATEGORY_TYPE_/, '')
                .replace(/^TRANSACTION_TYPE_/, '')
                .replace(/^SORT_FIELD_/, '');
            } else if (typeof value === 'boolean') {
              paramValue = value ? 'true' : 'false';
            } else {
              paramValue = value as string | number;
            }
            params.push(`${fullKey}=${encodeURIComponent(paramValue)}`);
          }
        }
        return params.join('&');
      }
      const queryString = request ? toQueryParams(request) : '';
      const endpoint = `/api/v1/wallets/monthly-dominance${queryString ? `?${queryString}` : ""}`;
      return apiClient.get(endpoint) as unknown as GetMonthlyDominanceResponse;
    },

  },

};

export default api;