// Auto-generated REST API Client from Protobuf Definitions
// DO NOT EDIT - This file is generated by api/scripts/generate-rest-api.js
// Generated at: 2026-01-19T08:46:52.465Z

import { apiClient } from "../api-client";
import type { ResponseType } from "./hooks.types";

import type { RegisterRequest, RegisterResponse, User, LoginRequest, LoginResponse, LoginData, LogoutRequest, LogoutResponse, VerifyAuthRequest, VerifyAuthResponse, GetAuthRequest, GetAuthResponse } from "@/gen/protobuf/v1/auth";
import type { GetTransactionRequest, GetTransactionResponse, Transaction, ListTransactionsRequest, ListTransactionsResponse, CreateTransactionRequest, CreateTransactionResponse, UpdateTransactionRequest, UpdateTransactionResponse, DeleteTransactionRequest, DeleteTransactionResponse, GetAvailableYearsRequest, GetAvailableYearsResponse, GetFinancialReportRequest, GetFinancialReportResponse, GetCategoryRequest, GetCategoryResponse, Category, ListCategoriesRequest, ListCategoriesResponse, CreateCategoryRequest, CreateCategoryResponse, UpdateCategoryRequest, UpdateCategoryResponse, DeleteCategoryRequest, DeleteCategoryResponse } from "@/gen/protobuf/v1/transaction";
import type { GetUserRequest, GetUserResponse, GetUserByEmailRequest, GetUserByEmailResponse, ListUsersRequest, ListUsersResponse, CreateUserRequest, CreateUserResponse, UpdateUserRequest, UpdateUserResponse, DeleteUserRequest, DeleteUserResponse } from "@/gen/protobuf/v1/user";
import type { GetWalletRequest, GetWalletResponse, Wallet, ListWalletsRequest, ListWalletsResponse, CreateWalletRequest, CreateWalletResponse, UpdateWalletRequest, UpdateWalletResponse, DeleteWalletRequest, DeleteWalletResponse, AddFundsRequest, AddFundsResponse, WithdrawFundsRequest, WithdrawFundsResponse, TransferFundsRequest, TransferFundsResponse, GetTotalBalanceRequest, GetTotalBalanceResponse, GetBalanceHistoryRequest, GetBalanceHistoryResponse, BalanceDataPoint, GetMonthlyDominanceRequest, GetMonthlyDominanceResponse, WalletMonthlyData } from "@/gen/protobuf/v1/wallet";
import type { Money } from "@/gen/protobuf/v1/common";

// ============================================================================
// REST API CLIENT (Auto-generated)
// ============================================================================

export const api = {
  /**
   * Auth service for user authentication operations. API
   */
  auth: {
    /**
     * Register a new user using Google OAuth token
     * POST /api/v1/auth/register
     */
    async register(request: RegisterRequest): Promise<RegisterResponse> {
      return apiClient.post(`/api/v1/auth/register`, request) as unknown as RegisterResponse;
    },

    /**
     * Login using Google OAuth token
     * POST /api/v1/auth/login
     */
    async login(request: LoginRequest): Promise<LoginResponse> {
      return apiClient.post(`/api/v1/auth/login`, request) as unknown as LoginResponse;
    },

    /**
     * Logout and invalidate token
     * POST /api/v1/auth/logout
     */
    async logout(request: LogoutRequest): Promise<LogoutResponse> {
      return apiClient.post(`/api/v1/auth/logout`, request) as unknown as LogoutResponse;
    },

    /**
     * Verify authentication status
     * GET /api/v1/auth/verify
     */
    async verifyAuth(request: VerifyAuthRequest): Promise<VerifyAuthResponse> {
      function toQueryParams(obj: any, parentKey = ''): string {
        const params: string[] = [];
        for (const [key, value] of Object.entries(obj)) {
          if (value === undefined || value === null) continue;
          if (typeof value === 'object' && !Array.isArray(value)) {
            // For nested objects like 'filter' and 'pagination', flatten them
            if (key === 'filter' || key === 'pagination') {
              params.push(toQueryParams(value, ''));
            } else {
              params.push(toQueryParams(value, key));
            }
          } else {
            // Convert camelCase to snake_case
            const snakeKey = key.replace(/([A-Z])/g, '_$1').toLowerCase();
            const fullKey = parentKey ? `${parentKey}.${snakeKey}` : snakeKey;
            let paramValue: string | number;
            // For numeric enums, pass as-is (backend handles numeric values)
            // For string enums (if any), convert to simplified form
            if (typeof value === 'string') {
              // Convert enum values like CATEGORY_TYPE_INCOME -> INCOME
              paramValue = value
                .replace(/^CATEGORY_TYPE_/, '')
                .replace(/^TRANSACTION_TYPE_/, '')
                .replace(/^SORT_FIELD_/, '');
            } else if (typeof value === 'boolean') {
              paramValue = value ? 'true' : 'false';
            } else {
              paramValue = value as string | number;
            }
            params.push(`${fullKey}=${encodeURIComponent(paramValue)}`);
          }
        }
        return params.join('&');
      }
      const queryString = request ? toQueryParams(request) : '';
      const endpoint = `/api/v1/auth/verify${queryString ? `?${queryString}` : ""}`;
      return apiClient.get(endpoint) as unknown as VerifyAuthResponse;
    },

    /**
     * Get authenticated user information
     * GET /api/v1/auth
     */
    async getAuth(request: GetAuthRequest): Promise<GetAuthResponse> {
      function toQueryParams(obj: any, parentKey = ''): string {
        const params: string[] = [];
        for (const [key, value] of Object.entries(obj)) {
          if (value === undefined || value === null) continue;
          if (typeof value === 'object' && !Array.isArray(value)) {
            // For nested objects like 'filter' and 'pagination', flatten them
            if (key === 'filter' || key === 'pagination') {
              params.push(toQueryParams(value, ''));
            } else {
              params.push(toQueryParams(value, key));
            }
          } else {
            // Convert camelCase to snake_case
            const snakeKey = key.replace(/([A-Z])/g, '_$1').toLowerCase();
            const fullKey = parentKey ? `${parentKey}.${snakeKey}` : snakeKey;
            let paramValue: string | number;
            // For numeric enums, pass as-is (backend handles numeric values)
            // For string enums (if any), convert to simplified form
            if (typeof value === 'string') {
              // Convert enum values like CATEGORY_TYPE_INCOME -> INCOME
              paramValue = value
                .replace(/^CATEGORY_TYPE_/, '')
                .replace(/^TRANSACTION_TYPE_/, '')
                .replace(/^SORT_FIELD_/, '');
            } else if (typeof value === 'boolean') {
              paramValue = value ? 'true' : 'false';
            } else {
              paramValue = value as string | number;
            }
            params.push(`${fullKey}=${encodeURIComponent(paramValue)}`);
          }
        }
        return params.join('&');
      }
      const queryString = request ? toQueryParams(request) : '';
      const endpoint = `/api/v1/auth${queryString ? `?${queryString}` : ""}`;
      return apiClient.get(endpoint) as unknown as GetAuthResponse;
    },

  },

  /**
   * Transaction service for transaction management operations. API
   */
  transaction: {
    /**
     * Get a transaction by ID
     * GET /api/v1/transactions/{transactionId}
     */
    async getTransaction(request: GetTransactionRequest): Promise<GetTransactionResponse> {
      const endpoint = `/api/v1/transactions/${request.transactionId}`;
      return apiClient.get(endpoint) as unknown as GetTransactionResponse;
    },

    /**
     * List all transactions for authenticated user with advanced filtering and pagination
     * GET /api/v1/transactions
     */
    async listTransactions(request: ListTransactionsRequest): Promise<ListTransactionsResponse> {
      function toQueryParams(obj: any, parentKey = ''): string {
        const params: string[] = [];
        for (const [key, value] of Object.entries(obj)) {
          if (value === undefined || value === null) continue;
          if (typeof value === 'object' && !Array.isArray(value)) {
            // For nested objects like 'filter' and 'pagination', flatten them
            if (key === 'filter' || key === 'pagination') {
              params.push(toQueryParams(value, ''));
            } else {
              params.push(toQueryParams(value, key));
            }
          } else {
            // Convert camelCase to snake_case
            const snakeKey = key.replace(/([A-Z])/g, '_$1').toLowerCase();
            const fullKey = parentKey ? `${parentKey}.${snakeKey}` : snakeKey;
            let paramValue: string | number;
            // For numeric enums, pass as-is (backend handles numeric values)
            // For string enums (if any), convert to simplified form
            if (typeof value === 'string') {
              // Convert enum values like CATEGORY_TYPE_INCOME -> INCOME
              paramValue = value
                .replace(/^CATEGORY_TYPE_/, '')
                .replace(/^TRANSACTION_TYPE_/, '')
                .replace(/^SORT_FIELD_/, '');
            } else if (typeof value === 'boolean') {
              paramValue = value ? 'true' : 'false';
            } else {
              paramValue = value as string | number;
            }
            params.push(`${fullKey}=${encodeURIComponent(paramValue)}`);
          }
        }
        return params.join('&');
      }
      const queryString = request ? toQueryParams(request) : '';
      const endpoint = `/api/v1/transactions${queryString ? `?${queryString}` : ""}`;
      return apiClient.get(endpoint) as unknown as ListTransactionsResponse;
    },

    /**
     * Create a new transaction
     * POST /api/v1/transactions
     */
    async createTransaction(request: CreateTransactionRequest): Promise<CreateTransactionResponse> {
      return apiClient.post(`/api/v1/transactions`, request) as unknown as CreateTransactionResponse;
    },

    /**
     * Update transaction information
     * PUT /api/v1/transactions/{transactionId}
     */
    async updateTransaction(request: UpdateTransactionRequest): Promise<UpdateTransactionResponse> {
      const endpoint = `/api/v1/transactions/${request.transactionId}`;
      return apiClient.put(endpoint, request) as unknown as UpdateTransactionResponse;
    },

    /**
     * Delete a transaction
     * DELETE /api/v1/transactions/{transactionId}
     */
    async deleteTransaction(request: DeleteTransactionRequest): Promise<DeleteTransactionResponse> {
      const endpoint = `/api/v1/transactions/${request.transactionId}`;
      return apiClient.delete(endpoint) as unknown as DeleteTransactionResponse;
    },

    /**
     * Get available years from user's transactions
     * GET /api/v1/transactions/available-years
     */
    async getAvailableYears(request: GetAvailableYearsRequest): Promise<GetAvailableYearsResponse> {
      function toQueryParams(obj: any, parentKey = ''): string {
        const params: string[] = [];
        for (const [key, value] of Object.entries(obj)) {
          if (value === undefined || value === null) continue;
          if (typeof value === 'object' && !Array.isArray(value)) {
            // For nested objects like 'filter' and 'pagination', flatten them
            if (key === 'filter' || key === 'pagination') {
              params.push(toQueryParams(value, ''));
            } else {
              params.push(toQueryParams(value, key));
            }
          } else {
            // Convert camelCase to snake_case
            const snakeKey = key.replace(/([A-Z])/g, '_$1').toLowerCase();
            const fullKey = parentKey ? `${parentKey}.${snakeKey}` : snakeKey;
            let paramValue: string | number;
            // For numeric enums, pass as-is (backend handles numeric values)
            // For string enums (if any), convert to simplified form
            if (typeof value === 'string') {
              // Convert enum values like CATEGORY_TYPE_INCOME -> INCOME
              paramValue = value
                .replace(/^CATEGORY_TYPE_/, '')
                .replace(/^TRANSACTION_TYPE_/, '')
                .replace(/^SORT_FIELD_/, '');
            } else if (typeof value === 'boolean') {
              paramValue = value ? 'true' : 'false';
            } else {
              paramValue = value as string | number;
            }
            params.push(`${fullKey}=${encodeURIComponent(paramValue)}`);
          }
        }
        return params.join('&');
      }
      const queryString = request ? toQueryParams(request) : '';
      const endpoint = `/api/v1/transactions/available-years${queryString ? `?${queryString}` : ""}`;
      return apiClient.get(endpoint) as unknown as GetAvailableYearsResponse;
    },

    /**
     * Get financial report data with monthly breakdown per wallet
     * GET /api/v1/transactions/financial-report
     */
    async getFinancialReport(request: GetFinancialReportRequest): Promise<GetFinancialReportResponse> {
      function toQueryParams(obj: any, parentKey = ''): string {
        const params: string[] = [];
        for (const [key, value] of Object.entries(obj)) {
          if (value === undefined || value === null) continue;
          if (typeof value === 'object' && !Array.isArray(value)) {
            // For nested objects like 'filter' and 'pagination', flatten them
            if (key === 'filter' || key === 'pagination') {
              params.push(toQueryParams(value, ''));
            } else {
              params.push(toQueryParams(value, key));
            }
          } else {
            // Convert camelCase to snake_case
            const snakeKey = key.replace(/([A-Z])/g, '_$1').toLowerCase();
            const fullKey = parentKey ? `${parentKey}.${snakeKey}` : snakeKey;
            let paramValue: string | number;
            // For numeric enums, pass as-is (backend handles numeric values)
            // For string enums (if any), convert to simplified form
            if (typeof value === 'string') {
              // Convert enum values like CATEGORY_TYPE_INCOME -> INCOME
              paramValue = value
                .replace(/^CATEGORY_TYPE_/, '')
                .replace(/^TRANSACTION_TYPE_/, '')
                .replace(/^SORT_FIELD_/, '');
            } else if (typeof value === 'boolean') {
              paramValue = value ? 'true' : 'false';
            } else {
              paramValue = value as string | number;
            }
            params.push(`${fullKey}=${encodeURIComponent(paramValue)}`);
          }
        }
        return params.join('&');
      }
      const queryString = request ? toQueryParams(request) : '';
      const endpoint = `/api/v1/transactions/financial-report${queryString ? `?${queryString}` : ""}`;
      return apiClient.get(endpoint) as unknown as GetFinancialReportResponse;
    },

  },

  /**
   * Category service for category management operations. API
   */
  category: {
    /**
     * Get a category by ID
     * GET /api/v1/categories/{categoryId}
     */
    async getCategory(request: GetCategoryRequest): Promise<GetCategoryResponse> {
      const endpoint = `/api/v1/categories/${request.categoryId}`;
      return apiClient.get(endpoint) as unknown as GetCategoryResponse;
    },

    /**
     * List all categories for authenticated user with type filtering and pagination
     * GET /api/v1/categories
     */
    async listCategories(request: ListCategoriesRequest): Promise<ListCategoriesResponse> {
      function toQueryParams(obj: any, parentKey = ''): string {
        const params: string[] = [];
        for (const [key, value] of Object.entries(obj)) {
          if (value === undefined || value === null) continue;
          if (typeof value === 'object' && !Array.isArray(value)) {
            // For nested objects like 'filter' and 'pagination', flatten them
            if (key === 'filter' || key === 'pagination') {
              params.push(toQueryParams(value, ''));
            } else {
              params.push(toQueryParams(value, key));
            }
          } else {
            // Convert camelCase to snake_case
            const snakeKey = key.replace(/([A-Z])/g, '_$1').toLowerCase();
            const fullKey = parentKey ? `${parentKey}.${snakeKey}` : snakeKey;
            let paramValue: string | number;
            // For numeric enums, pass as-is (backend handles numeric values)
            // For string enums (if any), convert to simplified form
            if (typeof value === 'string') {
              // Convert enum values like CATEGORY_TYPE_INCOME -> INCOME
              paramValue = value
                .replace(/^CATEGORY_TYPE_/, '')
                .replace(/^TRANSACTION_TYPE_/, '')
                .replace(/^SORT_FIELD_/, '');
            } else if (typeof value === 'boolean') {
              paramValue = value ? 'true' : 'false';
            } else {
              paramValue = value as string | number;
            }
            params.push(`${fullKey}=${encodeURIComponent(paramValue)}`);
          }
        }
        return params.join('&');
      }
      const queryString = request ? toQueryParams(request) : '';
      const endpoint = `/api/v1/categories${queryString ? `?${queryString}` : ""}`;
      return apiClient.get(endpoint) as unknown as ListCategoriesResponse;
    },

    /**
     * Create a new category
     * POST /api/v1/categories
     */
    async createCategory(request: CreateCategoryRequest): Promise<CreateCategoryResponse> {
      return apiClient.post(`/api/v1/categories`, request) as unknown as CreateCategoryResponse;
    },

    /**
     * Update category information
     * PUT /api/v1/categories/{categoryId}
     */
    async updateCategory(request: UpdateCategoryRequest): Promise<UpdateCategoryResponse> {
      const endpoint = `/api/v1/categories/${request.categoryId}`;
      return apiClient.put(endpoint, request) as unknown as UpdateCategoryResponse;
    },

    /**
     * Delete a category
     * DELETE /api/v1/categories/{categoryId}
     */
    async deleteCategory(request: DeleteCategoryRequest): Promise<DeleteCategoryResponse> {
      const endpoint = `/api/v1/categories/${request.categoryId}`;
      return apiClient.delete(endpoint) as unknown as DeleteCategoryResponse;
    },

  },

  /**
   * User service for user management operations. API
   */
  user: {
    /**
     * Get the authenticated user's profile
     * GET /api/v1/users/{userId}
     */
    async getUser(request: GetUserRequest): Promise<GetUserResponse> {
      const endpoint = `/api/v1/users/${request.userId}`;
      return apiClient.get(endpoint) as unknown as GetUserResponse;
    },

    /**
     * Get a user by email
     * GET /api/v1/users/by-email/{email}
     */
    async getUserByEmail(request: GetUserByEmailRequest): Promise<GetUserByEmailResponse> {
      const endpoint = `/api/v1/users/by-email/${request.email}`;
      return apiClient.get(endpoint) as unknown as GetUserByEmailResponse;
    },

    /**
     * List all users with pagination
     * GET /api/v1/users
     */
    async listUsers(request: ListUsersRequest): Promise<ListUsersResponse> {
      function toQueryParams(obj: any, parentKey = ''): string {
        const params: string[] = [];
        for (const [key, value] of Object.entries(obj)) {
          if (value === undefined || value === null) continue;
          if (typeof value === 'object' && !Array.isArray(value)) {
            // For nested objects like 'filter' and 'pagination', flatten them
            if (key === 'filter' || key === 'pagination') {
              params.push(toQueryParams(value, ''));
            } else {
              params.push(toQueryParams(value, key));
            }
          } else {
            // Convert camelCase to snake_case
            const snakeKey = key.replace(/([A-Z])/g, '_$1').toLowerCase();
            const fullKey = parentKey ? `${parentKey}.${snakeKey}` : snakeKey;
            let paramValue: string | number;
            // For numeric enums, pass as-is (backend handles numeric values)
            // For string enums (if any), convert to simplified form
            if (typeof value === 'string') {
              // Convert enum values like CATEGORY_TYPE_INCOME -> INCOME
              paramValue = value
                .replace(/^CATEGORY_TYPE_/, '')
                .replace(/^TRANSACTION_TYPE_/, '')
                .replace(/^SORT_FIELD_/, '');
            } else if (typeof value === 'boolean') {
              paramValue = value ? 'true' : 'false';
            } else {
              paramValue = value as string | number;
            }
            params.push(`${fullKey}=${encodeURIComponent(paramValue)}`);
          }
        }
        return params.join('&');
      }
      const queryString = request ? toQueryParams(request) : '';
      const endpoint = `/api/v1/users${queryString ? `?${queryString}` : ""}`;
      return apiClient.get(endpoint) as unknown as ListUsersResponse;
    },

    /**
     * Create a new user
     * POST /api/v1/users
     */
    async createUser(request: CreateUserRequest): Promise<CreateUserResponse> {
      return apiClient.post(`/api/v1/users`, request) as unknown as CreateUserResponse;
    },

    /**
     * Update user information
     * PUT /api/v1/users/{userId}
     */
    async updateUser(request: UpdateUserRequest): Promise<UpdateUserResponse> {
      const endpoint = `/api/v1/users/${request.userId}`;
      return apiClient.put(endpoint, request) as unknown as UpdateUserResponse;
    },

    /**
     * Delete a user
     * DELETE /api/v1/users/{userId}
     */
    async deleteUser(request: DeleteUserRequest): Promise<DeleteUserResponse> {
      const endpoint = `/api/v1/users/${request.userId}`;
      return apiClient.delete(endpoint) as unknown as DeleteUserResponse;
    },

  },

  /**
   * Wallet service for wallet management operations. API
   */
  wallet: {
    /**
     * Get a wallet by ID
     * GET /api/v1/wallets/{walletId}
     */
    async getWallet(request: GetWalletRequest): Promise<GetWalletResponse> {
      const endpoint = `/api/v1/wallets/${request.walletId}`;
      return apiClient.get(endpoint) as unknown as GetWalletResponse;
    },

    /**
     * List all wallets for authenticated user with pagination
     * GET /api/v1/wallets
     */
    async listWallets(request: ListWalletsRequest): Promise<ListWalletsResponse> {
      function toQueryParams(obj: any, parentKey = ''): string {
        const params: string[] = [];
        for (const [key, value] of Object.entries(obj)) {
          if (value === undefined || value === null) continue;
          if (typeof value === 'object' && !Array.isArray(value)) {
            // For nested objects like 'filter' and 'pagination', flatten them
            if (key === 'filter' || key === 'pagination') {
              params.push(toQueryParams(value, ''));
            } else {
              params.push(toQueryParams(value, key));
            }
          } else {
            // Convert camelCase to snake_case
            const snakeKey = key.replace(/([A-Z])/g, '_$1').toLowerCase();
            const fullKey = parentKey ? `${parentKey}.${snakeKey}` : snakeKey;
            let paramValue: string | number;
            // For numeric enums, pass as-is (backend handles numeric values)
            // For string enums (if any), convert to simplified form
            if (typeof value === 'string') {
              // Convert enum values like CATEGORY_TYPE_INCOME -> INCOME
              paramValue = value
                .replace(/^CATEGORY_TYPE_/, '')
                .replace(/^TRANSACTION_TYPE_/, '')
                .replace(/^SORT_FIELD_/, '');
            } else if (typeof value === 'boolean') {
              paramValue = value ? 'true' : 'false';
            } else {
              paramValue = value as string | number;
            }
            params.push(`${fullKey}=${encodeURIComponent(paramValue)}`);
          }
        }
        return params.join('&');
      }
      const queryString = request ? toQueryParams(request) : '';
      const endpoint = `/api/v1/wallets${queryString ? `?${queryString}` : ""}`;
      return apiClient.get(endpoint) as unknown as ListWalletsResponse;
    },

    /**
     * Create a new wallet
     * POST /api/v1/wallets
     */
    async createWallet(request: CreateWalletRequest): Promise<CreateWalletResponse> {
      return apiClient.post(`/api/v1/wallets`, request) as unknown as CreateWalletResponse;
    },

    /**
     * Update wallet information
     * PUT /api/v1/wallets/{walletId}
     */
    async updateWallet(request: UpdateWalletRequest): Promise<UpdateWalletResponse> {
      const endpoint = `/api/v1/wallets/${request.walletId}`;
      return apiClient.put(endpoint, request) as unknown as UpdateWalletResponse;
    },

    /**
     * Delete a wallet
     * DELETE /api/v1/wallets/{walletId}
     */
    async deleteWallet(request: DeleteWalletRequest): Promise<DeleteWalletResponse> {
      const endpoint = `/api/v1/wallets/${request.walletId}`;
      return apiClient.delete(endpoint) as unknown as DeleteWalletResponse;
    },

    /**
     * Add funds to a wallet
     * POST /api/v1/wallets/{walletId}/add
     */
    async addFunds(request: AddFundsRequest): Promise<AddFundsResponse> {
      const endpoint = `/api/v1/wallets/${request.walletId}/add`;
      return apiClient.post(endpoint, request) as unknown as AddFundsResponse;
    },

    /**
     * Withdraw funds from a wallet
     * POST /api/v1/wallets/{walletId}/withdraw
     */
    async withdrawFunds(request: WithdrawFundsRequest): Promise<WithdrawFundsResponse> {
      const endpoint = `/api/v1/wallets/${request.walletId}/withdraw`;
      return apiClient.post(endpoint, request) as unknown as WithdrawFundsResponse;
    },

    /**
     * Transfer funds between wallets
     * POST /api/v1/wallets/transfer
     */
    async transferFunds(request: TransferFundsRequest): Promise<TransferFundsResponse> {
      return apiClient.post(`/api/v1/wallets/transfer`, request) as unknown as TransferFundsResponse;
    },

    /**
     * Get total balance across all user wallets
     * GET /api/v1/wallets/total-balance
     */
    async getTotalBalance(request: GetTotalBalanceRequest): Promise<GetTotalBalanceResponse> {
      function toQueryParams(obj: any, parentKey = ''): string {
        const params: string[] = [];
        for (const [key, value] of Object.entries(obj)) {
          if (value === undefined || value === null) continue;
          if (typeof value === 'object' && !Array.isArray(value)) {
            // For nested objects like 'filter' and 'pagination', flatten them
            if (key === 'filter' || key === 'pagination') {
              params.push(toQueryParams(value, ''));
            } else {
              params.push(toQueryParams(value, key));
            }
          } else {
            // Convert camelCase to snake_case
            const snakeKey = key.replace(/([A-Z])/g, '_$1').toLowerCase();
            const fullKey = parentKey ? `${parentKey}.${snakeKey}` : snakeKey;
            let paramValue: string | number;
            // For numeric enums, pass as-is (backend handles numeric values)
            // For string enums (if any), convert to simplified form
            if (typeof value === 'string') {
              // Convert enum values like CATEGORY_TYPE_INCOME -> INCOME
              paramValue = value
                .replace(/^CATEGORY_TYPE_/, '')
                .replace(/^TRANSACTION_TYPE_/, '')
                .replace(/^SORT_FIELD_/, '');
            } else if (typeof value === 'boolean') {
              paramValue = value ? 'true' : 'false';
            } else {
              paramValue = value as string | number;
            }
            params.push(`${fullKey}=${encodeURIComponent(paramValue)}`);
          }
        }
        return params.join('&');
      }
      const queryString = request ? toQueryParams(request) : '';
      const endpoint = `/api/v1/wallets/total-balance${queryString ? `?${queryString}` : ""}`;
      return apiClient.get(endpoint) as unknown as GetTotalBalanceResponse;
    },

    /**
     * Get balance history for chart visualization
     * GET /api/v1/wallets/balance-history
     */
    async getBalanceHistory(request: GetBalanceHistoryRequest): Promise<GetBalanceHistoryResponse> {
      function toQueryParams(obj: any, parentKey = ''): string {
        const params: string[] = [];
        for (const [key, value] of Object.entries(obj)) {
          if (value === undefined || value === null) continue;
          if (typeof value === 'object' && !Array.isArray(value)) {
            // For nested objects like 'filter' and 'pagination', flatten them
            if (key === 'filter' || key === 'pagination') {
              params.push(toQueryParams(value, ''));
            } else {
              params.push(toQueryParams(value, key));
            }
          } else {
            // Convert camelCase to snake_case
            const snakeKey = key.replace(/([A-Z])/g, '_$1').toLowerCase();
            const fullKey = parentKey ? `${parentKey}.${snakeKey}` : snakeKey;
            let paramValue: string | number;
            // For numeric enums, pass as-is (backend handles numeric values)
            // For string enums (if any), convert to simplified form
            if (typeof value === 'string') {
              // Convert enum values like CATEGORY_TYPE_INCOME -> INCOME
              paramValue = value
                .replace(/^CATEGORY_TYPE_/, '')
                .replace(/^TRANSACTION_TYPE_/, '')
                .replace(/^SORT_FIELD_/, '');
            } else if (typeof value === 'boolean') {
              paramValue = value ? 'true' : 'false';
            } else {
              paramValue = value as string | number;
            }
            params.push(`${fullKey}=${encodeURIComponent(paramValue)}`);
          }
        }
        return params.join('&');
      }
      const queryString = request ? toQueryParams(request) : '';
      const endpoint = `/api/v1/wallets/balance-history${queryString ? `?${queryString}` : ""}`;
      return apiClient.get(endpoint) as unknown as GetBalanceHistoryResponse;
    },

    /**
     * Get monthly dominance data showing each wallet's balance over time
     * GET /api/v1/wallets/monthly-dominance
     */
    async getMonthlyDominance(request: GetMonthlyDominanceRequest): Promise<GetMonthlyDominanceResponse> {
      function toQueryParams(obj: any, parentKey = ''): string {
        const params: string[] = [];
        for (const [key, value] of Object.entries(obj)) {
          if (value === undefined || value === null) continue;
          if (typeof value === 'object' && !Array.isArray(value)) {
            // For nested objects like 'filter' and 'pagination', flatten them
            if (key === 'filter' || key === 'pagination') {
              params.push(toQueryParams(value, ''));
            } else {
              params.push(toQueryParams(value, key));
            }
          } else {
            // Convert camelCase to snake_case
            const snakeKey = key.replace(/([A-Z])/g, '_$1').toLowerCase();
            const fullKey = parentKey ? `${parentKey}.${snakeKey}` : snakeKey;
            let paramValue: string | number;
            // For numeric enums, pass as-is (backend handles numeric values)
            // For string enums (if any), convert to simplified form
            if (typeof value === 'string') {
              // Convert enum values like CATEGORY_TYPE_INCOME -> INCOME
              paramValue = value
                .replace(/^CATEGORY_TYPE_/, '')
                .replace(/^TRANSACTION_TYPE_/, '')
                .replace(/^SORT_FIELD_/, '');
            } else if (typeof value === 'boolean') {
              paramValue = value ? 'true' : 'false';
            } else {
              paramValue = value as string | number;
            }
            params.push(`${fullKey}=${encodeURIComponent(paramValue)}`);
          }
        }
        return params.join('&');
      }
      const queryString = request ? toQueryParams(request) : '';
      const endpoint = `/api/v1/wallets/monthly-dominance${queryString ? `?${queryString}` : ""}`;
      return apiClient.get(endpoint) as unknown as GetMonthlyDominanceResponse;
    },

  },

};

export default api;