// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.11.2
//   protoc               unknown
// source: protobuf/v1/import.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import { Money, PaginationParams, PaginationResult } from "./common";
import { Transaction, TransactionType, transactionTypeFromJSON, transactionTypeToJSON } from "./transaction";

export const protobufPackage = "wealthjourney.import.v1";

export const DuplicateHandlingStrategy = {
  DUPLICATE_STRATEGY_UNSPECIFIED: 0,
  DUPLICATE_STRATEGY_AUTO_MERGE: 1,
  DUPLICATE_STRATEGY_REVIEW_EACH: 2,
  DUPLICATE_STRATEGY_KEEP_ALL: 3,
  DUPLICATE_STRATEGY_SKIP_ALL: 4,
  UNRECOGNIZED: -1,
} as const;

export type DuplicateHandlingStrategy = typeof DuplicateHandlingStrategy[keyof typeof DuplicateHandlingStrategy];

export namespace DuplicateHandlingStrategy {
  export type DUPLICATE_STRATEGY_UNSPECIFIED = typeof DuplicateHandlingStrategy.DUPLICATE_STRATEGY_UNSPECIFIED;
  export type DUPLICATE_STRATEGY_AUTO_MERGE = typeof DuplicateHandlingStrategy.DUPLICATE_STRATEGY_AUTO_MERGE;
  export type DUPLICATE_STRATEGY_REVIEW_EACH = typeof DuplicateHandlingStrategy.DUPLICATE_STRATEGY_REVIEW_EACH;
  export type DUPLICATE_STRATEGY_KEEP_ALL = typeof DuplicateHandlingStrategy.DUPLICATE_STRATEGY_KEEP_ALL;
  export type DUPLICATE_STRATEGY_SKIP_ALL = typeof DuplicateHandlingStrategy.DUPLICATE_STRATEGY_SKIP_ALL;
  export type UNRECOGNIZED = typeof DuplicateHandlingStrategy.UNRECOGNIZED;
}

export function duplicateHandlingStrategyFromJSON(object: any): DuplicateHandlingStrategy {
  switch (object) {
    case 0:
    case "DUPLICATE_STRATEGY_UNSPECIFIED":
      return DuplicateHandlingStrategy.DUPLICATE_STRATEGY_UNSPECIFIED;
    case 1:
    case "DUPLICATE_STRATEGY_AUTO_MERGE":
      return DuplicateHandlingStrategy.DUPLICATE_STRATEGY_AUTO_MERGE;
    case 2:
    case "DUPLICATE_STRATEGY_REVIEW_EACH":
      return DuplicateHandlingStrategy.DUPLICATE_STRATEGY_REVIEW_EACH;
    case 3:
    case "DUPLICATE_STRATEGY_KEEP_ALL":
      return DuplicateHandlingStrategy.DUPLICATE_STRATEGY_KEEP_ALL;
    case 4:
    case "DUPLICATE_STRATEGY_SKIP_ALL":
      return DuplicateHandlingStrategy.DUPLICATE_STRATEGY_SKIP_ALL;
    case -1:
    case "UNRECOGNIZED":
    default:
      return DuplicateHandlingStrategy.UNRECOGNIZED;
  }
}

export function duplicateHandlingStrategyToJSON(object: DuplicateHandlingStrategy): string {
  switch (object) {
    case DuplicateHandlingStrategy.DUPLICATE_STRATEGY_UNSPECIFIED:
      return "DUPLICATE_STRATEGY_UNSPECIFIED";
    case DuplicateHandlingStrategy.DUPLICATE_STRATEGY_AUTO_MERGE:
      return "DUPLICATE_STRATEGY_AUTO_MERGE";
    case DuplicateHandlingStrategy.DUPLICATE_STRATEGY_REVIEW_EACH:
      return "DUPLICATE_STRATEGY_REVIEW_EACH";
    case DuplicateHandlingStrategy.DUPLICATE_STRATEGY_KEEP_ALL:
      return "DUPLICATE_STRATEGY_KEEP_ALL";
    case DuplicateHandlingStrategy.DUPLICATE_STRATEGY_SKIP_ALL:
      return "DUPLICATE_STRATEGY_SKIP_ALL";
    case DuplicateHandlingStrategy.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export const DuplicateActionType = {
  DUPLICATE_ACTION_UNSPECIFIED: 0,
  /** DUPLICATE_ACTION_MERGE - Update existing transaction with imported data */
  DUPLICATE_ACTION_MERGE: 1,
  /** DUPLICATE_ACTION_KEEP_BOTH - Import as new transaction */
  DUPLICATE_ACTION_KEEP_BOTH: 2,
  /** DUPLICATE_ACTION_SKIP - Don't import */
  DUPLICATE_ACTION_SKIP: 3,
  /** DUPLICATE_ACTION_NOT_DUPLICATE - False positive, treat as new */
  DUPLICATE_ACTION_NOT_DUPLICATE: 4,
  UNRECOGNIZED: -1,
} as const;

export type DuplicateActionType = typeof DuplicateActionType[keyof typeof DuplicateActionType];

export namespace DuplicateActionType {
  export type DUPLICATE_ACTION_UNSPECIFIED = typeof DuplicateActionType.DUPLICATE_ACTION_UNSPECIFIED;
  export type DUPLICATE_ACTION_MERGE = typeof DuplicateActionType.DUPLICATE_ACTION_MERGE;
  export type DUPLICATE_ACTION_KEEP_BOTH = typeof DuplicateActionType.DUPLICATE_ACTION_KEEP_BOTH;
  export type DUPLICATE_ACTION_SKIP = typeof DuplicateActionType.DUPLICATE_ACTION_SKIP;
  export type DUPLICATE_ACTION_NOT_DUPLICATE = typeof DuplicateActionType.DUPLICATE_ACTION_NOT_DUPLICATE;
  export type UNRECOGNIZED = typeof DuplicateActionType.UNRECOGNIZED;
}

export function duplicateActionTypeFromJSON(object: any): DuplicateActionType {
  switch (object) {
    case 0:
    case "DUPLICATE_ACTION_UNSPECIFIED":
      return DuplicateActionType.DUPLICATE_ACTION_UNSPECIFIED;
    case 1:
    case "DUPLICATE_ACTION_MERGE":
      return DuplicateActionType.DUPLICATE_ACTION_MERGE;
    case 2:
    case "DUPLICATE_ACTION_KEEP_BOTH":
      return DuplicateActionType.DUPLICATE_ACTION_KEEP_BOTH;
    case 3:
    case "DUPLICATE_ACTION_SKIP":
      return DuplicateActionType.DUPLICATE_ACTION_SKIP;
    case 4:
    case "DUPLICATE_ACTION_NOT_DUPLICATE":
      return DuplicateActionType.DUPLICATE_ACTION_NOT_DUPLICATE;
    case -1:
    case "UNRECOGNIZED":
    default:
      return DuplicateActionType.UNRECOGNIZED;
  }
}

export function duplicateActionTypeToJSON(object: DuplicateActionType): string {
  switch (object) {
    case DuplicateActionType.DUPLICATE_ACTION_UNSPECIFIED:
      return "DUPLICATE_ACTION_UNSPECIFIED";
    case DuplicateActionType.DUPLICATE_ACTION_MERGE:
      return "DUPLICATE_ACTION_MERGE";
    case DuplicateActionType.DUPLICATE_ACTION_KEEP_BOTH:
      return "DUPLICATE_ACTION_KEEP_BOTH";
    case DuplicateActionType.DUPLICATE_ACTION_SKIP:
      return "DUPLICATE_ACTION_SKIP";
    case DuplicateActionType.DUPLICATE_ACTION_NOT_DUPLICATE:
      return "DUPLICATE_ACTION_NOT_DUPLICATE";
    case DuplicateActionType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Background Job Status */
export const JobStatus = {
  JOB_STATUS_UNSPECIFIED: 0,
  JOB_STATUS_QUEUED: 1,
  JOB_STATUS_PROCESSING: 2,
  JOB_STATUS_COMPLETED: 3,
  JOB_STATUS_FAILED: 4,
  JOB_STATUS_CANCELLED: 5,
  UNRECOGNIZED: -1,
} as const;

export type JobStatus = typeof JobStatus[keyof typeof JobStatus];

export namespace JobStatus {
  export type JOB_STATUS_UNSPECIFIED = typeof JobStatus.JOB_STATUS_UNSPECIFIED;
  export type JOB_STATUS_QUEUED = typeof JobStatus.JOB_STATUS_QUEUED;
  export type JOB_STATUS_PROCESSING = typeof JobStatus.JOB_STATUS_PROCESSING;
  export type JOB_STATUS_COMPLETED = typeof JobStatus.JOB_STATUS_COMPLETED;
  export type JOB_STATUS_FAILED = typeof JobStatus.JOB_STATUS_FAILED;
  export type JOB_STATUS_CANCELLED = typeof JobStatus.JOB_STATUS_CANCELLED;
  export type UNRECOGNIZED = typeof JobStatus.UNRECOGNIZED;
}

export function jobStatusFromJSON(object: any): JobStatus {
  switch (object) {
    case 0:
    case "JOB_STATUS_UNSPECIFIED":
      return JobStatus.JOB_STATUS_UNSPECIFIED;
    case 1:
    case "JOB_STATUS_QUEUED":
      return JobStatus.JOB_STATUS_QUEUED;
    case 2:
    case "JOB_STATUS_PROCESSING":
      return JobStatus.JOB_STATUS_PROCESSING;
    case 3:
    case "JOB_STATUS_COMPLETED":
      return JobStatus.JOB_STATUS_COMPLETED;
    case 4:
    case "JOB_STATUS_FAILED":
      return JobStatus.JOB_STATUS_FAILED;
    case 5:
    case "JOB_STATUS_CANCELLED":
      return JobStatus.JOB_STATUS_CANCELLED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return JobStatus.UNRECOGNIZED;
  }
}

export function jobStatusToJSON(object: JobStatus): string {
  switch (object) {
    case JobStatus.JOB_STATUS_UNSPECIFIED:
      return "JOB_STATUS_UNSPECIFIED";
    case JobStatus.JOB_STATUS_QUEUED:
      return "JOB_STATUS_QUEUED";
    case JobStatus.JOB_STATUS_PROCESSING:
      return "JOB_STATUS_PROCESSING";
    case JobStatus.JOB_STATUS_COMPLETED:
      return "JOB_STATUS_COMPLETED";
    case JobStatus.JOB_STATUS_FAILED:
      return "JOB_STATUS_FAILED";
    case JobStatus.JOB_STATUS_CANCELLED:
      return "JOB_STATUS_CANCELLED";
    case JobStatus.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface UploadStatementFileRequest {
  fileData: Uint8Array;
  fileName: string;
  /** csv, excel, pdf */
  fileType: string;
  fileSize: number;
}

export interface UploadStatementFileResponse {
  success: boolean;
  message: string;
  fileId: string;
  timestamp: string;
}

export interface ParseStatementRequest {
  fileId: string;
  /** Optional: e.g., "vcb-credit-card" */
  bankTemplateId: string;
  /** For custom format */
  customMapping:
    | ColumnMapping
    | undefined;
  /** Optional: specific Excel sheet to parse */
  sheetName: string;
  /** Optional: enable OCR for scanned PDFs (not implemented yet) */
  useOcr: boolean;
}

export interface ColumnMapping {
  dateColumn: string;
  amountColumn: string;
  descriptionColumn: string;
  /** Optional */
  typeColumn: string;
  /** Optional */
  categoryColumn: string;
  /** Optional */
  referenceColumn: string;
  /** e.g., "DD/MM/YYYY" */
  dateFormat: string;
  currency: string;
}

export interface ParseStatementResponse {
  success: boolean;
  message: string;
  transactions: ParsedTransaction[];
  statistics: ParseStatistics | undefined;
  currencyInfo: CurrencyInfo | undefined;
  timestamp: string;
}

export interface ParsedTransaction {
  rowNumber: number;
  /** Unix timestamp */
  date: number;
  amount: Money | undefined;
  description: string;
  type: TransactionType;
  suggestedCategoryId: number;
  /** 0-100 */
  categoryConfidence: number;
  referenceNumber: string;
  validationErrors: ValidationError[];
  isValid: boolean;
  /** Currency conversion metadata (populated after ConvertCurrency call) */
  originalAmount: Money | undefined;
  exchangeRate: number;
  /** "auto" or "manual" */
  exchangeRateSource: string;
  /** Unix timestamp */
  exchangeRateDate: number;
}

export interface ValidationError {
  field: string;
  message: string;
  /** error, warning, info */
  severity: string;
}

export interface ParseStatistics {
  totalRows: number;
  validRows: number;
  errorRows: number;
  warningRows: number;
}

export interface DetectDuplicatesRequest {
  transactions: ParsedTransaction[];
  walletId: number;
}

export interface DetectDuplicatesResponse {
  success: boolean;
  message: string;
  matches: DuplicateMatch[];
  timestamp: string;
}

export interface DuplicateMatch {
  importedTransaction: ParsedTransaction | undefined;
  existingTransaction:
    | Transaction
    | undefined;
  /** 50-100 (Level 1-4) */
  confidence: number;
  matchReason: string;
}

export interface ExecuteImportRequest {
  fileId: string;
  walletId: number;
  transactions: ParsedTransaction[];
  strategy: DuplicateHandlingStrategy;
  /** Rows user unchecked */
  excludedRowNumbers: number[];
  /** Optional date range filter */
  dateFilterStart: number;
  dateFilterEnd: number;
  /** User decisions for REVIEW_EACH strategy */
  duplicateActions: DuplicateAction[];
}

export interface DuplicateAction {
  /** Row number from parsed transaction */
  importedRowNumber: number;
  /** ID of existing transaction */
  existingTransactionId: number;
  /** User's decision */
  action: DuplicateActionType;
}

export interface ExecuteImportResponse {
  success: boolean;
  message: string;
  importBatchId: string;
  summary: ImportSummary | undefined;
  timestamp: string;
}

export interface ImportSummary {
  totalImported: number;
  totalSkipped: number;
  duplicatesMerged: number;
  duplicatesSkipped: number;
  totalIncome: Money | undefined;
  totalExpenses: Money | undefined;
  netChange: Money | undefined;
  newWalletBalance: Money | undefined;
}

export interface ListBankTemplatesRequest {
}

export interface ListBankTemplatesResponse {
  success: boolean;
  message: string;
  templates: BankTemplate[];
  timestamp: string;
}

export interface BankTemplate {
  id: string;
  name: string;
  bankCode: string;
  /** credit, debit, checking */
  statementType: string;
  fileFormats: string[];
}

export interface GetImportHistoryRequest {
  pagination: PaginationParams | undefined;
}

export interface GetImportHistoryResponse {
  success: boolean;
  message: string;
  batches: ImportBatch[];
  pagination: PaginationResult | undefined;
  timestamp: string;
}

export interface ImportBatch {
  id: string;
  userId: number;
  walletId: number;
  fileName: string;
  fileType: string;
  bankTemplate: string;
  importedAt: number;
  summary: ImportSummary | undefined;
  canUndo: boolean;
  undoExpiresAt: number;
}

export interface UndoImportRequest {
  importId: string;
}

export interface UndoImportResponse {
  success: boolean;
  message: string;
  timestamp: string;
}

export interface CurrencyInfo {
  walletCurrency: string;
  currenciesFound: string[];
  needsConversion: boolean;
}

export interface ConvertCurrencyRequest {
  walletId: number;
  transactions: ParsedTransaction[];
  /** currency -> rate */
  manualRates: { [key: string]: ManualExchangeRate };
}

export interface ConvertCurrencyRequest_ManualRatesEntry {
  key: string;
  value: ManualExchangeRate | undefined;
}

export interface ManualExchangeRate {
  fromCurrency: string;
  toCurrency: string;
  exchangeRate: number;
  /** Unix timestamp */
  rateDate: number;
}

export interface ConvertCurrencyResponse {
  success: boolean;
  message: string;
  conversions: CurrencyConversion[];
  convertedTransactions: ParsedTransaction[];
  timestamp: string;
}

export interface ListExcelSheetsRequest {
  fileId: string;
}

export interface ListExcelSheetsResponse {
  success: boolean;
  message: string;
  sheetNames: string[];
  /** Recommended sheet to use */
  defaultSheet: string;
  timestamp: string;
}

export interface CurrencyConversion {
  fromCurrency: string;
  toCurrency: string;
  exchangeRate: number;
  /** "auto" or "manual" */
  rateSource: string;
  /** Unix timestamp */
  rateDate: number;
  transactionCount: number;
  totalOriginal: Money | undefined;
  totalConverted: Money | undefined;
}

export interface CreateUserTemplateRequest {
  templateName: string;
  columnMapping: ColumnMapping | undefined;
  dateFormat: string;
  currency: string;
  /** ["csv", "excel", "pdf"] */
  fileFormats: string[];
}

export interface CreateUserTemplateResponse {
  success: boolean;
  message: string;
  template: UserTemplate | undefined;
  timestamp: string;
}

export interface ListUserTemplatesRequest {
}

export interface ListUserTemplatesResponse {
  success: boolean;
  message: string;
  templates: UserTemplate[];
  timestamp: string;
}

export interface GetUserTemplateRequest {
  templateId: number;
}

export interface GetUserTemplateResponse {
  success: boolean;
  message: string;
  template: UserTemplate | undefined;
  timestamp: string;
}

export interface UpdateUserTemplateRequest {
  templateId: number;
  templateName: string;
  columnMapping: ColumnMapping | undefined;
  dateFormat: string;
  currency: string;
  fileFormats: string[];
}

export interface UpdateUserTemplateResponse {
  success: boolean;
  message: string;
  template: UserTemplate | undefined;
  timestamp: string;
}

export interface DeleteUserTemplateRequest {
  templateId: number;
}

export interface DeleteUserTemplateResponse {
  success: boolean;
  message: string;
  timestamp: string;
}

export interface UserTemplate {
  id: number;
  userId: number;
  name: string;
  columnMapping: ColumnMapping | undefined;
  dateFormat: string;
  currency: string;
  fileFormats: string[];
  createdAt: number;
  updatedAt: number;
}

export interface GetJobStatusRequest {
  jobId: string;
}

export interface GetJobStatusResponse {
  success: boolean;
  message: string;
  job: ImportJobStatus | undefined;
  timestamp: string;
}

export interface CancelJobRequest {
  jobId: string;
}

export interface CancelJobResponse {
  success: boolean;
  message: string;
  timestamp: string;
}

export interface ListUserJobsRequest {
  /** Optional: filter by status */
  status: JobStatus;
}

export interface ListUserJobsResponse {
  success: boolean;
  message: string;
  jobs: ImportJobStatus[];
  timestamp: string;
}

export interface ImportJobStatus {
  jobId: string;
  userId: number;
  fileId: string;
  walletId: number;
  status: JobStatus;
  /** 0-100 */
  progress: number;
  processedCount: number;
  totalCount: number;
  result: ExecuteImportResponse | undefined;
  error: string;
  createdAt: number;
  startedAt: number;
  completedAt: number;
  expiresAt: number;
}

function createBaseUploadStatementFileRequest(): UploadStatementFileRequest {
  return { fileData: new Uint8Array(0), fileName: "", fileType: "", fileSize: 0 };
}

export const UploadStatementFileRequest: MessageFns<UploadStatementFileRequest> = {
  encode(message: UploadStatementFileRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.fileData.length !== 0) {
      writer.uint32(10).bytes(message.fileData);
    }
    if (message.fileName !== "") {
      writer.uint32(18).string(message.fileName);
    }
    if (message.fileType !== "") {
      writer.uint32(26).string(message.fileType);
    }
    if (message.fileSize !== 0) {
      writer.uint32(32).int64(message.fileSize);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UploadStatementFileRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUploadStatementFileRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.fileData = reader.bytes();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.fileName = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.fileType = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.fileSize = longToNumber(reader.int64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UploadStatementFileRequest {
    return {
      fileData: isSet(object.fileData)
        ? bytesFromBase64(object.fileData)
        : isSet(object.file_data)
        ? bytesFromBase64(object.file_data)
        : new Uint8Array(0),
      fileName: isSet(object.fileName)
        ? globalThis.String(object.fileName)
        : isSet(object.file_name)
        ? globalThis.String(object.file_name)
        : "",
      fileType: isSet(object.fileType)
        ? globalThis.String(object.fileType)
        : isSet(object.file_type)
        ? globalThis.String(object.file_type)
        : "",
      fileSize: isSet(object.fileSize)
        ? globalThis.Number(object.fileSize)
        : isSet(object.file_size)
        ? globalThis.Number(object.file_size)
        : 0,
    };
  },

  toJSON(message: UploadStatementFileRequest): unknown {
    const obj: any = {};
    if (message.fileData.length !== 0) {
      obj.fileData = base64FromBytes(message.fileData);
    }
    if (message.fileName !== "") {
      obj.fileName = message.fileName;
    }
    if (message.fileType !== "") {
      obj.fileType = message.fileType;
    }
    if (message.fileSize !== 0) {
      obj.fileSize = Math.round(message.fileSize);
    }
    return obj;
  },

  create(base?: DeepPartial<UploadStatementFileRequest>): UploadStatementFileRequest {
    return UploadStatementFileRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<UploadStatementFileRequest>): UploadStatementFileRequest {
    const message = createBaseUploadStatementFileRequest();
    message.fileData = object.fileData ?? new Uint8Array(0);
    message.fileName = object.fileName ?? "";
    message.fileType = object.fileType ?? "";
    message.fileSize = object.fileSize ?? 0;
    return message;
  },
};

function createBaseUploadStatementFileResponse(): UploadStatementFileResponse {
  return { success: false, message: "", fileId: "", timestamp: "" };
}

export const UploadStatementFileResponse: MessageFns<UploadStatementFileResponse> = {
  encode(message: UploadStatementFileResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    if (message.message !== "") {
      writer.uint32(18).string(message.message);
    }
    if (message.fileId !== "") {
      writer.uint32(26).string(message.fileId);
    }
    if (message.timestamp !== "") {
      writer.uint32(34).string(message.timestamp);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UploadStatementFileResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUploadStatementFileResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.message = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.fileId = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.timestamp = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UploadStatementFileResponse {
    return {
      success: isSet(object.success) ? globalThis.Boolean(object.success) : false,
      message: isSet(object.message) ? globalThis.String(object.message) : "",
      fileId: isSet(object.fileId)
        ? globalThis.String(object.fileId)
        : isSet(object.file_id)
        ? globalThis.String(object.file_id)
        : "",
      timestamp: isSet(object.timestamp) ? globalThis.String(object.timestamp) : "",
    };
  },

  toJSON(message: UploadStatementFileResponse): unknown {
    const obj: any = {};
    if (message.success !== false) {
      obj.success = message.success;
    }
    if (message.message !== "") {
      obj.message = message.message;
    }
    if (message.fileId !== "") {
      obj.fileId = message.fileId;
    }
    if (message.timestamp !== "") {
      obj.timestamp = message.timestamp;
    }
    return obj;
  },

  create(base?: DeepPartial<UploadStatementFileResponse>): UploadStatementFileResponse {
    return UploadStatementFileResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<UploadStatementFileResponse>): UploadStatementFileResponse {
    const message = createBaseUploadStatementFileResponse();
    message.success = object.success ?? false;
    message.message = object.message ?? "";
    message.fileId = object.fileId ?? "";
    message.timestamp = object.timestamp ?? "";
    return message;
  },
};

function createBaseParseStatementRequest(): ParseStatementRequest {
  return { fileId: "", bankTemplateId: "", customMapping: undefined, sheetName: "", useOcr: false };
}

export const ParseStatementRequest: MessageFns<ParseStatementRequest> = {
  encode(message: ParseStatementRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.fileId !== "") {
      writer.uint32(10).string(message.fileId);
    }
    if (message.bankTemplateId !== "") {
      writer.uint32(18).string(message.bankTemplateId);
    }
    if (message.customMapping !== undefined) {
      ColumnMapping.encode(message.customMapping, writer.uint32(26).fork()).join();
    }
    if (message.sheetName !== "") {
      writer.uint32(34).string(message.sheetName);
    }
    if (message.useOcr !== false) {
      writer.uint32(40).bool(message.useOcr);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ParseStatementRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseParseStatementRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.fileId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.bankTemplateId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.customMapping = ColumnMapping.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.sheetName = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.useOcr = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ParseStatementRequest {
    return {
      fileId: isSet(object.fileId)
        ? globalThis.String(object.fileId)
        : isSet(object.file_id)
        ? globalThis.String(object.file_id)
        : "",
      bankTemplateId: isSet(object.bankTemplateId)
        ? globalThis.String(object.bankTemplateId)
        : isSet(object.bank_template_id)
        ? globalThis.String(object.bank_template_id)
        : "",
      customMapping: isSet(object.customMapping)
        ? ColumnMapping.fromJSON(object.customMapping)
        : isSet(object.custom_mapping)
        ? ColumnMapping.fromJSON(object.custom_mapping)
        : undefined,
      sheetName: isSet(object.sheetName)
        ? globalThis.String(object.sheetName)
        : isSet(object.sheet_name)
        ? globalThis.String(object.sheet_name)
        : "",
      useOcr: isSet(object.useOcr)
        ? globalThis.Boolean(object.useOcr)
        : isSet(object.use_ocr)
        ? globalThis.Boolean(object.use_ocr)
        : false,
    };
  },

  toJSON(message: ParseStatementRequest): unknown {
    const obj: any = {};
    if (message.fileId !== "") {
      obj.fileId = message.fileId;
    }
    if (message.bankTemplateId !== "") {
      obj.bankTemplateId = message.bankTemplateId;
    }
    if (message.customMapping !== undefined) {
      obj.customMapping = ColumnMapping.toJSON(message.customMapping);
    }
    if (message.sheetName !== "") {
      obj.sheetName = message.sheetName;
    }
    if (message.useOcr !== false) {
      obj.useOcr = message.useOcr;
    }
    return obj;
  },

  create(base?: DeepPartial<ParseStatementRequest>): ParseStatementRequest {
    return ParseStatementRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ParseStatementRequest>): ParseStatementRequest {
    const message = createBaseParseStatementRequest();
    message.fileId = object.fileId ?? "";
    message.bankTemplateId = object.bankTemplateId ?? "";
    message.customMapping = (object.customMapping !== undefined && object.customMapping !== null)
      ? ColumnMapping.fromPartial(object.customMapping)
      : undefined;
    message.sheetName = object.sheetName ?? "";
    message.useOcr = object.useOcr ?? false;
    return message;
  },
};

function createBaseColumnMapping(): ColumnMapping {
  return {
    dateColumn: "",
    amountColumn: "",
    descriptionColumn: "",
    typeColumn: "",
    categoryColumn: "",
    referenceColumn: "",
    dateFormat: "",
    currency: "",
  };
}

export const ColumnMapping: MessageFns<ColumnMapping> = {
  encode(message: ColumnMapping, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.dateColumn !== "") {
      writer.uint32(10).string(message.dateColumn);
    }
    if (message.amountColumn !== "") {
      writer.uint32(18).string(message.amountColumn);
    }
    if (message.descriptionColumn !== "") {
      writer.uint32(26).string(message.descriptionColumn);
    }
    if (message.typeColumn !== "") {
      writer.uint32(34).string(message.typeColumn);
    }
    if (message.categoryColumn !== "") {
      writer.uint32(42).string(message.categoryColumn);
    }
    if (message.referenceColumn !== "") {
      writer.uint32(50).string(message.referenceColumn);
    }
    if (message.dateFormat !== "") {
      writer.uint32(58).string(message.dateFormat);
    }
    if (message.currency !== "") {
      writer.uint32(66).string(message.currency);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ColumnMapping {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseColumnMapping();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.dateColumn = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.amountColumn = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.descriptionColumn = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.typeColumn = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.categoryColumn = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.referenceColumn = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.dateFormat = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.currency = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ColumnMapping {
    return {
      dateColumn: isSet(object.dateColumn)
        ? globalThis.String(object.dateColumn)
        : isSet(object.date_column)
        ? globalThis.String(object.date_column)
        : "",
      amountColumn: isSet(object.amountColumn)
        ? globalThis.String(object.amountColumn)
        : isSet(object.amount_column)
        ? globalThis.String(object.amount_column)
        : "",
      descriptionColumn: isSet(object.descriptionColumn)
        ? globalThis.String(object.descriptionColumn)
        : isSet(object.description_column)
        ? globalThis.String(object.description_column)
        : "",
      typeColumn: isSet(object.typeColumn)
        ? globalThis.String(object.typeColumn)
        : isSet(object.type_column)
        ? globalThis.String(object.type_column)
        : "",
      categoryColumn: isSet(object.categoryColumn)
        ? globalThis.String(object.categoryColumn)
        : isSet(object.category_column)
        ? globalThis.String(object.category_column)
        : "",
      referenceColumn: isSet(object.referenceColumn)
        ? globalThis.String(object.referenceColumn)
        : isSet(object.reference_column)
        ? globalThis.String(object.reference_column)
        : "",
      dateFormat: isSet(object.dateFormat)
        ? globalThis.String(object.dateFormat)
        : isSet(object.date_format)
        ? globalThis.String(object.date_format)
        : "",
      currency: isSet(object.currency) ? globalThis.String(object.currency) : "",
    };
  },

  toJSON(message: ColumnMapping): unknown {
    const obj: any = {};
    if (message.dateColumn !== "") {
      obj.dateColumn = message.dateColumn;
    }
    if (message.amountColumn !== "") {
      obj.amountColumn = message.amountColumn;
    }
    if (message.descriptionColumn !== "") {
      obj.descriptionColumn = message.descriptionColumn;
    }
    if (message.typeColumn !== "") {
      obj.typeColumn = message.typeColumn;
    }
    if (message.categoryColumn !== "") {
      obj.categoryColumn = message.categoryColumn;
    }
    if (message.referenceColumn !== "") {
      obj.referenceColumn = message.referenceColumn;
    }
    if (message.dateFormat !== "") {
      obj.dateFormat = message.dateFormat;
    }
    if (message.currency !== "") {
      obj.currency = message.currency;
    }
    return obj;
  },

  create(base?: DeepPartial<ColumnMapping>): ColumnMapping {
    return ColumnMapping.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ColumnMapping>): ColumnMapping {
    const message = createBaseColumnMapping();
    message.dateColumn = object.dateColumn ?? "";
    message.amountColumn = object.amountColumn ?? "";
    message.descriptionColumn = object.descriptionColumn ?? "";
    message.typeColumn = object.typeColumn ?? "";
    message.categoryColumn = object.categoryColumn ?? "";
    message.referenceColumn = object.referenceColumn ?? "";
    message.dateFormat = object.dateFormat ?? "";
    message.currency = object.currency ?? "";
    return message;
  },
};

function createBaseParseStatementResponse(): ParseStatementResponse {
  return {
    success: false,
    message: "",
    transactions: [],
    statistics: undefined,
    currencyInfo: undefined,
    timestamp: "",
  };
}

export const ParseStatementResponse: MessageFns<ParseStatementResponse> = {
  encode(message: ParseStatementResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    if (message.message !== "") {
      writer.uint32(18).string(message.message);
    }
    for (const v of message.transactions) {
      ParsedTransaction.encode(v!, writer.uint32(26).fork()).join();
    }
    if (message.statistics !== undefined) {
      ParseStatistics.encode(message.statistics, writer.uint32(34).fork()).join();
    }
    if (message.currencyInfo !== undefined) {
      CurrencyInfo.encode(message.currencyInfo, writer.uint32(42).fork()).join();
    }
    if (message.timestamp !== "") {
      writer.uint32(50).string(message.timestamp);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ParseStatementResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseParseStatementResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.message = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.transactions.push(ParsedTransaction.decode(reader, reader.uint32()));
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.statistics = ParseStatistics.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.currencyInfo = CurrencyInfo.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.timestamp = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ParseStatementResponse {
    return {
      success: isSet(object.success) ? globalThis.Boolean(object.success) : false,
      message: isSet(object.message) ? globalThis.String(object.message) : "",
      transactions: globalThis.Array.isArray(object?.transactions)
        ? object.transactions.map((e: any) => ParsedTransaction.fromJSON(e))
        : [],
      statistics: isSet(object.statistics) ? ParseStatistics.fromJSON(object.statistics) : undefined,
      currencyInfo: isSet(object.currencyInfo)
        ? CurrencyInfo.fromJSON(object.currencyInfo)
        : isSet(object.currency_info)
        ? CurrencyInfo.fromJSON(object.currency_info)
        : undefined,
      timestamp: isSet(object.timestamp) ? globalThis.String(object.timestamp) : "",
    };
  },

  toJSON(message: ParseStatementResponse): unknown {
    const obj: any = {};
    if (message.success !== false) {
      obj.success = message.success;
    }
    if (message.message !== "") {
      obj.message = message.message;
    }
    if (message.transactions?.length) {
      obj.transactions = message.transactions.map((e) => ParsedTransaction.toJSON(e));
    }
    if (message.statistics !== undefined) {
      obj.statistics = ParseStatistics.toJSON(message.statistics);
    }
    if (message.currencyInfo !== undefined) {
      obj.currencyInfo = CurrencyInfo.toJSON(message.currencyInfo);
    }
    if (message.timestamp !== "") {
      obj.timestamp = message.timestamp;
    }
    return obj;
  },

  create(base?: DeepPartial<ParseStatementResponse>): ParseStatementResponse {
    return ParseStatementResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ParseStatementResponse>): ParseStatementResponse {
    const message = createBaseParseStatementResponse();
    message.success = object.success ?? false;
    message.message = object.message ?? "";
    message.transactions = object.transactions?.map((e) => ParsedTransaction.fromPartial(e)) || [];
    message.statistics = (object.statistics !== undefined && object.statistics !== null)
      ? ParseStatistics.fromPartial(object.statistics)
      : undefined;
    message.currencyInfo = (object.currencyInfo !== undefined && object.currencyInfo !== null)
      ? CurrencyInfo.fromPartial(object.currencyInfo)
      : undefined;
    message.timestamp = object.timestamp ?? "";
    return message;
  },
};

function createBaseParsedTransaction(): ParsedTransaction {
  return {
    rowNumber: 0,
    date: 0,
    amount: undefined,
    description: "",
    type: 0,
    suggestedCategoryId: 0,
    categoryConfidence: 0,
    referenceNumber: "",
    validationErrors: [],
    isValid: false,
    originalAmount: undefined,
    exchangeRate: 0,
    exchangeRateSource: "",
    exchangeRateDate: 0,
  };
}

export const ParsedTransaction: MessageFns<ParsedTransaction> = {
  encode(message: ParsedTransaction, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.rowNumber !== 0) {
      writer.uint32(8).int32(message.rowNumber);
    }
    if (message.date !== 0) {
      writer.uint32(16).int64(message.date);
    }
    if (message.amount !== undefined) {
      Money.encode(message.amount, writer.uint32(26).fork()).join();
    }
    if (message.description !== "") {
      writer.uint32(34).string(message.description);
    }
    if (message.type !== 0) {
      writer.uint32(40).int32(message.type);
    }
    if (message.suggestedCategoryId !== 0) {
      writer.uint32(48).int32(message.suggestedCategoryId);
    }
    if (message.categoryConfidence !== 0) {
      writer.uint32(56).int32(message.categoryConfidence);
    }
    if (message.referenceNumber !== "") {
      writer.uint32(66).string(message.referenceNumber);
    }
    for (const v of message.validationErrors) {
      ValidationError.encode(v!, writer.uint32(74).fork()).join();
    }
    if (message.isValid !== false) {
      writer.uint32(80).bool(message.isValid);
    }
    if (message.originalAmount !== undefined) {
      Money.encode(message.originalAmount, writer.uint32(90).fork()).join();
    }
    if (message.exchangeRate !== 0) {
      writer.uint32(97).double(message.exchangeRate);
    }
    if (message.exchangeRateSource !== "") {
      writer.uint32(106).string(message.exchangeRateSource);
    }
    if (message.exchangeRateDate !== 0) {
      writer.uint32(112).int64(message.exchangeRateDate);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ParsedTransaction {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseParsedTransaction();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.rowNumber = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.date = longToNumber(reader.int64());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.amount = Money.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.description = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.type = reader.int32() as any;
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.suggestedCategoryId = reader.int32();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.categoryConfidence = reader.int32();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.referenceNumber = reader.string();
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.validationErrors.push(ValidationError.decode(reader, reader.uint32()));
          continue;
        }
        case 10: {
          if (tag !== 80) {
            break;
          }

          message.isValid = reader.bool();
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.originalAmount = Money.decode(reader, reader.uint32());
          continue;
        }
        case 12: {
          if (tag !== 97) {
            break;
          }

          message.exchangeRate = reader.double();
          continue;
        }
        case 13: {
          if (tag !== 106) {
            break;
          }

          message.exchangeRateSource = reader.string();
          continue;
        }
        case 14: {
          if (tag !== 112) {
            break;
          }

          message.exchangeRateDate = longToNumber(reader.int64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ParsedTransaction {
    return {
      rowNumber: isSet(object.rowNumber)
        ? globalThis.Number(object.rowNumber)
        : isSet(object.row_number)
        ? globalThis.Number(object.row_number)
        : 0,
      date: isSet(object.date) ? globalThis.Number(object.date) : 0,
      amount: isSet(object.amount) ? Money.fromJSON(object.amount) : undefined,
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      type: isSet(object.type) ? transactionTypeFromJSON(object.type) : 0,
      suggestedCategoryId: isSet(object.suggestedCategoryId)
        ? globalThis.Number(object.suggestedCategoryId)
        : isSet(object.suggested_category_id)
        ? globalThis.Number(object.suggested_category_id)
        : 0,
      categoryConfidence: isSet(object.categoryConfidence)
        ? globalThis.Number(object.categoryConfidence)
        : isSet(object.category_confidence)
        ? globalThis.Number(object.category_confidence)
        : 0,
      referenceNumber: isSet(object.referenceNumber)
        ? globalThis.String(object.referenceNumber)
        : isSet(object.reference_number)
        ? globalThis.String(object.reference_number)
        : "",
      validationErrors: globalThis.Array.isArray(object?.validationErrors)
        ? object.validationErrors.map((e: any) => ValidationError.fromJSON(e))
        : globalThis.Array.isArray(object?.validation_errors)
        ? object.validation_errors.map((e: any) => ValidationError.fromJSON(e))
        : [],
      isValid: isSet(object.isValid)
        ? globalThis.Boolean(object.isValid)
        : isSet(object.is_valid)
        ? globalThis.Boolean(object.is_valid)
        : false,
      originalAmount: isSet(object.originalAmount)
        ? Money.fromJSON(object.originalAmount)
        : isSet(object.original_amount)
        ? Money.fromJSON(object.original_amount)
        : undefined,
      exchangeRate: isSet(object.exchangeRate)
        ? globalThis.Number(object.exchangeRate)
        : isSet(object.exchange_rate)
        ? globalThis.Number(object.exchange_rate)
        : 0,
      exchangeRateSource: isSet(object.exchangeRateSource)
        ? globalThis.String(object.exchangeRateSource)
        : isSet(object.exchange_rate_source)
        ? globalThis.String(object.exchange_rate_source)
        : "",
      exchangeRateDate: isSet(object.exchangeRateDate)
        ? globalThis.Number(object.exchangeRateDate)
        : isSet(object.exchange_rate_date)
        ? globalThis.Number(object.exchange_rate_date)
        : 0,
    };
  },

  toJSON(message: ParsedTransaction): unknown {
    const obj: any = {};
    if (message.rowNumber !== 0) {
      obj.rowNumber = Math.round(message.rowNumber);
    }
    if (message.date !== 0) {
      obj.date = Math.round(message.date);
    }
    if (message.amount !== undefined) {
      obj.amount = Money.toJSON(message.amount);
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.type !== 0) {
      obj.type = transactionTypeToJSON(message.type);
    }
    if (message.suggestedCategoryId !== 0) {
      obj.suggestedCategoryId = Math.round(message.suggestedCategoryId);
    }
    if (message.categoryConfidence !== 0) {
      obj.categoryConfidence = Math.round(message.categoryConfidence);
    }
    if (message.referenceNumber !== "") {
      obj.referenceNumber = message.referenceNumber;
    }
    if (message.validationErrors?.length) {
      obj.validationErrors = message.validationErrors.map((e) => ValidationError.toJSON(e));
    }
    if (message.isValid !== false) {
      obj.isValid = message.isValid;
    }
    if (message.originalAmount !== undefined) {
      obj.originalAmount = Money.toJSON(message.originalAmount);
    }
    if (message.exchangeRate !== 0) {
      obj.exchangeRate = message.exchangeRate;
    }
    if (message.exchangeRateSource !== "") {
      obj.exchangeRateSource = message.exchangeRateSource;
    }
    if (message.exchangeRateDate !== 0) {
      obj.exchangeRateDate = Math.round(message.exchangeRateDate);
    }
    return obj;
  },

  create(base?: DeepPartial<ParsedTransaction>): ParsedTransaction {
    return ParsedTransaction.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ParsedTransaction>): ParsedTransaction {
    const message = createBaseParsedTransaction();
    message.rowNumber = object.rowNumber ?? 0;
    message.date = object.date ?? 0;
    message.amount = (object.amount !== undefined && object.amount !== null)
      ? Money.fromPartial(object.amount)
      : undefined;
    message.description = object.description ?? "";
    message.type = object.type ?? 0;
    message.suggestedCategoryId = object.suggestedCategoryId ?? 0;
    message.categoryConfidence = object.categoryConfidence ?? 0;
    message.referenceNumber = object.referenceNumber ?? "";
    message.validationErrors = object.validationErrors?.map((e) => ValidationError.fromPartial(e)) || [];
    message.isValid = object.isValid ?? false;
    message.originalAmount = (object.originalAmount !== undefined && object.originalAmount !== null)
      ? Money.fromPartial(object.originalAmount)
      : undefined;
    message.exchangeRate = object.exchangeRate ?? 0;
    message.exchangeRateSource = object.exchangeRateSource ?? "";
    message.exchangeRateDate = object.exchangeRateDate ?? 0;
    return message;
  },
};

function createBaseValidationError(): ValidationError {
  return { field: "", message: "", severity: "" };
}

export const ValidationError: MessageFns<ValidationError> = {
  encode(message: ValidationError, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.field !== "") {
      writer.uint32(10).string(message.field);
    }
    if (message.message !== "") {
      writer.uint32(18).string(message.message);
    }
    if (message.severity !== "") {
      writer.uint32(26).string(message.severity);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ValidationError {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseValidationError();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.field = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.message = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.severity = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ValidationError {
    return {
      field: isSet(object.field) ? globalThis.String(object.field) : "",
      message: isSet(object.message) ? globalThis.String(object.message) : "",
      severity: isSet(object.severity) ? globalThis.String(object.severity) : "",
    };
  },

  toJSON(message: ValidationError): unknown {
    const obj: any = {};
    if (message.field !== "") {
      obj.field = message.field;
    }
    if (message.message !== "") {
      obj.message = message.message;
    }
    if (message.severity !== "") {
      obj.severity = message.severity;
    }
    return obj;
  },

  create(base?: DeepPartial<ValidationError>): ValidationError {
    return ValidationError.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ValidationError>): ValidationError {
    const message = createBaseValidationError();
    message.field = object.field ?? "";
    message.message = object.message ?? "";
    message.severity = object.severity ?? "";
    return message;
  },
};

function createBaseParseStatistics(): ParseStatistics {
  return { totalRows: 0, validRows: 0, errorRows: 0, warningRows: 0 };
}

export const ParseStatistics: MessageFns<ParseStatistics> = {
  encode(message: ParseStatistics, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.totalRows !== 0) {
      writer.uint32(8).int32(message.totalRows);
    }
    if (message.validRows !== 0) {
      writer.uint32(16).int32(message.validRows);
    }
    if (message.errorRows !== 0) {
      writer.uint32(24).int32(message.errorRows);
    }
    if (message.warningRows !== 0) {
      writer.uint32(32).int32(message.warningRows);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ParseStatistics {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseParseStatistics();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.totalRows = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.validRows = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.errorRows = reader.int32();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.warningRows = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ParseStatistics {
    return {
      totalRows: isSet(object.totalRows)
        ? globalThis.Number(object.totalRows)
        : isSet(object.total_rows)
        ? globalThis.Number(object.total_rows)
        : 0,
      validRows: isSet(object.validRows)
        ? globalThis.Number(object.validRows)
        : isSet(object.valid_rows)
        ? globalThis.Number(object.valid_rows)
        : 0,
      errorRows: isSet(object.errorRows)
        ? globalThis.Number(object.errorRows)
        : isSet(object.error_rows)
        ? globalThis.Number(object.error_rows)
        : 0,
      warningRows: isSet(object.warningRows)
        ? globalThis.Number(object.warningRows)
        : isSet(object.warning_rows)
        ? globalThis.Number(object.warning_rows)
        : 0,
    };
  },

  toJSON(message: ParseStatistics): unknown {
    const obj: any = {};
    if (message.totalRows !== 0) {
      obj.totalRows = Math.round(message.totalRows);
    }
    if (message.validRows !== 0) {
      obj.validRows = Math.round(message.validRows);
    }
    if (message.errorRows !== 0) {
      obj.errorRows = Math.round(message.errorRows);
    }
    if (message.warningRows !== 0) {
      obj.warningRows = Math.round(message.warningRows);
    }
    return obj;
  },

  create(base?: DeepPartial<ParseStatistics>): ParseStatistics {
    return ParseStatistics.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ParseStatistics>): ParseStatistics {
    const message = createBaseParseStatistics();
    message.totalRows = object.totalRows ?? 0;
    message.validRows = object.validRows ?? 0;
    message.errorRows = object.errorRows ?? 0;
    message.warningRows = object.warningRows ?? 0;
    return message;
  },
};

function createBaseDetectDuplicatesRequest(): DetectDuplicatesRequest {
  return { transactions: [], walletId: 0 };
}

export const DetectDuplicatesRequest: MessageFns<DetectDuplicatesRequest> = {
  encode(message: DetectDuplicatesRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.transactions) {
      ParsedTransaction.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.walletId !== 0) {
      writer.uint32(16).int32(message.walletId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DetectDuplicatesRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDetectDuplicatesRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.transactions.push(ParsedTransaction.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.walletId = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DetectDuplicatesRequest {
    return {
      transactions: globalThis.Array.isArray(object?.transactions)
        ? object.transactions.map((e: any) => ParsedTransaction.fromJSON(e))
        : [],
      walletId: isSet(object.walletId)
        ? globalThis.Number(object.walletId)
        : isSet(object.wallet_id)
        ? globalThis.Number(object.wallet_id)
        : 0,
    };
  },

  toJSON(message: DetectDuplicatesRequest): unknown {
    const obj: any = {};
    if (message.transactions?.length) {
      obj.transactions = message.transactions.map((e) => ParsedTransaction.toJSON(e));
    }
    if (message.walletId !== 0) {
      obj.walletId = Math.round(message.walletId);
    }
    return obj;
  },

  create(base?: DeepPartial<DetectDuplicatesRequest>): DetectDuplicatesRequest {
    return DetectDuplicatesRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DetectDuplicatesRequest>): DetectDuplicatesRequest {
    const message = createBaseDetectDuplicatesRequest();
    message.transactions = object.transactions?.map((e) => ParsedTransaction.fromPartial(e)) || [];
    message.walletId = object.walletId ?? 0;
    return message;
  },
};

function createBaseDetectDuplicatesResponse(): DetectDuplicatesResponse {
  return { success: false, message: "", matches: [], timestamp: "" };
}

export const DetectDuplicatesResponse: MessageFns<DetectDuplicatesResponse> = {
  encode(message: DetectDuplicatesResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    if (message.message !== "") {
      writer.uint32(18).string(message.message);
    }
    for (const v of message.matches) {
      DuplicateMatch.encode(v!, writer.uint32(26).fork()).join();
    }
    if (message.timestamp !== "") {
      writer.uint32(34).string(message.timestamp);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DetectDuplicatesResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDetectDuplicatesResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.message = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.matches.push(DuplicateMatch.decode(reader, reader.uint32()));
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.timestamp = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DetectDuplicatesResponse {
    return {
      success: isSet(object.success) ? globalThis.Boolean(object.success) : false,
      message: isSet(object.message) ? globalThis.String(object.message) : "",
      matches: globalThis.Array.isArray(object?.matches)
        ? object.matches.map((e: any) => DuplicateMatch.fromJSON(e))
        : [],
      timestamp: isSet(object.timestamp) ? globalThis.String(object.timestamp) : "",
    };
  },

  toJSON(message: DetectDuplicatesResponse): unknown {
    const obj: any = {};
    if (message.success !== false) {
      obj.success = message.success;
    }
    if (message.message !== "") {
      obj.message = message.message;
    }
    if (message.matches?.length) {
      obj.matches = message.matches.map((e) => DuplicateMatch.toJSON(e));
    }
    if (message.timestamp !== "") {
      obj.timestamp = message.timestamp;
    }
    return obj;
  },

  create(base?: DeepPartial<DetectDuplicatesResponse>): DetectDuplicatesResponse {
    return DetectDuplicatesResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DetectDuplicatesResponse>): DetectDuplicatesResponse {
    const message = createBaseDetectDuplicatesResponse();
    message.success = object.success ?? false;
    message.message = object.message ?? "";
    message.matches = object.matches?.map((e) => DuplicateMatch.fromPartial(e)) || [];
    message.timestamp = object.timestamp ?? "";
    return message;
  },
};

function createBaseDuplicateMatch(): DuplicateMatch {
  return { importedTransaction: undefined, existingTransaction: undefined, confidence: 0, matchReason: "" };
}

export const DuplicateMatch: MessageFns<DuplicateMatch> = {
  encode(message: DuplicateMatch, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.importedTransaction !== undefined) {
      ParsedTransaction.encode(message.importedTransaction, writer.uint32(10).fork()).join();
    }
    if (message.existingTransaction !== undefined) {
      Transaction.encode(message.existingTransaction, writer.uint32(18).fork()).join();
    }
    if (message.confidence !== 0) {
      writer.uint32(24).int32(message.confidence);
    }
    if (message.matchReason !== "") {
      writer.uint32(34).string(message.matchReason);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DuplicateMatch {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDuplicateMatch();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.importedTransaction = ParsedTransaction.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.existingTransaction = Transaction.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.confidence = reader.int32();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.matchReason = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DuplicateMatch {
    return {
      importedTransaction: isSet(object.importedTransaction)
        ? ParsedTransaction.fromJSON(object.importedTransaction)
        : isSet(object.imported_transaction)
        ? ParsedTransaction.fromJSON(object.imported_transaction)
        : undefined,
      existingTransaction: isSet(object.existingTransaction)
        ? Transaction.fromJSON(object.existingTransaction)
        : isSet(object.existing_transaction)
        ? Transaction.fromJSON(object.existing_transaction)
        : undefined,
      confidence: isSet(object.confidence) ? globalThis.Number(object.confidence) : 0,
      matchReason: isSet(object.matchReason)
        ? globalThis.String(object.matchReason)
        : isSet(object.match_reason)
        ? globalThis.String(object.match_reason)
        : "",
    };
  },

  toJSON(message: DuplicateMatch): unknown {
    const obj: any = {};
    if (message.importedTransaction !== undefined) {
      obj.importedTransaction = ParsedTransaction.toJSON(message.importedTransaction);
    }
    if (message.existingTransaction !== undefined) {
      obj.existingTransaction = Transaction.toJSON(message.existingTransaction);
    }
    if (message.confidence !== 0) {
      obj.confidence = Math.round(message.confidence);
    }
    if (message.matchReason !== "") {
      obj.matchReason = message.matchReason;
    }
    return obj;
  },

  create(base?: DeepPartial<DuplicateMatch>): DuplicateMatch {
    return DuplicateMatch.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DuplicateMatch>): DuplicateMatch {
    const message = createBaseDuplicateMatch();
    message.importedTransaction = (object.importedTransaction !== undefined && object.importedTransaction !== null)
      ? ParsedTransaction.fromPartial(object.importedTransaction)
      : undefined;
    message.existingTransaction = (object.existingTransaction !== undefined && object.existingTransaction !== null)
      ? Transaction.fromPartial(object.existingTransaction)
      : undefined;
    message.confidence = object.confidence ?? 0;
    message.matchReason = object.matchReason ?? "";
    return message;
  },
};

function createBaseExecuteImportRequest(): ExecuteImportRequest {
  return {
    fileId: "",
    walletId: 0,
    transactions: [],
    strategy: 0,
    excludedRowNumbers: [],
    dateFilterStart: 0,
    dateFilterEnd: 0,
    duplicateActions: [],
  };
}

export const ExecuteImportRequest: MessageFns<ExecuteImportRequest> = {
  encode(message: ExecuteImportRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.fileId !== "") {
      writer.uint32(10).string(message.fileId);
    }
    if (message.walletId !== 0) {
      writer.uint32(16).int32(message.walletId);
    }
    for (const v of message.transactions) {
      ParsedTransaction.encode(v!, writer.uint32(26).fork()).join();
    }
    if (message.strategy !== 0) {
      writer.uint32(32).int32(message.strategy);
    }
    writer.uint32(42).fork();
    for (const v of message.excludedRowNumbers) {
      writer.int32(v);
    }
    writer.join();
    if (message.dateFilterStart !== 0) {
      writer.uint32(48).int64(message.dateFilterStart);
    }
    if (message.dateFilterEnd !== 0) {
      writer.uint32(56).int64(message.dateFilterEnd);
    }
    for (const v of message.duplicateActions) {
      DuplicateAction.encode(v!, writer.uint32(66).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ExecuteImportRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseExecuteImportRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.fileId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.walletId = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.transactions.push(ParsedTransaction.decode(reader, reader.uint32()));
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.strategy = reader.int32() as any;
          continue;
        }
        case 5: {
          if (tag === 40) {
            message.excludedRowNumbers.push(reader.int32());

            continue;
          }

          if (tag === 42) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.excludedRowNumbers.push(reader.int32());
            }

            continue;
          }

          break;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.dateFilterStart = longToNumber(reader.int64());
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.dateFilterEnd = longToNumber(reader.int64());
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.duplicateActions.push(DuplicateAction.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ExecuteImportRequest {
    return {
      fileId: isSet(object.fileId)
        ? globalThis.String(object.fileId)
        : isSet(object.file_id)
        ? globalThis.String(object.file_id)
        : "",
      walletId: isSet(object.walletId)
        ? globalThis.Number(object.walletId)
        : isSet(object.wallet_id)
        ? globalThis.Number(object.wallet_id)
        : 0,
      transactions: globalThis.Array.isArray(object?.transactions)
        ? object.transactions.map((e: any) => ParsedTransaction.fromJSON(e))
        : [],
      strategy: isSet(object.strategy) ? duplicateHandlingStrategyFromJSON(object.strategy) : 0,
      excludedRowNumbers: globalThis.Array.isArray(object?.excludedRowNumbers)
        ? object.excludedRowNumbers.map((e: any) => globalThis.Number(e))
        : globalThis.Array.isArray(object?.excluded_row_numbers)
        ? object.excluded_row_numbers.map((e: any) => globalThis.Number(e))
        : [],
      dateFilterStart: isSet(object.dateFilterStart)
        ? globalThis.Number(object.dateFilterStart)
        : isSet(object.date_filter_start)
        ? globalThis.Number(object.date_filter_start)
        : 0,
      dateFilterEnd: isSet(object.dateFilterEnd)
        ? globalThis.Number(object.dateFilterEnd)
        : isSet(object.date_filter_end)
        ? globalThis.Number(object.date_filter_end)
        : 0,
      duplicateActions: globalThis.Array.isArray(object?.duplicateActions)
        ? object.duplicateActions.map((e: any) => DuplicateAction.fromJSON(e))
        : globalThis.Array.isArray(object?.duplicate_actions)
        ? object.duplicate_actions.map((e: any) => DuplicateAction.fromJSON(e))
        : [],
    };
  },

  toJSON(message: ExecuteImportRequest): unknown {
    const obj: any = {};
    if (message.fileId !== "") {
      obj.fileId = message.fileId;
    }
    if (message.walletId !== 0) {
      obj.walletId = Math.round(message.walletId);
    }
    if (message.transactions?.length) {
      obj.transactions = message.transactions.map((e) => ParsedTransaction.toJSON(e));
    }
    if (message.strategy !== 0) {
      obj.strategy = duplicateHandlingStrategyToJSON(message.strategy);
    }
    if (message.excludedRowNumbers?.length) {
      obj.excludedRowNumbers = message.excludedRowNumbers.map((e) => Math.round(e));
    }
    if (message.dateFilterStart !== 0) {
      obj.dateFilterStart = Math.round(message.dateFilterStart);
    }
    if (message.dateFilterEnd !== 0) {
      obj.dateFilterEnd = Math.round(message.dateFilterEnd);
    }
    if (message.duplicateActions?.length) {
      obj.duplicateActions = message.duplicateActions.map((e) => DuplicateAction.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<ExecuteImportRequest>): ExecuteImportRequest {
    return ExecuteImportRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ExecuteImportRequest>): ExecuteImportRequest {
    const message = createBaseExecuteImportRequest();
    message.fileId = object.fileId ?? "";
    message.walletId = object.walletId ?? 0;
    message.transactions = object.transactions?.map((e) => ParsedTransaction.fromPartial(e)) || [];
    message.strategy = object.strategy ?? 0;
    message.excludedRowNumbers = object.excludedRowNumbers?.map((e) => e) || [];
    message.dateFilterStart = object.dateFilterStart ?? 0;
    message.dateFilterEnd = object.dateFilterEnd ?? 0;
    message.duplicateActions = object.duplicateActions?.map((e) => DuplicateAction.fromPartial(e)) || [];
    return message;
  },
};

function createBaseDuplicateAction(): DuplicateAction {
  return { importedRowNumber: 0, existingTransactionId: 0, action: 0 };
}

export const DuplicateAction: MessageFns<DuplicateAction> = {
  encode(message: DuplicateAction, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.importedRowNumber !== 0) {
      writer.uint32(8).int32(message.importedRowNumber);
    }
    if (message.existingTransactionId !== 0) {
      writer.uint32(16).int32(message.existingTransactionId);
    }
    if (message.action !== 0) {
      writer.uint32(24).int32(message.action);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DuplicateAction {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDuplicateAction();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.importedRowNumber = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.existingTransactionId = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.action = reader.int32() as any;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DuplicateAction {
    return {
      importedRowNumber: isSet(object.importedRowNumber)
        ? globalThis.Number(object.importedRowNumber)
        : isSet(object.imported_row_number)
        ? globalThis.Number(object.imported_row_number)
        : 0,
      existingTransactionId: isSet(object.existingTransactionId)
        ? globalThis.Number(object.existingTransactionId)
        : isSet(object.existing_transaction_id)
        ? globalThis.Number(object.existing_transaction_id)
        : 0,
      action: isSet(object.action) ? duplicateActionTypeFromJSON(object.action) : 0,
    };
  },

  toJSON(message: DuplicateAction): unknown {
    const obj: any = {};
    if (message.importedRowNumber !== 0) {
      obj.importedRowNumber = Math.round(message.importedRowNumber);
    }
    if (message.existingTransactionId !== 0) {
      obj.existingTransactionId = Math.round(message.existingTransactionId);
    }
    if (message.action !== 0) {
      obj.action = duplicateActionTypeToJSON(message.action);
    }
    return obj;
  },

  create(base?: DeepPartial<DuplicateAction>): DuplicateAction {
    return DuplicateAction.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DuplicateAction>): DuplicateAction {
    const message = createBaseDuplicateAction();
    message.importedRowNumber = object.importedRowNumber ?? 0;
    message.existingTransactionId = object.existingTransactionId ?? 0;
    message.action = object.action ?? 0;
    return message;
  },
};

function createBaseExecuteImportResponse(): ExecuteImportResponse {
  return { success: false, message: "", importBatchId: "", summary: undefined, timestamp: "" };
}

export const ExecuteImportResponse: MessageFns<ExecuteImportResponse> = {
  encode(message: ExecuteImportResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    if (message.message !== "") {
      writer.uint32(18).string(message.message);
    }
    if (message.importBatchId !== "") {
      writer.uint32(26).string(message.importBatchId);
    }
    if (message.summary !== undefined) {
      ImportSummary.encode(message.summary, writer.uint32(34).fork()).join();
    }
    if (message.timestamp !== "") {
      writer.uint32(42).string(message.timestamp);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ExecuteImportResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseExecuteImportResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.message = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.importBatchId = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.summary = ImportSummary.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.timestamp = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ExecuteImportResponse {
    return {
      success: isSet(object.success) ? globalThis.Boolean(object.success) : false,
      message: isSet(object.message) ? globalThis.String(object.message) : "",
      importBatchId: isSet(object.importBatchId)
        ? globalThis.String(object.importBatchId)
        : isSet(object.import_batch_id)
        ? globalThis.String(object.import_batch_id)
        : "",
      summary: isSet(object.summary) ? ImportSummary.fromJSON(object.summary) : undefined,
      timestamp: isSet(object.timestamp) ? globalThis.String(object.timestamp) : "",
    };
  },

  toJSON(message: ExecuteImportResponse): unknown {
    const obj: any = {};
    if (message.success !== false) {
      obj.success = message.success;
    }
    if (message.message !== "") {
      obj.message = message.message;
    }
    if (message.importBatchId !== "") {
      obj.importBatchId = message.importBatchId;
    }
    if (message.summary !== undefined) {
      obj.summary = ImportSummary.toJSON(message.summary);
    }
    if (message.timestamp !== "") {
      obj.timestamp = message.timestamp;
    }
    return obj;
  },

  create(base?: DeepPartial<ExecuteImportResponse>): ExecuteImportResponse {
    return ExecuteImportResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ExecuteImportResponse>): ExecuteImportResponse {
    const message = createBaseExecuteImportResponse();
    message.success = object.success ?? false;
    message.message = object.message ?? "";
    message.importBatchId = object.importBatchId ?? "";
    message.summary = (object.summary !== undefined && object.summary !== null)
      ? ImportSummary.fromPartial(object.summary)
      : undefined;
    message.timestamp = object.timestamp ?? "";
    return message;
  },
};

function createBaseImportSummary(): ImportSummary {
  return {
    totalImported: 0,
    totalSkipped: 0,
    duplicatesMerged: 0,
    duplicatesSkipped: 0,
    totalIncome: undefined,
    totalExpenses: undefined,
    netChange: undefined,
    newWalletBalance: undefined,
  };
}

export const ImportSummary: MessageFns<ImportSummary> = {
  encode(message: ImportSummary, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.totalImported !== 0) {
      writer.uint32(8).int32(message.totalImported);
    }
    if (message.totalSkipped !== 0) {
      writer.uint32(16).int32(message.totalSkipped);
    }
    if (message.duplicatesMerged !== 0) {
      writer.uint32(24).int32(message.duplicatesMerged);
    }
    if (message.duplicatesSkipped !== 0) {
      writer.uint32(32).int32(message.duplicatesSkipped);
    }
    if (message.totalIncome !== undefined) {
      Money.encode(message.totalIncome, writer.uint32(42).fork()).join();
    }
    if (message.totalExpenses !== undefined) {
      Money.encode(message.totalExpenses, writer.uint32(50).fork()).join();
    }
    if (message.netChange !== undefined) {
      Money.encode(message.netChange, writer.uint32(58).fork()).join();
    }
    if (message.newWalletBalance !== undefined) {
      Money.encode(message.newWalletBalance, writer.uint32(66).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ImportSummary {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseImportSummary();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.totalImported = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.totalSkipped = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.duplicatesMerged = reader.int32();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.duplicatesSkipped = reader.int32();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.totalIncome = Money.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.totalExpenses = Money.decode(reader, reader.uint32());
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.netChange = Money.decode(reader, reader.uint32());
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.newWalletBalance = Money.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ImportSummary {
    return {
      totalImported: isSet(object.totalImported)
        ? globalThis.Number(object.totalImported)
        : isSet(object.total_imported)
        ? globalThis.Number(object.total_imported)
        : 0,
      totalSkipped: isSet(object.totalSkipped)
        ? globalThis.Number(object.totalSkipped)
        : isSet(object.total_skipped)
        ? globalThis.Number(object.total_skipped)
        : 0,
      duplicatesMerged: isSet(object.duplicatesMerged)
        ? globalThis.Number(object.duplicatesMerged)
        : isSet(object.duplicates_merged)
        ? globalThis.Number(object.duplicates_merged)
        : 0,
      duplicatesSkipped: isSet(object.duplicatesSkipped)
        ? globalThis.Number(object.duplicatesSkipped)
        : isSet(object.duplicates_skipped)
        ? globalThis.Number(object.duplicates_skipped)
        : 0,
      totalIncome: isSet(object.totalIncome)
        ? Money.fromJSON(object.totalIncome)
        : isSet(object.total_income)
        ? Money.fromJSON(object.total_income)
        : undefined,
      totalExpenses: isSet(object.totalExpenses)
        ? Money.fromJSON(object.totalExpenses)
        : isSet(object.total_expenses)
        ? Money.fromJSON(object.total_expenses)
        : undefined,
      netChange: isSet(object.netChange)
        ? Money.fromJSON(object.netChange)
        : isSet(object.net_change)
        ? Money.fromJSON(object.net_change)
        : undefined,
      newWalletBalance: isSet(object.newWalletBalance)
        ? Money.fromJSON(object.newWalletBalance)
        : isSet(object.new_wallet_balance)
        ? Money.fromJSON(object.new_wallet_balance)
        : undefined,
    };
  },

  toJSON(message: ImportSummary): unknown {
    const obj: any = {};
    if (message.totalImported !== 0) {
      obj.totalImported = Math.round(message.totalImported);
    }
    if (message.totalSkipped !== 0) {
      obj.totalSkipped = Math.round(message.totalSkipped);
    }
    if (message.duplicatesMerged !== 0) {
      obj.duplicatesMerged = Math.round(message.duplicatesMerged);
    }
    if (message.duplicatesSkipped !== 0) {
      obj.duplicatesSkipped = Math.round(message.duplicatesSkipped);
    }
    if (message.totalIncome !== undefined) {
      obj.totalIncome = Money.toJSON(message.totalIncome);
    }
    if (message.totalExpenses !== undefined) {
      obj.totalExpenses = Money.toJSON(message.totalExpenses);
    }
    if (message.netChange !== undefined) {
      obj.netChange = Money.toJSON(message.netChange);
    }
    if (message.newWalletBalance !== undefined) {
      obj.newWalletBalance = Money.toJSON(message.newWalletBalance);
    }
    return obj;
  },

  create(base?: DeepPartial<ImportSummary>): ImportSummary {
    return ImportSummary.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ImportSummary>): ImportSummary {
    const message = createBaseImportSummary();
    message.totalImported = object.totalImported ?? 0;
    message.totalSkipped = object.totalSkipped ?? 0;
    message.duplicatesMerged = object.duplicatesMerged ?? 0;
    message.duplicatesSkipped = object.duplicatesSkipped ?? 0;
    message.totalIncome = (object.totalIncome !== undefined && object.totalIncome !== null)
      ? Money.fromPartial(object.totalIncome)
      : undefined;
    message.totalExpenses = (object.totalExpenses !== undefined && object.totalExpenses !== null)
      ? Money.fromPartial(object.totalExpenses)
      : undefined;
    message.netChange = (object.netChange !== undefined && object.netChange !== null)
      ? Money.fromPartial(object.netChange)
      : undefined;
    message.newWalletBalance = (object.newWalletBalance !== undefined && object.newWalletBalance !== null)
      ? Money.fromPartial(object.newWalletBalance)
      : undefined;
    return message;
  },
};

function createBaseListBankTemplatesRequest(): ListBankTemplatesRequest {
  return {};
}

export const ListBankTemplatesRequest: MessageFns<ListBankTemplatesRequest> = {
  encode(_: ListBankTemplatesRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListBankTemplatesRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListBankTemplatesRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): ListBankTemplatesRequest {
    return {};
  },

  toJSON(_: ListBankTemplatesRequest): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<ListBankTemplatesRequest>): ListBankTemplatesRequest {
    return ListBankTemplatesRequest.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<ListBankTemplatesRequest>): ListBankTemplatesRequest {
    const message = createBaseListBankTemplatesRequest();
    return message;
  },
};

function createBaseListBankTemplatesResponse(): ListBankTemplatesResponse {
  return { success: false, message: "", templates: [], timestamp: "" };
}

export const ListBankTemplatesResponse: MessageFns<ListBankTemplatesResponse> = {
  encode(message: ListBankTemplatesResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    if (message.message !== "") {
      writer.uint32(18).string(message.message);
    }
    for (const v of message.templates) {
      BankTemplate.encode(v!, writer.uint32(26).fork()).join();
    }
    if (message.timestamp !== "") {
      writer.uint32(34).string(message.timestamp);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListBankTemplatesResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListBankTemplatesResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.message = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.templates.push(BankTemplate.decode(reader, reader.uint32()));
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.timestamp = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListBankTemplatesResponse {
    return {
      success: isSet(object.success) ? globalThis.Boolean(object.success) : false,
      message: isSet(object.message) ? globalThis.String(object.message) : "",
      templates: globalThis.Array.isArray(object?.templates)
        ? object.templates.map((e: any) => BankTemplate.fromJSON(e))
        : [],
      timestamp: isSet(object.timestamp) ? globalThis.String(object.timestamp) : "",
    };
  },

  toJSON(message: ListBankTemplatesResponse): unknown {
    const obj: any = {};
    if (message.success !== false) {
      obj.success = message.success;
    }
    if (message.message !== "") {
      obj.message = message.message;
    }
    if (message.templates?.length) {
      obj.templates = message.templates.map((e) => BankTemplate.toJSON(e));
    }
    if (message.timestamp !== "") {
      obj.timestamp = message.timestamp;
    }
    return obj;
  },

  create(base?: DeepPartial<ListBankTemplatesResponse>): ListBankTemplatesResponse {
    return ListBankTemplatesResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListBankTemplatesResponse>): ListBankTemplatesResponse {
    const message = createBaseListBankTemplatesResponse();
    message.success = object.success ?? false;
    message.message = object.message ?? "";
    message.templates = object.templates?.map((e) => BankTemplate.fromPartial(e)) || [];
    message.timestamp = object.timestamp ?? "";
    return message;
  },
};

function createBaseBankTemplate(): BankTemplate {
  return { id: "", name: "", bankCode: "", statementType: "", fileFormats: [] };
}

export const BankTemplate: MessageFns<BankTemplate> = {
  encode(message: BankTemplate, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    if (message.bankCode !== "") {
      writer.uint32(26).string(message.bankCode);
    }
    if (message.statementType !== "") {
      writer.uint32(34).string(message.statementType);
    }
    for (const v of message.fileFormats) {
      writer.uint32(42).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BankTemplate {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBankTemplate();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.bankCode = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.statementType = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.fileFormats.push(reader.string());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BankTemplate {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      bankCode: isSet(object.bankCode)
        ? globalThis.String(object.bankCode)
        : isSet(object.bank_code)
        ? globalThis.String(object.bank_code)
        : "",
      statementType: isSet(object.statementType)
        ? globalThis.String(object.statementType)
        : isSet(object.statement_type)
        ? globalThis.String(object.statement_type)
        : "",
      fileFormats: globalThis.Array.isArray(object?.fileFormats)
        ? object.fileFormats.map((e: any) => globalThis.String(e))
        : globalThis.Array.isArray(object?.file_formats)
        ? object.file_formats.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: BankTemplate): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.bankCode !== "") {
      obj.bankCode = message.bankCode;
    }
    if (message.statementType !== "") {
      obj.statementType = message.statementType;
    }
    if (message.fileFormats?.length) {
      obj.fileFormats = message.fileFormats;
    }
    return obj;
  },

  create(base?: DeepPartial<BankTemplate>): BankTemplate {
    return BankTemplate.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<BankTemplate>): BankTemplate {
    const message = createBaseBankTemplate();
    message.id = object.id ?? "";
    message.name = object.name ?? "";
    message.bankCode = object.bankCode ?? "";
    message.statementType = object.statementType ?? "";
    message.fileFormats = object.fileFormats?.map((e) => e) || [];
    return message;
  },
};

function createBaseGetImportHistoryRequest(): GetImportHistoryRequest {
  return { pagination: undefined };
}

export const GetImportHistoryRequest: MessageFns<GetImportHistoryRequest> = {
  encode(message: GetImportHistoryRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.pagination !== undefined) {
      PaginationParams.encode(message.pagination, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetImportHistoryRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetImportHistoryRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.pagination = PaginationParams.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetImportHistoryRequest {
    return { pagination: isSet(object.pagination) ? PaginationParams.fromJSON(object.pagination) : undefined };
  },

  toJSON(message: GetImportHistoryRequest): unknown {
    const obj: any = {};
    if (message.pagination !== undefined) {
      obj.pagination = PaginationParams.toJSON(message.pagination);
    }
    return obj;
  },

  create(base?: DeepPartial<GetImportHistoryRequest>): GetImportHistoryRequest {
    return GetImportHistoryRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetImportHistoryRequest>): GetImportHistoryRequest {
    const message = createBaseGetImportHistoryRequest();
    message.pagination = (object.pagination !== undefined && object.pagination !== null)
      ? PaginationParams.fromPartial(object.pagination)
      : undefined;
    return message;
  },
};

function createBaseGetImportHistoryResponse(): GetImportHistoryResponse {
  return { success: false, message: "", batches: [], pagination: undefined, timestamp: "" };
}

export const GetImportHistoryResponse: MessageFns<GetImportHistoryResponse> = {
  encode(message: GetImportHistoryResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    if (message.message !== "") {
      writer.uint32(18).string(message.message);
    }
    for (const v of message.batches) {
      ImportBatch.encode(v!, writer.uint32(26).fork()).join();
    }
    if (message.pagination !== undefined) {
      PaginationResult.encode(message.pagination, writer.uint32(34).fork()).join();
    }
    if (message.timestamp !== "") {
      writer.uint32(42).string(message.timestamp);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetImportHistoryResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetImportHistoryResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.message = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.batches.push(ImportBatch.decode(reader, reader.uint32()));
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.pagination = PaginationResult.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.timestamp = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetImportHistoryResponse {
    return {
      success: isSet(object.success) ? globalThis.Boolean(object.success) : false,
      message: isSet(object.message) ? globalThis.String(object.message) : "",
      batches: globalThis.Array.isArray(object?.batches) ? object.batches.map((e: any) => ImportBatch.fromJSON(e)) : [],
      pagination: isSet(object.pagination) ? PaginationResult.fromJSON(object.pagination) : undefined,
      timestamp: isSet(object.timestamp) ? globalThis.String(object.timestamp) : "",
    };
  },

  toJSON(message: GetImportHistoryResponse): unknown {
    const obj: any = {};
    if (message.success !== false) {
      obj.success = message.success;
    }
    if (message.message !== "") {
      obj.message = message.message;
    }
    if (message.batches?.length) {
      obj.batches = message.batches.map((e) => ImportBatch.toJSON(e));
    }
    if (message.pagination !== undefined) {
      obj.pagination = PaginationResult.toJSON(message.pagination);
    }
    if (message.timestamp !== "") {
      obj.timestamp = message.timestamp;
    }
    return obj;
  },

  create(base?: DeepPartial<GetImportHistoryResponse>): GetImportHistoryResponse {
    return GetImportHistoryResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetImportHistoryResponse>): GetImportHistoryResponse {
    const message = createBaseGetImportHistoryResponse();
    message.success = object.success ?? false;
    message.message = object.message ?? "";
    message.batches = object.batches?.map((e) => ImportBatch.fromPartial(e)) || [];
    message.pagination = (object.pagination !== undefined && object.pagination !== null)
      ? PaginationResult.fromPartial(object.pagination)
      : undefined;
    message.timestamp = object.timestamp ?? "";
    return message;
  },
};

function createBaseImportBatch(): ImportBatch {
  return {
    id: "",
    userId: 0,
    walletId: 0,
    fileName: "",
    fileType: "",
    bankTemplate: "",
    importedAt: 0,
    summary: undefined,
    canUndo: false,
    undoExpiresAt: 0,
  };
}

export const ImportBatch: MessageFns<ImportBatch> = {
  encode(message: ImportBatch, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.userId !== 0) {
      writer.uint32(16).int32(message.userId);
    }
    if (message.walletId !== 0) {
      writer.uint32(24).int32(message.walletId);
    }
    if (message.fileName !== "") {
      writer.uint32(34).string(message.fileName);
    }
    if (message.fileType !== "") {
      writer.uint32(42).string(message.fileType);
    }
    if (message.bankTemplate !== "") {
      writer.uint32(50).string(message.bankTemplate);
    }
    if (message.importedAt !== 0) {
      writer.uint32(56).int64(message.importedAt);
    }
    if (message.summary !== undefined) {
      ImportSummary.encode(message.summary, writer.uint32(66).fork()).join();
    }
    if (message.canUndo !== false) {
      writer.uint32(72).bool(message.canUndo);
    }
    if (message.undoExpiresAt !== 0) {
      writer.uint32(80).int64(message.undoExpiresAt);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ImportBatch {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseImportBatch();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.userId = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.walletId = reader.int32();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.fileName = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.fileType = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.bankTemplate = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.importedAt = longToNumber(reader.int64());
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.summary = ImportSummary.decode(reader, reader.uint32());
          continue;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }

          message.canUndo = reader.bool();
          continue;
        }
        case 10: {
          if (tag !== 80) {
            break;
          }

          message.undoExpiresAt = longToNumber(reader.int64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ImportBatch {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      userId: isSet(object.userId)
        ? globalThis.Number(object.userId)
        : isSet(object.user_id)
        ? globalThis.Number(object.user_id)
        : 0,
      walletId: isSet(object.walletId)
        ? globalThis.Number(object.walletId)
        : isSet(object.wallet_id)
        ? globalThis.Number(object.wallet_id)
        : 0,
      fileName: isSet(object.fileName)
        ? globalThis.String(object.fileName)
        : isSet(object.file_name)
        ? globalThis.String(object.file_name)
        : "",
      fileType: isSet(object.fileType)
        ? globalThis.String(object.fileType)
        : isSet(object.file_type)
        ? globalThis.String(object.file_type)
        : "",
      bankTemplate: isSet(object.bankTemplate)
        ? globalThis.String(object.bankTemplate)
        : isSet(object.bank_template)
        ? globalThis.String(object.bank_template)
        : "",
      importedAt: isSet(object.importedAt)
        ? globalThis.Number(object.importedAt)
        : isSet(object.imported_at)
        ? globalThis.Number(object.imported_at)
        : 0,
      summary: isSet(object.summary) ? ImportSummary.fromJSON(object.summary) : undefined,
      canUndo: isSet(object.canUndo)
        ? globalThis.Boolean(object.canUndo)
        : isSet(object.can_undo)
        ? globalThis.Boolean(object.can_undo)
        : false,
      undoExpiresAt: isSet(object.undoExpiresAt)
        ? globalThis.Number(object.undoExpiresAt)
        : isSet(object.undo_expires_at)
        ? globalThis.Number(object.undo_expires_at)
        : 0,
    };
  },

  toJSON(message: ImportBatch): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.userId !== 0) {
      obj.userId = Math.round(message.userId);
    }
    if (message.walletId !== 0) {
      obj.walletId = Math.round(message.walletId);
    }
    if (message.fileName !== "") {
      obj.fileName = message.fileName;
    }
    if (message.fileType !== "") {
      obj.fileType = message.fileType;
    }
    if (message.bankTemplate !== "") {
      obj.bankTemplate = message.bankTemplate;
    }
    if (message.importedAt !== 0) {
      obj.importedAt = Math.round(message.importedAt);
    }
    if (message.summary !== undefined) {
      obj.summary = ImportSummary.toJSON(message.summary);
    }
    if (message.canUndo !== false) {
      obj.canUndo = message.canUndo;
    }
    if (message.undoExpiresAt !== 0) {
      obj.undoExpiresAt = Math.round(message.undoExpiresAt);
    }
    return obj;
  },

  create(base?: DeepPartial<ImportBatch>): ImportBatch {
    return ImportBatch.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ImportBatch>): ImportBatch {
    const message = createBaseImportBatch();
    message.id = object.id ?? "";
    message.userId = object.userId ?? 0;
    message.walletId = object.walletId ?? 0;
    message.fileName = object.fileName ?? "";
    message.fileType = object.fileType ?? "";
    message.bankTemplate = object.bankTemplate ?? "";
    message.importedAt = object.importedAt ?? 0;
    message.summary = (object.summary !== undefined && object.summary !== null)
      ? ImportSummary.fromPartial(object.summary)
      : undefined;
    message.canUndo = object.canUndo ?? false;
    message.undoExpiresAt = object.undoExpiresAt ?? 0;
    return message;
  },
};

function createBaseUndoImportRequest(): UndoImportRequest {
  return { importId: "" };
}

export const UndoImportRequest: MessageFns<UndoImportRequest> = {
  encode(message: UndoImportRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.importId !== "") {
      writer.uint32(10).string(message.importId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UndoImportRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUndoImportRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.importId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UndoImportRequest {
    return {
      importId: isSet(object.importId)
        ? globalThis.String(object.importId)
        : isSet(object.import_id)
        ? globalThis.String(object.import_id)
        : "",
    };
  },

  toJSON(message: UndoImportRequest): unknown {
    const obj: any = {};
    if (message.importId !== "") {
      obj.importId = message.importId;
    }
    return obj;
  },

  create(base?: DeepPartial<UndoImportRequest>): UndoImportRequest {
    return UndoImportRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<UndoImportRequest>): UndoImportRequest {
    const message = createBaseUndoImportRequest();
    message.importId = object.importId ?? "";
    return message;
  },
};

function createBaseUndoImportResponse(): UndoImportResponse {
  return { success: false, message: "", timestamp: "" };
}

export const UndoImportResponse: MessageFns<UndoImportResponse> = {
  encode(message: UndoImportResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    if (message.message !== "") {
      writer.uint32(18).string(message.message);
    }
    if (message.timestamp !== "") {
      writer.uint32(26).string(message.timestamp);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UndoImportResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUndoImportResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.message = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.timestamp = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UndoImportResponse {
    return {
      success: isSet(object.success) ? globalThis.Boolean(object.success) : false,
      message: isSet(object.message) ? globalThis.String(object.message) : "",
      timestamp: isSet(object.timestamp) ? globalThis.String(object.timestamp) : "",
    };
  },

  toJSON(message: UndoImportResponse): unknown {
    const obj: any = {};
    if (message.success !== false) {
      obj.success = message.success;
    }
    if (message.message !== "") {
      obj.message = message.message;
    }
    if (message.timestamp !== "") {
      obj.timestamp = message.timestamp;
    }
    return obj;
  },

  create(base?: DeepPartial<UndoImportResponse>): UndoImportResponse {
    return UndoImportResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<UndoImportResponse>): UndoImportResponse {
    const message = createBaseUndoImportResponse();
    message.success = object.success ?? false;
    message.message = object.message ?? "";
    message.timestamp = object.timestamp ?? "";
    return message;
  },
};

function createBaseCurrencyInfo(): CurrencyInfo {
  return { walletCurrency: "", currenciesFound: [], needsConversion: false };
}

export const CurrencyInfo: MessageFns<CurrencyInfo> = {
  encode(message: CurrencyInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.walletCurrency !== "") {
      writer.uint32(10).string(message.walletCurrency);
    }
    for (const v of message.currenciesFound) {
      writer.uint32(18).string(v!);
    }
    if (message.needsConversion !== false) {
      writer.uint32(24).bool(message.needsConversion);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CurrencyInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCurrencyInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.walletCurrency = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.currenciesFound.push(reader.string());
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.needsConversion = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CurrencyInfo {
    return {
      walletCurrency: isSet(object.walletCurrency)
        ? globalThis.String(object.walletCurrency)
        : isSet(object.wallet_currency)
        ? globalThis.String(object.wallet_currency)
        : "",
      currenciesFound: globalThis.Array.isArray(object?.currenciesFound)
        ? object.currenciesFound.map((e: any) => globalThis.String(e))
        : globalThis.Array.isArray(object?.currencies_found)
        ? object.currencies_found.map((e: any) => globalThis.String(e))
        : [],
      needsConversion: isSet(object.needsConversion)
        ? globalThis.Boolean(object.needsConversion)
        : isSet(object.needs_conversion)
        ? globalThis.Boolean(object.needs_conversion)
        : false,
    };
  },

  toJSON(message: CurrencyInfo): unknown {
    const obj: any = {};
    if (message.walletCurrency !== "") {
      obj.walletCurrency = message.walletCurrency;
    }
    if (message.currenciesFound?.length) {
      obj.currenciesFound = message.currenciesFound;
    }
    if (message.needsConversion !== false) {
      obj.needsConversion = message.needsConversion;
    }
    return obj;
  },

  create(base?: DeepPartial<CurrencyInfo>): CurrencyInfo {
    return CurrencyInfo.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CurrencyInfo>): CurrencyInfo {
    const message = createBaseCurrencyInfo();
    message.walletCurrency = object.walletCurrency ?? "";
    message.currenciesFound = object.currenciesFound?.map((e) => e) || [];
    message.needsConversion = object.needsConversion ?? false;
    return message;
  },
};

function createBaseConvertCurrencyRequest(): ConvertCurrencyRequest {
  return { walletId: 0, transactions: [], manualRates: {} };
}

export const ConvertCurrencyRequest: MessageFns<ConvertCurrencyRequest> = {
  encode(message: ConvertCurrencyRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.walletId !== 0) {
      writer.uint32(8).int32(message.walletId);
    }
    for (const v of message.transactions) {
      ParsedTransaction.encode(v!, writer.uint32(18).fork()).join();
    }
    globalThis.Object.entries(message.manualRates).forEach(([key, value]: [string, ManualExchangeRate]) => {
      ConvertCurrencyRequest_ManualRatesEntry.encode({ key: key as any, value }, writer.uint32(26).fork()).join();
    });
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ConvertCurrencyRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseConvertCurrencyRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.walletId = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.transactions.push(ParsedTransaction.decode(reader, reader.uint32()));
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          const entry3 = ConvertCurrencyRequest_ManualRatesEntry.decode(reader, reader.uint32());
          if (entry3.value !== undefined) {
            message.manualRates[entry3.key] = entry3.value;
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ConvertCurrencyRequest {
    return {
      walletId: isSet(object.walletId)
        ? globalThis.Number(object.walletId)
        : isSet(object.wallet_id)
        ? globalThis.Number(object.wallet_id)
        : 0,
      transactions: globalThis.Array.isArray(object?.transactions)
        ? object.transactions.map((e: any) => ParsedTransaction.fromJSON(e))
        : [],
      manualRates: isObject(object.manualRates)
        ? (globalThis.Object.entries(object.manualRates) as [string, any][]).reduce(
          (acc: { [key: string]: ManualExchangeRate }, [key, value]: [string, any]) => {
            acc[key] = ManualExchangeRate.fromJSON(value);
            return acc;
          },
          {},
        )
        : isObject(object.manual_rates)
        ? (globalThis.Object.entries(object.manual_rates) as [string, any][]).reduce(
          (acc: { [key: string]: ManualExchangeRate }, [key, value]: [string, any]) => {
            acc[key] = ManualExchangeRate.fromJSON(value);
            return acc;
          },
          {},
        )
        : {},
    };
  },

  toJSON(message: ConvertCurrencyRequest): unknown {
    const obj: any = {};
    if (message.walletId !== 0) {
      obj.walletId = Math.round(message.walletId);
    }
    if (message.transactions?.length) {
      obj.transactions = message.transactions.map((e) => ParsedTransaction.toJSON(e));
    }
    if (message.manualRates) {
      const entries = globalThis.Object.entries(message.manualRates) as [string, ManualExchangeRate][];
      if (entries.length > 0) {
        obj.manualRates = {};
        entries.forEach(([k, v]) => {
          obj.manualRates[k] = ManualExchangeRate.toJSON(v);
        });
      }
    }
    return obj;
  },

  create(base?: DeepPartial<ConvertCurrencyRequest>): ConvertCurrencyRequest {
    return ConvertCurrencyRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ConvertCurrencyRequest>): ConvertCurrencyRequest {
    const message = createBaseConvertCurrencyRequest();
    message.walletId = object.walletId ?? 0;
    message.transactions = object.transactions?.map((e) => ParsedTransaction.fromPartial(e)) || [];
    message.manualRates = (globalThis.Object.entries(object.manualRates ?? {}) as [string, ManualExchangeRate][])
      .reduce((acc: { [key: string]: ManualExchangeRate }, [key, value]: [string, ManualExchangeRate]) => {
        if (value !== undefined) {
          acc[key] = ManualExchangeRate.fromPartial(value);
        }
        return acc;
      }, {});
    return message;
  },
};

function createBaseConvertCurrencyRequest_ManualRatesEntry(): ConvertCurrencyRequest_ManualRatesEntry {
  return { key: "", value: undefined };
}

export const ConvertCurrencyRequest_ManualRatesEntry: MessageFns<ConvertCurrencyRequest_ManualRatesEntry> = {
  encode(message: ConvertCurrencyRequest_ManualRatesEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== undefined) {
      ManualExchangeRate.encode(message.value, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ConvertCurrencyRequest_ManualRatesEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseConvertCurrencyRequest_ManualRatesEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = ManualExchangeRate.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ConvertCurrencyRequest_ManualRatesEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? ManualExchangeRate.fromJSON(object.value) : undefined,
    };
  },

  toJSON(message: ConvertCurrencyRequest_ManualRatesEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== undefined) {
      obj.value = ManualExchangeRate.toJSON(message.value);
    }
    return obj;
  },

  create(base?: DeepPartial<ConvertCurrencyRequest_ManualRatesEntry>): ConvertCurrencyRequest_ManualRatesEntry {
    return ConvertCurrencyRequest_ManualRatesEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ConvertCurrencyRequest_ManualRatesEntry>): ConvertCurrencyRequest_ManualRatesEntry {
    const message = createBaseConvertCurrencyRequest_ManualRatesEntry();
    message.key = object.key ?? "";
    message.value = (object.value !== undefined && object.value !== null)
      ? ManualExchangeRate.fromPartial(object.value)
      : undefined;
    return message;
  },
};

function createBaseManualExchangeRate(): ManualExchangeRate {
  return { fromCurrency: "", toCurrency: "", exchangeRate: 0, rateDate: 0 };
}

export const ManualExchangeRate: MessageFns<ManualExchangeRate> = {
  encode(message: ManualExchangeRate, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.fromCurrency !== "") {
      writer.uint32(10).string(message.fromCurrency);
    }
    if (message.toCurrency !== "") {
      writer.uint32(18).string(message.toCurrency);
    }
    if (message.exchangeRate !== 0) {
      writer.uint32(25).double(message.exchangeRate);
    }
    if (message.rateDate !== 0) {
      writer.uint32(32).int64(message.rateDate);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ManualExchangeRate {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseManualExchangeRate();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.fromCurrency = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.toCurrency = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 25) {
            break;
          }

          message.exchangeRate = reader.double();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.rateDate = longToNumber(reader.int64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ManualExchangeRate {
    return {
      fromCurrency: isSet(object.fromCurrency)
        ? globalThis.String(object.fromCurrency)
        : isSet(object.from_currency)
        ? globalThis.String(object.from_currency)
        : "",
      toCurrency: isSet(object.toCurrency)
        ? globalThis.String(object.toCurrency)
        : isSet(object.to_currency)
        ? globalThis.String(object.to_currency)
        : "",
      exchangeRate: isSet(object.exchangeRate)
        ? globalThis.Number(object.exchangeRate)
        : isSet(object.exchange_rate)
        ? globalThis.Number(object.exchange_rate)
        : 0,
      rateDate: isSet(object.rateDate)
        ? globalThis.Number(object.rateDate)
        : isSet(object.rate_date)
        ? globalThis.Number(object.rate_date)
        : 0,
    };
  },

  toJSON(message: ManualExchangeRate): unknown {
    const obj: any = {};
    if (message.fromCurrency !== "") {
      obj.fromCurrency = message.fromCurrency;
    }
    if (message.toCurrency !== "") {
      obj.toCurrency = message.toCurrency;
    }
    if (message.exchangeRate !== 0) {
      obj.exchangeRate = message.exchangeRate;
    }
    if (message.rateDate !== 0) {
      obj.rateDate = Math.round(message.rateDate);
    }
    return obj;
  },

  create(base?: DeepPartial<ManualExchangeRate>): ManualExchangeRate {
    return ManualExchangeRate.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ManualExchangeRate>): ManualExchangeRate {
    const message = createBaseManualExchangeRate();
    message.fromCurrency = object.fromCurrency ?? "";
    message.toCurrency = object.toCurrency ?? "";
    message.exchangeRate = object.exchangeRate ?? 0;
    message.rateDate = object.rateDate ?? 0;
    return message;
  },
};

function createBaseConvertCurrencyResponse(): ConvertCurrencyResponse {
  return { success: false, message: "", conversions: [], convertedTransactions: [], timestamp: "" };
}

export const ConvertCurrencyResponse: MessageFns<ConvertCurrencyResponse> = {
  encode(message: ConvertCurrencyResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    if (message.message !== "") {
      writer.uint32(18).string(message.message);
    }
    for (const v of message.conversions) {
      CurrencyConversion.encode(v!, writer.uint32(26).fork()).join();
    }
    for (const v of message.convertedTransactions) {
      ParsedTransaction.encode(v!, writer.uint32(34).fork()).join();
    }
    if (message.timestamp !== "") {
      writer.uint32(42).string(message.timestamp);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ConvertCurrencyResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseConvertCurrencyResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.message = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.conversions.push(CurrencyConversion.decode(reader, reader.uint32()));
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.convertedTransactions.push(ParsedTransaction.decode(reader, reader.uint32()));
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.timestamp = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ConvertCurrencyResponse {
    return {
      success: isSet(object.success) ? globalThis.Boolean(object.success) : false,
      message: isSet(object.message) ? globalThis.String(object.message) : "",
      conversions: globalThis.Array.isArray(object?.conversions)
        ? object.conversions.map((e: any) => CurrencyConversion.fromJSON(e))
        : [],
      convertedTransactions: globalThis.Array.isArray(object?.convertedTransactions)
        ? object.convertedTransactions.map((e: any) => ParsedTransaction.fromJSON(e))
        : globalThis.Array.isArray(object?.converted_transactions)
        ? object.converted_transactions.map((e: any) => ParsedTransaction.fromJSON(e))
        : [],
      timestamp: isSet(object.timestamp) ? globalThis.String(object.timestamp) : "",
    };
  },

  toJSON(message: ConvertCurrencyResponse): unknown {
    const obj: any = {};
    if (message.success !== false) {
      obj.success = message.success;
    }
    if (message.message !== "") {
      obj.message = message.message;
    }
    if (message.conversions?.length) {
      obj.conversions = message.conversions.map((e) => CurrencyConversion.toJSON(e));
    }
    if (message.convertedTransactions?.length) {
      obj.convertedTransactions = message.convertedTransactions.map((e) => ParsedTransaction.toJSON(e));
    }
    if (message.timestamp !== "") {
      obj.timestamp = message.timestamp;
    }
    return obj;
  },

  create(base?: DeepPartial<ConvertCurrencyResponse>): ConvertCurrencyResponse {
    return ConvertCurrencyResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ConvertCurrencyResponse>): ConvertCurrencyResponse {
    const message = createBaseConvertCurrencyResponse();
    message.success = object.success ?? false;
    message.message = object.message ?? "";
    message.conversions = object.conversions?.map((e) => CurrencyConversion.fromPartial(e)) || [];
    message.convertedTransactions = object.convertedTransactions?.map((e) => ParsedTransaction.fromPartial(e)) || [];
    message.timestamp = object.timestamp ?? "";
    return message;
  },
};

function createBaseListExcelSheetsRequest(): ListExcelSheetsRequest {
  return { fileId: "" };
}

export const ListExcelSheetsRequest: MessageFns<ListExcelSheetsRequest> = {
  encode(message: ListExcelSheetsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.fileId !== "") {
      writer.uint32(10).string(message.fileId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListExcelSheetsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListExcelSheetsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.fileId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListExcelSheetsRequest {
    return {
      fileId: isSet(object.fileId)
        ? globalThis.String(object.fileId)
        : isSet(object.file_id)
        ? globalThis.String(object.file_id)
        : "",
    };
  },

  toJSON(message: ListExcelSheetsRequest): unknown {
    const obj: any = {};
    if (message.fileId !== "") {
      obj.fileId = message.fileId;
    }
    return obj;
  },

  create(base?: DeepPartial<ListExcelSheetsRequest>): ListExcelSheetsRequest {
    return ListExcelSheetsRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListExcelSheetsRequest>): ListExcelSheetsRequest {
    const message = createBaseListExcelSheetsRequest();
    message.fileId = object.fileId ?? "";
    return message;
  },
};

function createBaseListExcelSheetsResponse(): ListExcelSheetsResponse {
  return { success: false, message: "", sheetNames: [], defaultSheet: "", timestamp: "" };
}

export const ListExcelSheetsResponse: MessageFns<ListExcelSheetsResponse> = {
  encode(message: ListExcelSheetsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    if (message.message !== "") {
      writer.uint32(18).string(message.message);
    }
    for (const v of message.sheetNames) {
      writer.uint32(26).string(v!);
    }
    if (message.defaultSheet !== "") {
      writer.uint32(34).string(message.defaultSheet);
    }
    if (message.timestamp !== "") {
      writer.uint32(42).string(message.timestamp);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListExcelSheetsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListExcelSheetsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.message = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.sheetNames.push(reader.string());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.defaultSheet = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.timestamp = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListExcelSheetsResponse {
    return {
      success: isSet(object.success) ? globalThis.Boolean(object.success) : false,
      message: isSet(object.message) ? globalThis.String(object.message) : "",
      sheetNames: globalThis.Array.isArray(object?.sheetNames)
        ? object.sheetNames.map((e: any) => globalThis.String(e))
        : globalThis.Array.isArray(object?.sheet_names)
        ? object.sheet_names.map((e: any) => globalThis.String(e))
        : [],
      defaultSheet: isSet(object.defaultSheet)
        ? globalThis.String(object.defaultSheet)
        : isSet(object.default_sheet)
        ? globalThis.String(object.default_sheet)
        : "",
      timestamp: isSet(object.timestamp) ? globalThis.String(object.timestamp) : "",
    };
  },

  toJSON(message: ListExcelSheetsResponse): unknown {
    const obj: any = {};
    if (message.success !== false) {
      obj.success = message.success;
    }
    if (message.message !== "") {
      obj.message = message.message;
    }
    if (message.sheetNames?.length) {
      obj.sheetNames = message.sheetNames;
    }
    if (message.defaultSheet !== "") {
      obj.defaultSheet = message.defaultSheet;
    }
    if (message.timestamp !== "") {
      obj.timestamp = message.timestamp;
    }
    return obj;
  },

  create(base?: DeepPartial<ListExcelSheetsResponse>): ListExcelSheetsResponse {
    return ListExcelSheetsResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListExcelSheetsResponse>): ListExcelSheetsResponse {
    const message = createBaseListExcelSheetsResponse();
    message.success = object.success ?? false;
    message.message = object.message ?? "";
    message.sheetNames = object.sheetNames?.map((e) => e) || [];
    message.defaultSheet = object.defaultSheet ?? "";
    message.timestamp = object.timestamp ?? "";
    return message;
  },
};

function createBaseCurrencyConversion(): CurrencyConversion {
  return {
    fromCurrency: "",
    toCurrency: "",
    exchangeRate: 0,
    rateSource: "",
    rateDate: 0,
    transactionCount: 0,
    totalOriginal: undefined,
    totalConverted: undefined,
  };
}

export const CurrencyConversion: MessageFns<CurrencyConversion> = {
  encode(message: CurrencyConversion, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.fromCurrency !== "") {
      writer.uint32(10).string(message.fromCurrency);
    }
    if (message.toCurrency !== "") {
      writer.uint32(18).string(message.toCurrency);
    }
    if (message.exchangeRate !== 0) {
      writer.uint32(25).double(message.exchangeRate);
    }
    if (message.rateSource !== "") {
      writer.uint32(34).string(message.rateSource);
    }
    if (message.rateDate !== 0) {
      writer.uint32(40).int64(message.rateDate);
    }
    if (message.transactionCount !== 0) {
      writer.uint32(48).int32(message.transactionCount);
    }
    if (message.totalOriginal !== undefined) {
      Money.encode(message.totalOriginal, writer.uint32(58).fork()).join();
    }
    if (message.totalConverted !== undefined) {
      Money.encode(message.totalConverted, writer.uint32(66).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CurrencyConversion {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCurrencyConversion();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.fromCurrency = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.toCurrency = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 25) {
            break;
          }

          message.exchangeRate = reader.double();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.rateSource = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.rateDate = longToNumber(reader.int64());
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.transactionCount = reader.int32();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.totalOriginal = Money.decode(reader, reader.uint32());
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.totalConverted = Money.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CurrencyConversion {
    return {
      fromCurrency: isSet(object.fromCurrency)
        ? globalThis.String(object.fromCurrency)
        : isSet(object.from_currency)
        ? globalThis.String(object.from_currency)
        : "",
      toCurrency: isSet(object.toCurrency)
        ? globalThis.String(object.toCurrency)
        : isSet(object.to_currency)
        ? globalThis.String(object.to_currency)
        : "",
      exchangeRate: isSet(object.exchangeRate)
        ? globalThis.Number(object.exchangeRate)
        : isSet(object.exchange_rate)
        ? globalThis.Number(object.exchange_rate)
        : 0,
      rateSource: isSet(object.rateSource)
        ? globalThis.String(object.rateSource)
        : isSet(object.rate_source)
        ? globalThis.String(object.rate_source)
        : "",
      rateDate: isSet(object.rateDate)
        ? globalThis.Number(object.rateDate)
        : isSet(object.rate_date)
        ? globalThis.Number(object.rate_date)
        : 0,
      transactionCount: isSet(object.transactionCount)
        ? globalThis.Number(object.transactionCount)
        : isSet(object.transaction_count)
        ? globalThis.Number(object.transaction_count)
        : 0,
      totalOriginal: isSet(object.totalOriginal)
        ? Money.fromJSON(object.totalOriginal)
        : isSet(object.total_original)
        ? Money.fromJSON(object.total_original)
        : undefined,
      totalConverted: isSet(object.totalConverted)
        ? Money.fromJSON(object.totalConverted)
        : isSet(object.total_converted)
        ? Money.fromJSON(object.total_converted)
        : undefined,
    };
  },

  toJSON(message: CurrencyConversion): unknown {
    const obj: any = {};
    if (message.fromCurrency !== "") {
      obj.fromCurrency = message.fromCurrency;
    }
    if (message.toCurrency !== "") {
      obj.toCurrency = message.toCurrency;
    }
    if (message.exchangeRate !== 0) {
      obj.exchangeRate = message.exchangeRate;
    }
    if (message.rateSource !== "") {
      obj.rateSource = message.rateSource;
    }
    if (message.rateDate !== 0) {
      obj.rateDate = Math.round(message.rateDate);
    }
    if (message.transactionCount !== 0) {
      obj.transactionCount = Math.round(message.transactionCount);
    }
    if (message.totalOriginal !== undefined) {
      obj.totalOriginal = Money.toJSON(message.totalOriginal);
    }
    if (message.totalConverted !== undefined) {
      obj.totalConverted = Money.toJSON(message.totalConverted);
    }
    return obj;
  },

  create(base?: DeepPartial<CurrencyConversion>): CurrencyConversion {
    return CurrencyConversion.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CurrencyConversion>): CurrencyConversion {
    const message = createBaseCurrencyConversion();
    message.fromCurrency = object.fromCurrency ?? "";
    message.toCurrency = object.toCurrency ?? "";
    message.exchangeRate = object.exchangeRate ?? 0;
    message.rateSource = object.rateSource ?? "";
    message.rateDate = object.rateDate ?? 0;
    message.transactionCount = object.transactionCount ?? 0;
    message.totalOriginal = (object.totalOriginal !== undefined && object.totalOriginal !== null)
      ? Money.fromPartial(object.totalOriginal)
      : undefined;
    message.totalConverted = (object.totalConverted !== undefined && object.totalConverted !== null)
      ? Money.fromPartial(object.totalConverted)
      : undefined;
    return message;
  },
};

function createBaseCreateUserTemplateRequest(): CreateUserTemplateRequest {
  return { templateName: "", columnMapping: undefined, dateFormat: "", currency: "", fileFormats: [] };
}

export const CreateUserTemplateRequest: MessageFns<CreateUserTemplateRequest> = {
  encode(message: CreateUserTemplateRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.templateName !== "") {
      writer.uint32(10).string(message.templateName);
    }
    if (message.columnMapping !== undefined) {
      ColumnMapping.encode(message.columnMapping, writer.uint32(18).fork()).join();
    }
    if (message.dateFormat !== "") {
      writer.uint32(26).string(message.dateFormat);
    }
    if (message.currency !== "") {
      writer.uint32(34).string(message.currency);
    }
    for (const v of message.fileFormats) {
      writer.uint32(42).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateUserTemplateRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateUserTemplateRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.templateName = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.columnMapping = ColumnMapping.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.dateFormat = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.currency = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.fileFormats.push(reader.string());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateUserTemplateRequest {
    return {
      templateName: isSet(object.templateName)
        ? globalThis.String(object.templateName)
        : isSet(object.template_name)
        ? globalThis.String(object.template_name)
        : "",
      columnMapping: isSet(object.columnMapping)
        ? ColumnMapping.fromJSON(object.columnMapping)
        : isSet(object.column_mapping)
        ? ColumnMapping.fromJSON(object.column_mapping)
        : undefined,
      dateFormat: isSet(object.dateFormat)
        ? globalThis.String(object.dateFormat)
        : isSet(object.date_format)
        ? globalThis.String(object.date_format)
        : "",
      currency: isSet(object.currency) ? globalThis.String(object.currency) : "",
      fileFormats: globalThis.Array.isArray(object?.fileFormats)
        ? object.fileFormats.map((e: any) => globalThis.String(e))
        : globalThis.Array.isArray(object?.file_formats)
        ? object.file_formats.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: CreateUserTemplateRequest): unknown {
    const obj: any = {};
    if (message.templateName !== "") {
      obj.templateName = message.templateName;
    }
    if (message.columnMapping !== undefined) {
      obj.columnMapping = ColumnMapping.toJSON(message.columnMapping);
    }
    if (message.dateFormat !== "") {
      obj.dateFormat = message.dateFormat;
    }
    if (message.currency !== "") {
      obj.currency = message.currency;
    }
    if (message.fileFormats?.length) {
      obj.fileFormats = message.fileFormats;
    }
    return obj;
  },

  create(base?: DeepPartial<CreateUserTemplateRequest>): CreateUserTemplateRequest {
    return CreateUserTemplateRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CreateUserTemplateRequest>): CreateUserTemplateRequest {
    const message = createBaseCreateUserTemplateRequest();
    message.templateName = object.templateName ?? "";
    message.columnMapping = (object.columnMapping !== undefined && object.columnMapping !== null)
      ? ColumnMapping.fromPartial(object.columnMapping)
      : undefined;
    message.dateFormat = object.dateFormat ?? "";
    message.currency = object.currency ?? "";
    message.fileFormats = object.fileFormats?.map((e) => e) || [];
    return message;
  },
};

function createBaseCreateUserTemplateResponse(): CreateUserTemplateResponse {
  return { success: false, message: "", template: undefined, timestamp: "" };
}

export const CreateUserTemplateResponse: MessageFns<CreateUserTemplateResponse> = {
  encode(message: CreateUserTemplateResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    if (message.message !== "") {
      writer.uint32(18).string(message.message);
    }
    if (message.template !== undefined) {
      UserTemplate.encode(message.template, writer.uint32(26).fork()).join();
    }
    if (message.timestamp !== "") {
      writer.uint32(34).string(message.timestamp);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateUserTemplateResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateUserTemplateResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.message = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.template = UserTemplate.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.timestamp = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateUserTemplateResponse {
    return {
      success: isSet(object.success) ? globalThis.Boolean(object.success) : false,
      message: isSet(object.message) ? globalThis.String(object.message) : "",
      template: isSet(object.template) ? UserTemplate.fromJSON(object.template) : undefined,
      timestamp: isSet(object.timestamp) ? globalThis.String(object.timestamp) : "",
    };
  },

  toJSON(message: CreateUserTemplateResponse): unknown {
    const obj: any = {};
    if (message.success !== false) {
      obj.success = message.success;
    }
    if (message.message !== "") {
      obj.message = message.message;
    }
    if (message.template !== undefined) {
      obj.template = UserTemplate.toJSON(message.template);
    }
    if (message.timestamp !== "") {
      obj.timestamp = message.timestamp;
    }
    return obj;
  },

  create(base?: DeepPartial<CreateUserTemplateResponse>): CreateUserTemplateResponse {
    return CreateUserTemplateResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CreateUserTemplateResponse>): CreateUserTemplateResponse {
    const message = createBaseCreateUserTemplateResponse();
    message.success = object.success ?? false;
    message.message = object.message ?? "";
    message.template = (object.template !== undefined && object.template !== null)
      ? UserTemplate.fromPartial(object.template)
      : undefined;
    message.timestamp = object.timestamp ?? "";
    return message;
  },
};

function createBaseListUserTemplatesRequest(): ListUserTemplatesRequest {
  return {};
}

export const ListUserTemplatesRequest: MessageFns<ListUserTemplatesRequest> = {
  encode(_: ListUserTemplatesRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListUserTemplatesRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListUserTemplatesRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): ListUserTemplatesRequest {
    return {};
  },

  toJSON(_: ListUserTemplatesRequest): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<ListUserTemplatesRequest>): ListUserTemplatesRequest {
    return ListUserTemplatesRequest.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<ListUserTemplatesRequest>): ListUserTemplatesRequest {
    const message = createBaseListUserTemplatesRequest();
    return message;
  },
};

function createBaseListUserTemplatesResponse(): ListUserTemplatesResponse {
  return { success: false, message: "", templates: [], timestamp: "" };
}

export const ListUserTemplatesResponse: MessageFns<ListUserTemplatesResponse> = {
  encode(message: ListUserTemplatesResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    if (message.message !== "") {
      writer.uint32(18).string(message.message);
    }
    for (const v of message.templates) {
      UserTemplate.encode(v!, writer.uint32(26).fork()).join();
    }
    if (message.timestamp !== "") {
      writer.uint32(34).string(message.timestamp);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListUserTemplatesResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListUserTemplatesResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.message = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.templates.push(UserTemplate.decode(reader, reader.uint32()));
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.timestamp = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListUserTemplatesResponse {
    return {
      success: isSet(object.success) ? globalThis.Boolean(object.success) : false,
      message: isSet(object.message) ? globalThis.String(object.message) : "",
      templates: globalThis.Array.isArray(object?.templates)
        ? object.templates.map((e: any) => UserTemplate.fromJSON(e))
        : [],
      timestamp: isSet(object.timestamp) ? globalThis.String(object.timestamp) : "",
    };
  },

  toJSON(message: ListUserTemplatesResponse): unknown {
    const obj: any = {};
    if (message.success !== false) {
      obj.success = message.success;
    }
    if (message.message !== "") {
      obj.message = message.message;
    }
    if (message.templates?.length) {
      obj.templates = message.templates.map((e) => UserTemplate.toJSON(e));
    }
    if (message.timestamp !== "") {
      obj.timestamp = message.timestamp;
    }
    return obj;
  },

  create(base?: DeepPartial<ListUserTemplatesResponse>): ListUserTemplatesResponse {
    return ListUserTemplatesResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListUserTemplatesResponse>): ListUserTemplatesResponse {
    const message = createBaseListUserTemplatesResponse();
    message.success = object.success ?? false;
    message.message = object.message ?? "";
    message.templates = object.templates?.map((e) => UserTemplate.fromPartial(e)) || [];
    message.timestamp = object.timestamp ?? "";
    return message;
  },
};

function createBaseGetUserTemplateRequest(): GetUserTemplateRequest {
  return { templateId: 0 };
}

export const GetUserTemplateRequest: MessageFns<GetUserTemplateRequest> = {
  encode(message: GetUserTemplateRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.templateId !== 0) {
      writer.uint32(8).int32(message.templateId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetUserTemplateRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetUserTemplateRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.templateId = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetUserTemplateRequest {
    return {
      templateId: isSet(object.templateId)
        ? globalThis.Number(object.templateId)
        : isSet(object.template_id)
        ? globalThis.Number(object.template_id)
        : 0,
    };
  },

  toJSON(message: GetUserTemplateRequest): unknown {
    const obj: any = {};
    if (message.templateId !== 0) {
      obj.templateId = Math.round(message.templateId);
    }
    return obj;
  },

  create(base?: DeepPartial<GetUserTemplateRequest>): GetUserTemplateRequest {
    return GetUserTemplateRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetUserTemplateRequest>): GetUserTemplateRequest {
    const message = createBaseGetUserTemplateRequest();
    message.templateId = object.templateId ?? 0;
    return message;
  },
};

function createBaseGetUserTemplateResponse(): GetUserTemplateResponse {
  return { success: false, message: "", template: undefined, timestamp: "" };
}

export const GetUserTemplateResponse: MessageFns<GetUserTemplateResponse> = {
  encode(message: GetUserTemplateResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    if (message.message !== "") {
      writer.uint32(18).string(message.message);
    }
    if (message.template !== undefined) {
      UserTemplate.encode(message.template, writer.uint32(26).fork()).join();
    }
    if (message.timestamp !== "") {
      writer.uint32(34).string(message.timestamp);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetUserTemplateResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetUserTemplateResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.message = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.template = UserTemplate.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.timestamp = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetUserTemplateResponse {
    return {
      success: isSet(object.success) ? globalThis.Boolean(object.success) : false,
      message: isSet(object.message) ? globalThis.String(object.message) : "",
      template: isSet(object.template) ? UserTemplate.fromJSON(object.template) : undefined,
      timestamp: isSet(object.timestamp) ? globalThis.String(object.timestamp) : "",
    };
  },

  toJSON(message: GetUserTemplateResponse): unknown {
    const obj: any = {};
    if (message.success !== false) {
      obj.success = message.success;
    }
    if (message.message !== "") {
      obj.message = message.message;
    }
    if (message.template !== undefined) {
      obj.template = UserTemplate.toJSON(message.template);
    }
    if (message.timestamp !== "") {
      obj.timestamp = message.timestamp;
    }
    return obj;
  },

  create(base?: DeepPartial<GetUserTemplateResponse>): GetUserTemplateResponse {
    return GetUserTemplateResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetUserTemplateResponse>): GetUserTemplateResponse {
    const message = createBaseGetUserTemplateResponse();
    message.success = object.success ?? false;
    message.message = object.message ?? "";
    message.template = (object.template !== undefined && object.template !== null)
      ? UserTemplate.fromPartial(object.template)
      : undefined;
    message.timestamp = object.timestamp ?? "";
    return message;
  },
};

function createBaseUpdateUserTemplateRequest(): UpdateUserTemplateRequest {
  return { templateId: 0, templateName: "", columnMapping: undefined, dateFormat: "", currency: "", fileFormats: [] };
}

export const UpdateUserTemplateRequest: MessageFns<UpdateUserTemplateRequest> = {
  encode(message: UpdateUserTemplateRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.templateId !== 0) {
      writer.uint32(8).int32(message.templateId);
    }
    if (message.templateName !== "") {
      writer.uint32(18).string(message.templateName);
    }
    if (message.columnMapping !== undefined) {
      ColumnMapping.encode(message.columnMapping, writer.uint32(26).fork()).join();
    }
    if (message.dateFormat !== "") {
      writer.uint32(34).string(message.dateFormat);
    }
    if (message.currency !== "") {
      writer.uint32(42).string(message.currency);
    }
    for (const v of message.fileFormats) {
      writer.uint32(50).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdateUserTemplateRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateUserTemplateRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.templateId = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.templateName = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.columnMapping = ColumnMapping.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.dateFormat = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.currency = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.fileFormats.push(reader.string());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateUserTemplateRequest {
    return {
      templateId: isSet(object.templateId)
        ? globalThis.Number(object.templateId)
        : isSet(object.template_id)
        ? globalThis.Number(object.template_id)
        : 0,
      templateName: isSet(object.templateName)
        ? globalThis.String(object.templateName)
        : isSet(object.template_name)
        ? globalThis.String(object.template_name)
        : "",
      columnMapping: isSet(object.columnMapping)
        ? ColumnMapping.fromJSON(object.columnMapping)
        : isSet(object.column_mapping)
        ? ColumnMapping.fromJSON(object.column_mapping)
        : undefined,
      dateFormat: isSet(object.dateFormat)
        ? globalThis.String(object.dateFormat)
        : isSet(object.date_format)
        ? globalThis.String(object.date_format)
        : "",
      currency: isSet(object.currency) ? globalThis.String(object.currency) : "",
      fileFormats: globalThis.Array.isArray(object?.fileFormats)
        ? object.fileFormats.map((e: any) => globalThis.String(e))
        : globalThis.Array.isArray(object?.file_formats)
        ? object.file_formats.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: UpdateUserTemplateRequest): unknown {
    const obj: any = {};
    if (message.templateId !== 0) {
      obj.templateId = Math.round(message.templateId);
    }
    if (message.templateName !== "") {
      obj.templateName = message.templateName;
    }
    if (message.columnMapping !== undefined) {
      obj.columnMapping = ColumnMapping.toJSON(message.columnMapping);
    }
    if (message.dateFormat !== "") {
      obj.dateFormat = message.dateFormat;
    }
    if (message.currency !== "") {
      obj.currency = message.currency;
    }
    if (message.fileFormats?.length) {
      obj.fileFormats = message.fileFormats;
    }
    return obj;
  },

  create(base?: DeepPartial<UpdateUserTemplateRequest>): UpdateUserTemplateRequest {
    return UpdateUserTemplateRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<UpdateUserTemplateRequest>): UpdateUserTemplateRequest {
    const message = createBaseUpdateUserTemplateRequest();
    message.templateId = object.templateId ?? 0;
    message.templateName = object.templateName ?? "";
    message.columnMapping = (object.columnMapping !== undefined && object.columnMapping !== null)
      ? ColumnMapping.fromPartial(object.columnMapping)
      : undefined;
    message.dateFormat = object.dateFormat ?? "";
    message.currency = object.currency ?? "";
    message.fileFormats = object.fileFormats?.map((e) => e) || [];
    return message;
  },
};

function createBaseUpdateUserTemplateResponse(): UpdateUserTemplateResponse {
  return { success: false, message: "", template: undefined, timestamp: "" };
}

export const UpdateUserTemplateResponse: MessageFns<UpdateUserTemplateResponse> = {
  encode(message: UpdateUserTemplateResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    if (message.message !== "") {
      writer.uint32(18).string(message.message);
    }
    if (message.template !== undefined) {
      UserTemplate.encode(message.template, writer.uint32(26).fork()).join();
    }
    if (message.timestamp !== "") {
      writer.uint32(34).string(message.timestamp);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdateUserTemplateResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateUserTemplateResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.message = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.template = UserTemplate.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.timestamp = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateUserTemplateResponse {
    return {
      success: isSet(object.success) ? globalThis.Boolean(object.success) : false,
      message: isSet(object.message) ? globalThis.String(object.message) : "",
      template: isSet(object.template) ? UserTemplate.fromJSON(object.template) : undefined,
      timestamp: isSet(object.timestamp) ? globalThis.String(object.timestamp) : "",
    };
  },

  toJSON(message: UpdateUserTemplateResponse): unknown {
    const obj: any = {};
    if (message.success !== false) {
      obj.success = message.success;
    }
    if (message.message !== "") {
      obj.message = message.message;
    }
    if (message.template !== undefined) {
      obj.template = UserTemplate.toJSON(message.template);
    }
    if (message.timestamp !== "") {
      obj.timestamp = message.timestamp;
    }
    return obj;
  },

  create(base?: DeepPartial<UpdateUserTemplateResponse>): UpdateUserTemplateResponse {
    return UpdateUserTemplateResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<UpdateUserTemplateResponse>): UpdateUserTemplateResponse {
    const message = createBaseUpdateUserTemplateResponse();
    message.success = object.success ?? false;
    message.message = object.message ?? "";
    message.template = (object.template !== undefined && object.template !== null)
      ? UserTemplate.fromPartial(object.template)
      : undefined;
    message.timestamp = object.timestamp ?? "";
    return message;
  },
};

function createBaseDeleteUserTemplateRequest(): DeleteUserTemplateRequest {
  return { templateId: 0 };
}

export const DeleteUserTemplateRequest: MessageFns<DeleteUserTemplateRequest> = {
  encode(message: DeleteUserTemplateRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.templateId !== 0) {
      writer.uint32(8).int32(message.templateId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteUserTemplateRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteUserTemplateRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.templateId = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeleteUserTemplateRequest {
    return {
      templateId: isSet(object.templateId)
        ? globalThis.Number(object.templateId)
        : isSet(object.template_id)
        ? globalThis.Number(object.template_id)
        : 0,
    };
  },

  toJSON(message: DeleteUserTemplateRequest): unknown {
    const obj: any = {};
    if (message.templateId !== 0) {
      obj.templateId = Math.round(message.templateId);
    }
    return obj;
  },

  create(base?: DeepPartial<DeleteUserTemplateRequest>): DeleteUserTemplateRequest {
    return DeleteUserTemplateRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DeleteUserTemplateRequest>): DeleteUserTemplateRequest {
    const message = createBaseDeleteUserTemplateRequest();
    message.templateId = object.templateId ?? 0;
    return message;
  },
};

function createBaseDeleteUserTemplateResponse(): DeleteUserTemplateResponse {
  return { success: false, message: "", timestamp: "" };
}

export const DeleteUserTemplateResponse: MessageFns<DeleteUserTemplateResponse> = {
  encode(message: DeleteUserTemplateResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    if (message.message !== "") {
      writer.uint32(18).string(message.message);
    }
    if (message.timestamp !== "") {
      writer.uint32(26).string(message.timestamp);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteUserTemplateResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteUserTemplateResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.message = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.timestamp = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeleteUserTemplateResponse {
    return {
      success: isSet(object.success) ? globalThis.Boolean(object.success) : false,
      message: isSet(object.message) ? globalThis.String(object.message) : "",
      timestamp: isSet(object.timestamp) ? globalThis.String(object.timestamp) : "",
    };
  },

  toJSON(message: DeleteUserTemplateResponse): unknown {
    const obj: any = {};
    if (message.success !== false) {
      obj.success = message.success;
    }
    if (message.message !== "") {
      obj.message = message.message;
    }
    if (message.timestamp !== "") {
      obj.timestamp = message.timestamp;
    }
    return obj;
  },

  create(base?: DeepPartial<DeleteUserTemplateResponse>): DeleteUserTemplateResponse {
    return DeleteUserTemplateResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DeleteUserTemplateResponse>): DeleteUserTemplateResponse {
    const message = createBaseDeleteUserTemplateResponse();
    message.success = object.success ?? false;
    message.message = object.message ?? "";
    message.timestamp = object.timestamp ?? "";
    return message;
  },
};

function createBaseUserTemplate(): UserTemplate {
  return {
    id: 0,
    userId: 0,
    name: "",
    columnMapping: undefined,
    dateFormat: "",
    currency: "",
    fileFormats: [],
    createdAt: 0,
    updatedAt: 0,
  };
}

export const UserTemplate: MessageFns<UserTemplate> = {
  encode(message: UserTemplate, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== 0) {
      writer.uint32(8).int32(message.id);
    }
    if (message.userId !== 0) {
      writer.uint32(16).int32(message.userId);
    }
    if (message.name !== "") {
      writer.uint32(26).string(message.name);
    }
    if (message.columnMapping !== undefined) {
      ColumnMapping.encode(message.columnMapping, writer.uint32(34).fork()).join();
    }
    if (message.dateFormat !== "") {
      writer.uint32(42).string(message.dateFormat);
    }
    if (message.currency !== "") {
      writer.uint32(50).string(message.currency);
    }
    for (const v of message.fileFormats) {
      writer.uint32(58).string(v!);
    }
    if (message.createdAt !== 0) {
      writer.uint32(64).int64(message.createdAt);
    }
    if (message.updatedAt !== 0) {
      writer.uint32(72).int64(message.updatedAt);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UserTemplate {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUserTemplate();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.id = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.userId = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.columnMapping = ColumnMapping.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.dateFormat = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.currency = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.fileFormats.push(reader.string());
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.createdAt = longToNumber(reader.int64());
          continue;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }

          message.updatedAt = longToNumber(reader.int64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UserTemplate {
    return {
      id: isSet(object.id) ? globalThis.Number(object.id) : 0,
      userId: isSet(object.userId)
        ? globalThis.Number(object.userId)
        : isSet(object.user_id)
        ? globalThis.Number(object.user_id)
        : 0,
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      columnMapping: isSet(object.columnMapping)
        ? ColumnMapping.fromJSON(object.columnMapping)
        : isSet(object.column_mapping)
        ? ColumnMapping.fromJSON(object.column_mapping)
        : undefined,
      dateFormat: isSet(object.dateFormat)
        ? globalThis.String(object.dateFormat)
        : isSet(object.date_format)
        ? globalThis.String(object.date_format)
        : "",
      currency: isSet(object.currency) ? globalThis.String(object.currency) : "",
      fileFormats: globalThis.Array.isArray(object?.fileFormats)
        ? object.fileFormats.map((e: any) => globalThis.String(e))
        : globalThis.Array.isArray(object?.file_formats)
        ? object.file_formats.map((e: any) => globalThis.String(e))
        : [],
      createdAt: isSet(object.createdAt)
        ? globalThis.Number(object.createdAt)
        : isSet(object.created_at)
        ? globalThis.Number(object.created_at)
        : 0,
      updatedAt: isSet(object.updatedAt)
        ? globalThis.Number(object.updatedAt)
        : isSet(object.updated_at)
        ? globalThis.Number(object.updated_at)
        : 0,
    };
  },

  toJSON(message: UserTemplate): unknown {
    const obj: any = {};
    if (message.id !== 0) {
      obj.id = Math.round(message.id);
    }
    if (message.userId !== 0) {
      obj.userId = Math.round(message.userId);
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.columnMapping !== undefined) {
      obj.columnMapping = ColumnMapping.toJSON(message.columnMapping);
    }
    if (message.dateFormat !== "") {
      obj.dateFormat = message.dateFormat;
    }
    if (message.currency !== "") {
      obj.currency = message.currency;
    }
    if (message.fileFormats?.length) {
      obj.fileFormats = message.fileFormats;
    }
    if (message.createdAt !== 0) {
      obj.createdAt = Math.round(message.createdAt);
    }
    if (message.updatedAt !== 0) {
      obj.updatedAt = Math.round(message.updatedAt);
    }
    return obj;
  },

  create(base?: DeepPartial<UserTemplate>): UserTemplate {
    return UserTemplate.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<UserTemplate>): UserTemplate {
    const message = createBaseUserTemplate();
    message.id = object.id ?? 0;
    message.userId = object.userId ?? 0;
    message.name = object.name ?? "";
    message.columnMapping = (object.columnMapping !== undefined && object.columnMapping !== null)
      ? ColumnMapping.fromPartial(object.columnMapping)
      : undefined;
    message.dateFormat = object.dateFormat ?? "";
    message.currency = object.currency ?? "";
    message.fileFormats = object.fileFormats?.map((e) => e) || [];
    message.createdAt = object.createdAt ?? 0;
    message.updatedAt = object.updatedAt ?? 0;
    return message;
  },
};

function createBaseGetJobStatusRequest(): GetJobStatusRequest {
  return { jobId: "" };
}

export const GetJobStatusRequest: MessageFns<GetJobStatusRequest> = {
  encode(message: GetJobStatusRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.jobId !== "") {
      writer.uint32(10).string(message.jobId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetJobStatusRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetJobStatusRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.jobId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetJobStatusRequest {
    return {
      jobId: isSet(object.jobId)
        ? globalThis.String(object.jobId)
        : isSet(object.job_id)
        ? globalThis.String(object.job_id)
        : "",
    };
  },

  toJSON(message: GetJobStatusRequest): unknown {
    const obj: any = {};
    if (message.jobId !== "") {
      obj.jobId = message.jobId;
    }
    return obj;
  },

  create(base?: DeepPartial<GetJobStatusRequest>): GetJobStatusRequest {
    return GetJobStatusRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetJobStatusRequest>): GetJobStatusRequest {
    const message = createBaseGetJobStatusRequest();
    message.jobId = object.jobId ?? "";
    return message;
  },
};

function createBaseGetJobStatusResponse(): GetJobStatusResponse {
  return { success: false, message: "", job: undefined, timestamp: "" };
}

export const GetJobStatusResponse: MessageFns<GetJobStatusResponse> = {
  encode(message: GetJobStatusResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    if (message.message !== "") {
      writer.uint32(18).string(message.message);
    }
    if (message.job !== undefined) {
      ImportJobStatus.encode(message.job, writer.uint32(26).fork()).join();
    }
    if (message.timestamp !== "") {
      writer.uint32(34).string(message.timestamp);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetJobStatusResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetJobStatusResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.message = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.job = ImportJobStatus.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.timestamp = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetJobStatusResponse {
    return {
      success: isSet(object.success) ? globalThis.Boolean(object.success) : false,
      message: isSet(object.message) ? globalThis.String(object.message) : "",
      job: isSet(object.job) ? ImportJobStatus.fromJSON(object.job) : undefined,
      timestamp: isSet(object.timestamp) ? globalThis.String(object.timestamp) : "",
    };
  },

  toJSON(message: GetJobStatusResponse): unknown {
    const obj: any = {};
    if (message.success !== false) {
      obj.success = message.success;
    }
    if (message.message !== "") {
      obj.message = message.message;
    }
    if (message.job !== undefined) {
      obj.job = ImportJobStatus.toJSON(message.job);
    }
    if (message.timestamp !== "") {
      obj.timestamp = message.timestamp;
    }
    return obj;
  },

  create(base?: DeepPartial<GetJobStatusResponse>): GetJobStatusResponse {
    return GetJobStatusResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetJobStatusResponse>): GetJobStatusResponse {
    const message = createBaseGetJobStatusResponse();
    message.success = object.success ?? false;
    message.message = object.message ?? "";
    message.job = (object.job !== undefined && object.job !== null)
      ? ImportJobStatus.fromPartial(object.job)
      : undefined;
    message.timestamp = object.timestamp ?? "";
    return message;
  },
};

function createBaseCancelJobRequest(): CancelJobRequest {
  return { jobId: "" };
}

export const CancelJobRequest: MessageFns<CancelJobRequest> = {
  encode(message: CancelJobRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.jobId !== "") {
      writer.uint32(10).string(message.jobId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CancelJobRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCancelJobRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.jobId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CancelJobRequest {
    return {
      jobId: isSet(object.jobId)
        ? globalThis.String(object.jobId)
        : isSet(object.job_id)
        ? globalThis.String(object.job_id)
        : "",
    };
  },

  toJSON(message: CancelJobRequest): unknown {
    const obj: any = {};
    if (message.jobId !== "") {
      obj.jobId = message.jobId;
    }
    return obj;
  },

  create(base?: DeepPartial<CancelJobRequest>): CancelJobRequest {
    return CancelJobRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CancelJobRequest>): CancelJobRequest {
    const message = createBaseCancelJobRequest();
    message.jobId = object.jobId ?? "";
    return message;
  },
};

function createBaseCancelJobResponse(): CancelJobResponse {
  return { success: false, message: "", timestamp: "" };
}

export const CancelJobResponse: MessageFns<CancelJobResponse> = {
  encode(message: CancelJobResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    if (message.message !== "") {
      writer.uint32(18).string(message.message);
    }
    if (message.timestamp !== "") {
      writer.uint32(26).string(message.timestamp);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CancelJobResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCancelJobResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.message = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.timestamp = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CancelJobResponse {
    return {
      success: isSet(object.success) ? globalThis.Boolean(object.success) : false,
      message: isSet(object.message) ? globalThis.String(object.message) : "",
      timestamp: isSet(object.timestamp) ? globalThis.String(object.timestamp) : "",
    };
  },

  toJSON(message: CancelJobResponse): unknown {
    const obj: any = {};
    if (message.success !== false) {
      obj.success = message.success;
    }
    if (message.message !== "") {
      obj.message = message.message;
    }
    if (message.timestamp !== "") {
      obj.timestamp = message.timestamp;
    }
    return obj;
  },

  create(base?: DeepPartial<CancelJobResponse>): CancelJobResponse {
    return CancelJobResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CancelJobResponse>): CancelJobResponse {
    const message = createBaseCancelJobResponse();
    message.success = object.success ?? false;
    message.message = object.message ?? "";
    message.timestamp = object.timestamp ?? "";
    return message;
  },
};

function createBaseListUserJobsRequest(): ListUserJobsRequest {
  return { status: 0 };
}

export const ListUserJobsRequest: MessageFns<ListUserJobsRequest> = {
  encode(message: ListUserJobsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.status !== 0) {
      writer.uint32(8).int32(message.status);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListUserJobsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListUserJobsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.status = reader.int32() as any;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListUserJobsRequest {
    return { status: isSet(object.status) ? jobStatusFromJSON(object.status) : 0 };
  },

  toJSON(message: ListUserJobsRequest): unknown {
    const obj: any = {};
    if (message.status !== 0) {
      obj.status = jobStatusToJSON(message.status);
    }
    return obj;
  },

  create(base?: DeepPartial<ListUserJobsRequest>): ListUserJobsRequest {
    return ListUserJobsRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListUserJobsRequest>): ListUserJobsRequest {
    const message = createBaseListUserJobsRequest();
    message.status = object.status ?? 0;
    return message;
  },
};

function createBaseListUserJobsResponse(): ListUserJobsResponse {
  return { success: false, message: "", jobs: [], timestamp: "" };
}

export const ListUserJobsResponse: MessageFns<ListUserJobsResponse> = {
  encode(message: ListUserJobsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    if (message.message !== "") {
      writer.uint32(18).string(message.message);
    }
    for (const v of message.jobs) {
      ImportJobStatus.encode(v!, writer.uint32(26).fork()).join();
    }
    if (message.timestamp !== "") {
      writer.uint32(34).string(message.timestamp);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListUserJobsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListUserJobsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.message = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.jobs.push(ImportJobStatus.decode(reader, reader.uint32()));
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.timestamp = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListUserJobsResponse {
    return {
      success: isSet(object.success) ? globalThis.Boolean(object.success) : false,
      message: isSet(object.message) ? globalThis.String(object.message) : "",
      jobs: globalThis.Array.isArray(object?.jobs) ? object.jobs.map((e: any) => ImportJobStatus.fromJSON(e)) : [],
      timestamp: isSet(object.timestamp) ? globalThis.String(object.timestamp) : "",
    };
  },

  toJSON(message: ListUserJobsResponse): unknown {
    const obj: any = {};
    if (message.success !== false) {
      obj.success = message.success;
    }
    if (message.message !== "") {
      obj.message = message.message;
    }
    if (message.jobs?.length) {
      obj.jobs = message.jobs.map((e) => ImportJobStatus.toJSON(e));
    }
    if (message.timestamp !== "") {
      obj.timestamp = message.timestamp;
    }
    return obj;
  },

  create(base?: DeepPartial<ListUserJobsResponse>): ListUserJobsResponse {
    return ListUserJobsResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListUserJobsResponse>): ListUserJobsResponse {
    const message = createBaseListUserJobsResponse();
    message.success = object.success ?? false;
    message.message = object.message ?? "";
    message.jobs = object.jobs?.map((e) => ImportJobStatus.fromPartial(e)) || [];
    message.timestamp = object.timestamp ?? "";
    return message;
  },
};

function createBaseImportJobStatus(): ImportJobStatus {
  return {
    jobId: "",
    userId: 0,
    fileId: "",
    walletId: 0,
    status: 0,
    progress: 0,
    processedCount: 0,
    totalCount: 0,
    result: undefined,
    error: "",
    createdAt: 0,
    startedAt: 0,
    completedAt: 0,
    expiresAt: 0,
  };
}

export const ImportJobStatus: MessageFns<ImportJobStatus> = {
  encode(message: ImportJobStatus, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.jobId !== "") {
      writer.uint32(10).string(message.jobId);
    }
    if (message.userId !== 0) {
      writer.uint32(16).int32(message.userId);
    }
    if (message.fileId !== "") {
      writer.uint32(26).string(message.fileId);
    }
    if (message.walletId !== 0) {
      writer.uint32(32).int32(message.walletId);
    }
    if (message.status !== 0) {
      writer.uint32(40).int32(message.status);
    }
    if (message.progress !== 0) {
      writer.uint32(48).int32(message.progress);
    }
    if (message.processedCount !== 0) {
      writer.uint32(56).int32(message.processedCount);
    }
    if (message.totalCount !== 0) {
      writer.uint32(64).int32(message.totalCount);
    }
    if (message.result !== undefined) {
      ExecuteImportResponse.encode(message.result, writer.uint32(74).fork()).join();
    }
    if (message.error !== "") {
      writer.uint32(82).string(message.error);
    }
    if (message.createdAt !== 0) {
      writer.uint32(88).int64(message.createdAt);
    }
    if (message.startedAt !== 0) {
      writer.uint32(96).int64(message.startedAt);
    }
    if (message.completedAt !== 0) {
      writer.uint32(104).int64(message.completedAt);
    }
    if (message.expiresAt !== 0) {
      writer.uint32(112).int64(message.expiresAt);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ImportJobStatus {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseImportJobStatus();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.jobId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.userId = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.fileId = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.walletId = reader.int32();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.status = reader.int32() as any;
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.progress = reader.int32();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.processedCount = reader.int32();
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.totalCount = reader.int32();
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.result = ExecuteImportResponse.decode(reader, reader.uint32());
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.error = reader.string();
          continue;
        }
        case 11: {
          if (tag !== 88) {
            break;
          }

          message.createdAt = longToNumber(reader.int64());
          continue;
        }
        case 12: {
          if (tag !== 96) {
            break;
          }

          message.startedAt = longToNumber(reader.int64());
          continue;
        }
        case 13: {
          if (tag !== 104) {
            break;
          }

          message.completedAt = longToNumber(reader.int64());
          continue;
        }
        case 14: {
          if (tag !== 112) {
            break;
          }

          message.expiresAt = longToNumber(reader.int64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ImportJobStatus {
    return {
      jobId: isSet(object.jobId)
        ? globalThis.String(object.jobId)
        : isSet(object.job_id)
        ? globalThis.String(object.job_id)
        : "",
      userId: isSet(object.userId)
        ? globalThis.Number(object.userId)
        : isSet(object.user_id)
        ? globalThis.Number(object.user_id)
        : 0,
      fileId: isSet(object.fileId)
        ? globalThis.String(object.fileId)
        : isSet(object.file_id)
        ? globalThis.String(object.file_id)
        : "",
      walletId: isSet(object.walletId)
        ? globalThis.Number(object.walletId)
        : isSet(object.wallet_id)
        ? globalThis.Number(object.wallet_id)
        : 0,
      status: isSet(object.status) ? jobStatusFromJSON(object.status) : 0,
      progress: isSet(object.progress) ? globalThis.Number(object.progress) : 0,
      processedCount: isSet(object.processedCount)
        ? globalThis.Number(object.processedCount)
        : isSet(object.processed_count)
        ? globalThis.Number(object.processed_count)
        : 0,
      totalCount: isSet(object.totalCount)
        ? globalThis.Number(object.totalCount)
        : isSet(object.total_count)
        ? globalThis.Number(object.total_count)
        : 0,
      result: isSet(object.result) ? ExecuteImportResponse.fromJSON(object.result) : undefined,
      error: isSet(object.error) ? globalThis.String(object.error) : "",
      createdAt: isSet(object.createdAt)
        ? globalThis.Number(object.createdAt)
        : isSet(object.created_at)
        ? globalThis.Number(object.created_at)
        : 0,
      startedAt: isSet(object.startedAt)
        ? globalThis.Number(object.startedAt)
        : isSet(object.started_at)
        ? globalThis.Number(object.started_at)
        : 0,
      completedAt: isSet(object.completedAt)
        ? globalThis.Number(object.completedAt)
        : isSet(object.completed_at)
        ? globalThis.Number(object.completed_at)
        : 0,
      expiresAt: isSet(object.expiresAt)
        ? globalThis.Number(object.expiresAt)
        : isSet(object.expires_at)
        ? globalThis.Number(object.expires_at)
        : 0,
    };
  },

  toJSON(message: ImportJobStatus): unknown {
    const obj: any = {};
    if (message.jobId !== "") {
      obj.jobId = message.jobId;
    }
    if (message.userId !== 0) {
      obj.userId = Math.round(message.userId);
    }
    if (message.fileId !== "") {
      obj.fileId = message.fileId;
    }
    if (message.walletId !== 0) {
      obj.walletId = Math.round(message.walletId);
    }
    if (message.status !== 0) {
      obj.status = jobStatusToJSON(message.status);
    }
    if (message.progress !== 0) {
      obj.progress = Math.round(message.progress);
    }
    if (message.processedCount !== 0) {
      obj.processedCount = Math.round(message.processedCount);
    }
    if (message.totalCount !== 0) {
      obj.totalCount = Math.round(message.totalCount);
    }
    if (message.result !== undefined) {
      obj.result = ExecuteImportResponse.toJSON(message.result);
    }
    if (message.error !== "") {
      obj.error = message.error;
    }
    if (message.createdAt !== 0) {
      obj.createdAt = Math.round(message.createdAt);
    }
    if (message.startedAt !== 0) {
      obj.startedAt = Math.round(message.startedAt);
    }
    if (message.completedAt !== 0) {
      obj.completedAt = Math.round(message.completedAt);
    }
    if (message.expiresAt !== 0) {
      obj.expiresAt = Math.round(message.expiresAt);
    }
    return obj;
  },

  create(base?: DeepPartial<ImportJobStatus>): ImportJobStatus {
    return ImportJobStatus.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ImportJobStatus>): ImportJobStatus {
    const message = createBaseImportJobStatus();
    message.jobId = object.jobId ?? "";
    message.userId = object.userId ?? 0;
    message.fileId = object.fileId ?? "";
    message.walletId = object.walletId ?? 0;
    message.status = object.status ?? 0;
    message.progress = object.progress ?? 0;
    message.processedCount = object.processedCount ?? 0;
    message.totalCount = object.totalCount ?? 0;
    message.result = (object.result !== undefined && object.result !== null)
      ? ExecuteImportResponse.fromPartial(object.result)
      : undefined;
    message.error = object.error ?? "";
    message.createdAt = object.createdAt ?? 0;
    message.startedAt = object.startedAt ?? 0;
    message.completedAt = object.completedAt ?? 0;
    message.expiresAt = object.expiresAt ?? 0;
    return message;
  },
};

function bytesFromBase64(b64: string): Uint8Array {
  if ((globalThis as any).Buffer) {
    return Uint8Array.from(globalThis.Buffer.from(b64, "base64"));
  } else {
    const bin = globalThis.atob(b64);
    const arr = new Uint8Array(bin.length);
    for (let i = 0; i < bin.length; ++i) {
      arr[i] = bin.charCodeAt(i);
    }
    return arr;
  }
}

function base64FromBytes(arr: Uint8Array): string {
  if ((globalThis as any).Buffer) {
    return globalThis.Buffer.from(arr).toString("base64");
  } else {
    const bin: string[] = [];
    arr.forEach((byte) => {
      bin.push(globalThis.String.fromCharCode(byte));
    });
    return globalThis.btoa(bin.join(""));
  }
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends { $case: string } ? { [K in keyof Omit<T, "$case">]?: DeepPartial<T[K]> } & { $case: T["$case"] }
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function longToNumber(int64: { toString(): string }): number {
  const num = globalThis.Number(int64.toString());
  if (num > globalThis.Number.MAX_SAFE_INTEGER) {
    throw new globalThis.Error("Value is larger than Number.MAX_SAFE_INTEGER");
  }
  if (num < globalThis.Number.MIN_SAFE_INTEGER) {
    throw new globalThis.Error("Value is smaller than Number.MIN_SAFE_INTEGER");
  }
  return num;
}

function isObject(value: any): boolean {
  return typeof value === "object" && value !== null;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
