// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.11.2
//   protoc               unknown
// source: protobuf/v1/import.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import { Money, PaginationParams, PaginationResult } from "./common";
import { Transaction, TransactionType, transactionTypeFromJSON, transactionTypeToJSON } from "./transaction";

export const protobufPackage = "wealthjourney.import.v1";

export const DuplicateHandlingStrategy = {
  DUPLICATE_STRATEGY_UNSPECIFIED: 0,
  DUPLICATE_STRATEGY_AUTO_MERGE: 1,
  DUPLICATE_STRATEGY_REVIEW_EACH: 2,
  DUPLICATE_STRATEGY_KEEP_ALL: 3,
  DUPLICATE_STRATEGY_SKIP_ALL: 4,
  UNRECOGNIZED: -1,
} as const;

export type DuplicateHandlingStrategy = typeof DuplicateHandlingStrategy[keyof typeof DuplicateHandlingStrategy];

export namespace DuplicateHandlingStrategy {
  export type DUPLICATE_STRATEGY_UNSPECIFIED = typeof DuplicateHandlingStrategy.DUPLICATE_STRATEGY_UNSPECIFIED;
  export type DUPLICATE_STRATEGY_AUTO_MERGE = typeof DuplicateHandlingStrategy.DUPLICATE_STRATEGY_AUTO_MERGE;
  export type DUPLICATE_STRATEGY_REVIEW_EACH = typeof DuplicateHandlingStrategy.DUPLICATE_STRATEGY_REVIEW_EACH;
  export type DUPLICATE_STRATEGY_KEEP_ALL = typeof DuplicateHandlingStrategy.DUPLICATE_STRATEGY_KEEP_ALL;
  export type DUPLICATE_STRATEGY_SKIP_ALL = typeof DuplicateHandlingStrategy.DUPLICATE_STRATEGY_SKIP_ALL;
  export type UNRECOGNIZED = typeof DuplicateHandlingStrategy.UNRECOGNIZED;
}

export function duplicateHandlingStrategyFromJSON(object: any): DuplicateHandlingStrategy {
  switch (object) {
    case 0:
    case "DUPLICATE_STRATEGY_UNSPECIFIED":
      return DuplicateHandlingStrategy.DUPLICATE_STRATEGY_UNSPECIFIED;
    case 1:
    case "DUPLICATE_STRATEGY_AUTO_MERGE":
      return DuplicateHandlingStrategy.DUPLICATE_STRATEGY_AUTO_MERGE;
    case 2:
    case "DUPLICATE_STRATEGY_REVIEW_EACH":
      return DuplicateHandlingStrategy.DUPLICATE_STRATEGY_REVIEW_EACH;
    case 3:
    case "DUPLICATE_STRATEGY_KEEP_ALL":
      return DuplicateHandlingStrategy.DUPLICATE_STRATEGY_KEEP_ALL;
    case 4:
    case "DUPLICATE_STRATEGY_SKIP_ALL":
      return DuplicateHandlingStrategy.DUPLICATE_STRATEGY_SKIP_ALL;
    case -1:
    case "UNRECOGNIZED":
    default:
      return DuplicateHandlingStrategy.UNRECOGNIZED;
  }
}

export function duplicateHandlingStrategyToJSON(object: DuplicateHandlingStrategy): string {
  switch (object) {
    case DuplicateHandlingStrategy.DUPLICATE_STRATEGY_UNSPECIFIED:
      return "DUPLICATE_STRATEGY_UNSPECIFIED";
    case DuplicateHandlingStrategy.DUPLICATE_STRATEGY_AUTO_MERGE:
      return "DUPLICATE_STRATEGY_AUTO_MERGE";
    case DuplicateHandlingStrategy.DUPLICATE_STRATEGY_REVIEW_EACH:
      return "DUPLICATE_STRATEGY_REVIEW_EACH";
    case DuplicateHandlingStrategy.DUPLICATE_STRATEGY_KEEP_ALL:
      return "DUPLICATE_STRATEGY_KEEP_ALL";
    case DuplicateHandlingStrategy.DUPLICATE_STRATEGY_SKIP_ALL:
      return "DUPLICATE_STRATEGY_SKIP_ALL";
    case DuplicateHandlingStrategy.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface UploadStatementFileRequest {
  fileData: Uint8Array;
  fileName: string;
  /** csv, excel, pdf */
  fileType: string;
  fileSize: number;
}

export interface UploadStatementFileResponse {
  success: boolean;
  message: string;
  fileId: string;
  timestamp: string;
}

export interface ParseStatementRequest {
  fileId: string;
  /** Optional: e.g., "vcb-credit-card" */
  bankTemplateId: string;
  /** For custom format */
  customMapping: ColumnMapping | undefined;
}

export interface ColumnMapping {
  dateColumn: string;
  amountColumn: string;
  descriptionColumn: string;
  /** Optional */
  typeColumn: string;
  /** Optional */
  categoryColumn: string;
  /** Optional */
  referenceColumn: string;
  /** e.g., "DD/MM/YYYY" */
  dateFormat: string;
  currency: string;
}

export interface ParseStatementResponse {
  success: boolean;
  message: string;
  transactions: ParsedTransaction[];
  statistics: ParseStatistics | undefined;
  timestamp: string;
}

export interface ParsedTransaction {
  rowNumber: number;
  /** Unix timestamp */
  date: number;
  amount: Money | undefined;
  description: string;
  type: TransactionType;
  suggestedCategoryId: number;
  /** 0-100 */
  categoryConfidence: number;
  referenceNumber: string;
  validationErrors: ValidationError[];
  isValid: boolean;
}

export interface ValidationError {
  field: string;
  message: string;
  /** error, warning, info */
  severity: string;
}

export interface ParseStatistics {
  totalRows: number;
  validRows: number;
  errorRows: number;
  warningRows: number;
}

export interface DetectDuplicatesRequest {
  transactions: ParsedTransaction[];
  walletId: number;
}

export interface DetectDuplicatesResponse {
  success: boolean;
  message: string;
  matches: DuplicateMatch[];
  timestamp: string;
}

export interface DuplicateMatch {
  importedTransaction: ParsedTransaction | undefined;
  existingTransaction:
    | Transaction
    | undefined;
  /** 50-100 (Level 1-4) */
  confidence: number;
  matchReason: string;
}

export interface ExecuteImportRequest {
  fileId: string;
  walletId: number;
  transactions: ParsedTransaction[];
  strategy: DuplicateHandlingStrategy;
  /** Rows user unchecked */
  excludedRowNumbers: number[];
  /** Optional date range filter */
  dateFilterStart: number;
  dateFilterEnd: number;
}

export interface ExecuteImportResponse {
  success: boolean;
  message: string;
  importBatchId: string;
  summary: ImportSummary | undefined;
  timestamp: string;
}

export interface ImportSummary {
  totalImported: number;
  totalSkipped: number;
  duplicatesMerged: number;
  duplicatesSkipped: number;
  totalIncome: Money | undefined;
  totalExpenses: Money | undefined;
  netChange: Money | undefined;
  newWalletBalance: Money | undefined;
}

export interface ListBankTemplatesRequest {
}

export interface ListBankTemplatesResponse {
  success: boolean;
  message: string;
  templates: BankTemplate[];
  timestamp: string;
}

export interface BankTemplate {
  id: string;
  name: string;
  bankCode: string;
  /** credit, debit, checking */
  statementType: string;
  fileFormats: string[];
}

export interface GetImportHistoryRequest {
  pagination: PaginationParams | undefined;
}

export interface GetImportHistoryResponse {
  success: boolean;
  message: string;
  batches: ImportBatch[];
  pagination: PaginationResult | undefined;
  timestamp: string;
}

export interface ImportBatch {
  id: string;
  userId: number;
  walletId: number;
  fileName: string;
  fileType: string;
  bankTemplate: string;
  importedAt: number;
  summary: ImportSummary | undefined;
  canUndo: boolean;
  undoExpiresAt: number;
}

export interface UndoImportRequest {
  importId: string;
}

export interface UndoImportResponse {
  success: boolean;
  message: string;
  timestamp: string;
}

function createBaseUploadStatementFileRequest(): UploadStatementFileRequest {
  return { fileData: new Uint8Array(0), fileName: "", fileType: "", fileSize: 0 };
}

export const UploadStatementFileRequest: MessageFns<UploadStatementFileRequest> = {
  encode(message: UploadStatementFileRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.fileData.length !== 0) {
      writer.uint32(10).bytes(message.fileData);
    }
    if (message.fileName !== "") {
      writer.uint32(18).string(message.fileName);
    }
    if (message.fileType !== "") {
      writer.uint32(26).string(message.fileType);
    }
    if (message.fileSize !== 0) {
      writer.uint32(32).int64(message.fileSize);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UploadStatementFileRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUploadStatementFileRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.fileData = reader.bytes();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.fileName = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.fileType = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.fileSize = longToNumber(reader.int64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UploadStatementFileRequest {
    return {
      fileData: isSet(object.fileData)
        ? bytesFromBase64(object.fileData)
        : isSet(object.file_data)
        ? bytesFromBase64(object.file_data)
        : new Uint8Array(0),
      fileName: isSet(object.fileName)
        ? globalThis.String(object.fileName)
        : isSet(object.file_name)
        ? globalThis.String(object.file_name)
        : "",
      fileType: isSet(object.fileType)
        ? globalThis.String(object.fileType)
        : isSet(object.file_type)
        ? globalThis.String(object.file_type)
        : "",
      fileSize: isSet(object.fileSize)
        ? globalThis.Number(object.fileSize)
        : isSet(object.file_size)
        ? globalThis.Number(object.file_size)
        : 0,
    };
  },

  toJSON(message: UploadStatementFileRequest): unknown {
    const obj: any = {};
    if (message.fileData.length !== 0) {
      obj.fileData = base64FromBytes(message.fileData);
    }
    if (message.fileName !== "") {
      obj.fileName = message.fileName;
    }
    if (message.fileType !== "") {
      obj.fileType = message.fileType;
    }
    if (message.fileSize !== 0) {
      obj.fileSize = Math.round(message.fileSize);
    }
    return obj;
  },

  create(base?: DeepPartial<UploadStatementFileRequest>): UploadStatementFileRequest {
    return UploadStatementFileRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<UploadStatementFileRequest>): UploadStatementFileRequest {
    const message = createBaseUploadStatementFileRequest();
    message.fileData = object.fileData ?? new Uint8Array(0);
    message.fileName = object.fileName ?? "";
    message.fileType = object.fileType ?? "";
    message.fileSize = object.fileSize ?? 0;
    return message;
  },
};

function createBaseUploadStatementFileResponse(): UploadStatementFileResponse {
  return { success: false, message: "", fileId: "", timestamp: "" };
}

export const UploadStatementFileResponse: MessageFns<UploadStatementFileResponse> = {
  encode(message: UploadStatementFileResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    if (message.message !== "") {
      writer.uint32(18).string(message.message);
    }
    if (message.fileId !== "") {
      writer.uint32(26).string(message.fileId);
    }
    if (message.timestamp !== "") {
      writer.uint32(34).string(message.timestamp);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UploadStatementFileResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUploadStatementFileResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.message = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.fileId = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.timestamp = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UploadStatementFileResponse {
    return {
      success: isSet(object.success) ? globalThis.Boolean(object.success) : false,
      message: isSet(object.message) ? globalThis.String(object.message) : "",
      fileId: isSet(object.fileId)
        ? globalThis.String(object.fileId)
        : isSet(object.file_id)
        ? globalThis.String(object.file_id)
        : "",
      timestamp: isSet(object.timestamp) ? globalThis.String(object.timestamp) : "",
    };
  },

  toJSON(message: UploadStatementFileResponse): unknown {
    const obj: any = {};
    if (message.success !== false) {
      obj.success = message.success;
    }
    if (message.message !== "") {
      obj.message = message.message;
    }
    if (message.fileId !== "") {
      obj.fileId = message.fileId;
    }
    if (message.timestamp !== "") {
      obj.timestamp = message.timestamp;
    }
    return obj;
  },

  create(base?: DeepPartial<UploadStatementFileResponse>): UploadStatementFileResponse {
    return UploadStatementFileResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<UploadStatementFileResponse>): UploadStatementFileResponse {
    const message = createBaseUploadStatementFileResponse();
    message.success = object.success ?? false;
    message.message = object.message ?? "";
    message.fileId = object.fileId ?? "";
    message.timestamp = object.timestamp ?? "";
    return message;
  },
};

function createBaseParseStatementRequest(): ParseStatementRequest {
  return { fileId: "", bankTemplateId: "", customMapping: undefined };
}

export const ParseStatementRequest: MessageFns<ParseStatementRequest> = {
  encode(message: ParseStatementRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.fileId !== "") {
      writer.uint32(10).string(message.fileId);
    }
    if (message.bankTemplateId !== "") {
      writer.uint32(18).string(message.bankTemplateId);
    }
    if (message.customMapping !== undefined) {
      ColumnMapping.encode(message.customMapping, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ParseStatementRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseParseStatementRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.fileId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.bankTemplateId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.customMapping = ColumnMapping.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ParseStatementRequest {
    return {
      fileId: isSet(object.fileId)
        ? globalThis.String(object.fileId)
        : isSet(object.file_id)
        ? globalThis.String(object.file_id)
        : "",
      bankTemplateId: isSet(object.bankTemplateId)
        ? globalThis.String(object.bankTemplateId)
        : isSet(object.bank_template_id)
        ? globalThis.String(object.bank_template_id)
        : "",
      customMapping: isSet(object.customMapping)
        ? ColumnMapping.fromJSON(object.customMapping)
        : isSet(object.custom_mapping)
        ? ColumnMapping.fromJSON(object.custom_mapping)
        : undefined,
    };
  },

  toJSON(message: ParseStatementRequest): unknown {
    const obj: any = {};
    if (message.fileId !== "") {
      obj.fileId = message.fileId;
    }
    if (message.bankTemplateId !== "") {
      obj.bankTemplateId = message.bankTemplateId;
    }
    if (message.customMapping !== undefined) {
      obj.customMapping = ColumnMapping.toJSON(message.customMapping);
    }
    return obj;
  },

  create(base?: DeepPartial<ParseStatementRequest>): ParseStatementRequest {
    return ParseStatementRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ParseStatementRequest>): ParseStatementRequest {
    const message = createBaseParseStatementRequest();
    message.fileId = object.fileId ?? "";
    message.bankTemplateId = object.bankTemplateId ?? "";
    message.customMapping = (object.customMapping !== undefined && object.customMapping !== null)
      ? ColumnMapping.fromPartial(object.customMapping)
      : undefined;
    return message;
  },
};

function createBaseColumnMapping(): ColumnMapping {
  return {
    dateColumn: "",
    amountColumn: "",
    descriptionColumn: "",
    typeColumn: "",
    categoryColumn: "",
    referenceColumn: "",
    dateFormat: "",
    currency: "",
  };
}

export const ColumnMapping: MessageFns<ColumnMapping> = {
  encode(message: ColumnMapping, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.dateColumn !== "") {
      writer.uint32(10).string(message.dateColumn);
    }
    if (message.amountColumn !== "") {
      writer.uint32(18).string(message.amountColumn);
    }
    if (message.descriptionColumn !== "") {
      writer.uint32(26).string(message.descriptionColumn);
    }
    if (message.typeColumn !== "") {
      writer.uint32(34).string(message.typeColumn);
    }
    if (message.categoryColumn !== "") {
      writer.uint32(42).string(message.categoryColumn);
    }
    if (message.referenceColumn !== "") {
      writer.uint32(50).string(message.referenceColumn);
    }
    if (message.dateFormat !== "") {
      writer.uint32(58).string(message.dateFormat);
    }
    if (message.currency !== "") {
      writer.uint32(66).string(message.currency);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ColumnMapping {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseColumnMapping();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.dateColumn = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.amountColumn = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.descriptionColumn = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.typeColumn = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.categoryColumn = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.referenceColumn = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.dateFormat = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.currency = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ColumnMapping {
    return {
      dateColumn: isSet(object.dateColumn)
        ? globalThis.String(object.dateColumn)
        : isSet(object.date_column)
        ? globalThis.String(object.date_column)
        : "",
      amountColumn: isSet(object.amountColumn)
        ? globalThis.String(object.amountColumn)
        : isSet(object.amount_column)
        ? globalThis.String(object.amount_column)
        : "",
      descriptionColumn: isSet(object.descriptionColumn)
        ? globalThis.String(object.descriptionColumn)
        : isSet(object.description_column)
        ? globalThis.String(object.description_column)
        : "",
      typeColumn: isSet(object.typeColumn)
        ? globalThis.String(object.typeColumn)
        : isSet(object.type_column)
        ? globalThis.String(object.type_column)
        : "",
      categoryColumn: isSet(object.categoryColumn)
        ? globalThis.String(object.categoryColumn)
        : isSet(object.category_column)
        ? globalThis.String(object.category_column)
        : "",
      referenceColumn: isSet(object.referenceColumn)
        ? globalThis.String(object.referenceColumn)
        : isSet(object.reference_column)
        ? globalThis.String(object.reference_column)
        : "",
      dateFormat: isSet(object.dateFormat)
        ? globalThis.String(object.dateFormat)
        : isSet(object.date_format)
        ? globalThis.String(object.date_format)
        : "",
      currency: isSet(object.currency) ? globalThis.String(object.currency) : "",
    };
  },

  toJSON(message: ColumnMapping): unknown {
    const obj: any = {};
    if (message.dateColumn !== "") {
      obj.dateColumn = message.dateColumn;
    }
    if (message.amountColumn !== "") {
      obj.amountColumn = message.amountColumn;
    }
    if (message.descriptionColumn !== "") {
      obj.descriptionColumn = message.descriptionColumn;
    }
    if (message.typeColumn !== "") {
      obj.typeColumn = message.typeColumn;
    }
    if (message.categoryColumn !== "") {
      obj.categoryColumn = message.categoryColumn;
    }
    if (message.referenceColumn !== "") {
      obj.referenceColumn = message.referenceColumn;
    }
    if (message.dateFormat !== "") {
      obj.dateFormat = message.dateFormat;
    }
    if (message.currency !== "") {
      obj.currency = message.currency;
    }
    return obj;
  },

  create(base?: DeepPartial<ColumnMapping>): ColumnMapping {
    return ColumnMapping.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ColumnMapping>): ColumnMapping {
    const message = createBaseColumnMapping();
    message.dateColumn = object.dateColumn ?? "";
    message.amountColumn = object.amountColumn ?? "";
    message.descriptionColumn = object.descriptionColumn ?? "";
    message.typeColumn = object.typeColumn ?? "";
    message.categoryColumn = object.categoryColumn ?? "";
    message.referenceColumn = object.referenceColumn ?? "";
    message.dateFormat = object.dateFormat ?? "";
    message.currency = object.currency ?? "";
    return message;
  },
};

function createBaseParseStatementResponse(): ParseStatementResponse {
  return { success: false, message: "", transactions: [], statistics: undefined, timestamp: "" };
}

export const ParseStatementResponse: MessageFns<ParseStatementResponse> = {
  encode(message: ParseStatementResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    if (message.message !== "") {
      writer.uint32(18).string(message.message);
    }
    for (const v of message.transactions) {
      ParsedTransaction.encode(v!, writer.uint32(26).fork()).join();
    }
    if (message.statistics !== undefined) {
      ParseStatistics.encode(message.statistics, writer.uint32(34).fork()).join();
    }
    if (message.timestamp !== "") {
      writer.uint32(42).string(message.timestamp);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ParseStatementResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseParseStatementResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.message = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.transactions.push(ParsedTransaction.decode(reader, reader.uint32()));
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.statistics = ParseStatistics.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.timestamp = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ParseStatementResponse {
    return {
      success: isSet(object.success) ? globalThis.Boolean(object.success) : false,
      message: isSet(object.message) ? globalThis.String(object.message) : "",
      transactions: globalThis.Array.isArray(object?.transactions)
        ? object.transactions.map((e: any) => ParsedTransaction.fromJSON(e))
        : [],
      statistics: isSet(object.statistics) ? ParseStatistics.fromJSON(object.statistics) : undefined,
      timestamp: isSet(object.timestamp) ? globalThis.String(object.timestamp) : "",
    };
  },

  toJSON(message: ParseStatementResponse): unknown {
    const obj: any = {};
    if (message.success !== false) {
      obj.success = message.success;
    }
    if (message.message !== "") {
      obj.message = message.message;
    }
    if (message.transactions?.length) {
      obj.transactions = message.transactions.map((e) => ParsedTransaction.toJSON(e));
    }
    if (message.statistics !== undefined) {
      obj.statistics = ParseStatistics.toJSON(message.statistics);
    }
    if (message.timestamp !== "") {
      obj.timestamp = message.timestamp;
    }
    return obj;
  },

  create(base?: DeepPartial<ParseStatementResponse>): ParseStatementResponse {
    return ParseStatementResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ParseStatementResponse>): ParseStatementResponse {
    const message = createBaseParseStatementResponse();
    message.success = object.success ?? false;
    message.message = object.message ?? "";
    message.transactions = object.transactions?.map((e) => ParsedTransaction.fromPartial(e)) || [];
    message.statistics = (object.statistics !== undefined && object.statistics !== null)
      ? ParseStatistics.fromPartial(object.statistics)
      : undefined;
    message.timestamp = object.timestamp ?? "";
    return message;
  },
};

function createBaseParsedTransaction(): ParsedTransaction {
  return {
    rowNumber: 0,
    date: 0,
    amount: undefined,
    description: "",
    type: 0,
    suggestedCategoryId: 0,
    categoryConfidence: 0,
    referenceNumber: "",
    validationErrors: [],
    isValid: false,
  };
}

export const ParsedTransaction: MessageFns<ParsedTransaction> = {
  encode(message: ParsedTransaction, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.rowNumber !== 0) {
      writer.uint32(8).int32(message.rowNumber);
    }
    if (message.date !== 0) {
      writer.uint32(16).int64(message.date);
    }
    if (message.amount !== undefined) {
      Money.encode(message.amount, writer.uint32(26).fork()).join();
    }
    if (message.description !== "") {
      writer.uint32(34).string(message.description);
    }
    if (message.type !== 0) {
      writer.uint32(40).int32(message.type);
    }
    if (message.suggestedCategoryId !== 0) {
      writer.uint32(48).int32(message.suggestedCategoryId);
    }
    if (message.categoryConfidence !== 0) {
      writer.uint32(56).int32(message.categoryConfidence);
    }
    if (message.referenceNumber !== "") {
      writer.uint32(66).string(message.referenceNumber);
    }
    for (const v of message.validationErrors) {
      ValidationError.encode(v!, writer.uint32(74).fork()).join();
    }
    if (message.isValid !== false) {
      writer.uint32(80).bool(message.isValid);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ParsedTransaction {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseParsedTransaction();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.rowNumber = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.date = longToNumber(reader.int64());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.amount = Money.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.description = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.type = reader.int32() as any;
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.suggestedCategoryId = reader.int32();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.categoryConfidence = reader.int32();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.referenceNumber = reader.string();
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.validationErrors.push(ValidationError.decode(reader, reader.uint32()));
          continue;
        }
        case 10: {
          if (tag !== 80) {
            break;
          }

          message.isValid = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ParsedTransaction {
    return {
      rowNumber: isSet(object.rowNumber)
        ? globalThis.Number(object.rowNumber)
        : isSet(object.row_number)
        ? globalThis.Number(object.row_number)
        : 0,
      date: isSet(object.date) ? globalThis.Number(object.date) : 0,
      amount: isSet(object.amount) ? Money.fromJSON(object.amount) : undefined,
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      type: isSet(object.type) ? transactionTypeFromJSON(object.type) : 0,
      suggestedCategoryId: isSet(object.suggestedCategoryId)
        ? globalThis.Number(object.suggestedCategoryId)
        : isSet(object.suggested_category_id)
        ? globalThis.Number(object.suggested_category_id)
        : 0,
      categoryConfidence: isSet(object.categoryConfidence)
        ? globalThis.Number(object.categoryConfidence)
        : isSet(object.category_confidence)
        ? globalThis.Number(object.category_confidence)
        : 0,
      referenceNumber: isSet(object.referenceNumber)
        ? globalThis.String(object.referenceNumber)
        : isSet(object.reference_number)
        ? globalThis.String(object.reference_number)
        : "",
      validationErrors: globalThis.Array.isArray(object?.validationErrors)
        ? object.validationErrors.map((e: any) => ValidationError.fromJSON(e))
        : globalThis.Array.isArray(object?.validation_errors)
        ? object.validation_errors.map((e: any) => ValidationError.fromJSON(e))
        : [],
      isValid: isSet(object.isValid)
        ? globalThis.Boolean(object.isValid)
        : isSet(object.is_valid)
        ? globalThis.Boolean(object.is_valid)
        : false,
    };
  },

  toJSON(message: ParsedTransaction): unknown {
    const obj: any = {};
    if (message.rowNumber !== 0) {
      obj.rowNumber = Math.round(message.rowNumber);
    }
    if (message.date !== 0) {
      obj.date = Math.round(message.date);
    }
    if (message.amount !== undefined) {
      obj.amount = Money.toJSON(message.amount);
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.type !== 0) {
      obj.type = transactionTypeToJSON(message.type);
    }
    if (message.suggestedCategoryId !== 0) {
      obj.suggestedCategoryId = Math.round(message.suggestedCategoryId);
    }
    if (message.categoryConfidence !== 0) {
      obj.categoryConfidence = Math.round(message.categoryConfidence);
    }
    if (message.referenceNumber !== "") {
      obj.referenceNumber = message.referenceNumber;
    }
    if (message.validationErrors?.length) {
      obj.validationErrors = message.validationErrors.map((e) => ValidationError.toJSON(e));
    }
    if (message.isValid !== false) {
      obj.isValid = message.isValid;
    }
    return obj;
  },

  create(base?: DeepPartial<ParsedTransaction>): ParsedTransaction {
    return ParsedTransaction.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ParsedTransaction>): ParsedTransaction {
    const message = createBaseParsedTransaction();
    message.rowNumber = object.rowNumber ?? 0;
    message.date = object.date ?? 0;
    message.amount = (object.amount !== undefined && object.amount !== null)
      ? Money.fromPartial(object.amount)
      : undefined;
    message.description = object.description ?? "";
    message.type = object.type ?? 0;
    message.suggestedCategoryId = object.suggestedCategoryId ?? 0;
    message.categoryConfidence = object.categoryConfidence ?? 0;
    message.referenceNumber = object.referenceNumber ?? "";
    message.validationErrors = object.validationErrors?.map((e) => ValidationError.fromPartial(e)) || [];
    message.isValid = object.isValid ?? false;
    return message;
  },
};

function createBaseValidationError(): ValidationError {
  return { field: "", message: "", severity: "" };
}

export const ValidationError: MessageFns<ValidationError> = {
  encode(message: ValidationError, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.field !== "") {
      writer.uint32(10).string(message.field);
    }
    if (message.message !== "") {
      writer.uint32(18).string(message.message);
    }
    if (message.severity !== "") {
      writer.uint32(26).string(message.severity);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ValidationError {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseValidationError();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.field = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.message = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.severity = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ValidationError {
    return {
      field: isSet(object.field) ? globalThis.String(object.field) : "",
      message: isSet(object.message) ? globalThis.String(object.message) : "",
      severity: isSet(object.severity) ? globalThis.String(object.severity) : "",
    };
  },

  toJSON(message: ValidationError): unknown {
    const obj: any = {};
    if (message.field !== "") {
      obj.field = message.field;
    }
    if (message.message !== "") {
      obj.message = message.message;
    }
    if (message.severity !== "") {
      obj.severity = message.severity;
    }
    return obj;
  },

  create(base?: DeepPartial<ValidationError>): ValidationError {
    return ValidationError.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ValidationError>): ValidationError {
    const message = createBaseValidationError();
    message.field = object.field ?? "";
    message.message = object.message ?? "";
    message.severity = object.severity ?? "";
    return message;
  },
};

function createBaseParseStatistics(): ParseStatistics {
  return { totalRows: 0, validRows: 0, errorRows: 0, warningRows: 0 };
}

export const ParseStatistics: MessageFns<ParseStatistics> = {
  encode(message: ParseStatistics, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.totalRows !== 0) {
      writer.uint32(8).int32(message.totalRows);
    }
    if (message.validRows !== 0) {
      writer.uint32(16).int32(message.validRows);
    }
    if (message.errorRows !== 0) {
      writer.uint32(24).int32(message.errorRows);
    }
    if (message.warningRows !== 0) {
      writer.uint32(32).int32(message.warningRows);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ParseStatistics {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseParseStatistics();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.totalRows = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.validRows = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.errorRows = reader.int32();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.warningRows = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ParseStatistics {
    return {
      totalRows: isSet(object.totalRows)
        ? globalThis.Number(object.totalRows)
        : isSet(object.total_rows)
        ? globalThis.Number(object.total_rows)
        : 0,
      validRows: isSet(object.validRows)
        ? globalThis.Number(object.validRows)
        : isSet(object.valid_rows)
        ? globalThis.Number(object.valid_rows)
        : 0,
      errorRows: isSet(object.errorRows)
        ? globalThis.Number(object.errorRows)
        : isSet(object.error_rows)
        ? globalThis.Number(object.error_rows)
        : 0,
      warningRows: isSet(object.warningRows)
        ? globalThis.Number(object.warningRows)
        : isSet(object.warning_rows)
        ? globalThis.Number(object.warning_rows)
        : 0,
    };
  },

  toJSON(message: ParseStatistics): unknown {
    const obj: any = {};
    if (message.totalRows !== 0) {
      obj.totalRows = Math.round(message.totalRows);
    }
    if (message.validRows !== 0) {
      obj.validRows = Math.round(message.validRows);
    }
    if (message.errorRows !== 0) {
      obj.errorRows = Math.round(message.errorRows);
    }
    if (message.warningRows !== 0) {
      obj.warningRows = Math.round(message.warningRows);
    }
    return obj;
  },

  create(base?: DeepPartial<ParseStatistics>): ParseStatistics {
    return ParseStatistics.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ParseStatistics>): ParseStatistics {
    const message = createBaseParseStatistics();
    message.totalRows = object.totalRows ?? 0;
    message.validRows = object.validRows ?? 0;
    message.errorRows = object.errorRows ?? 0;
    message.warningRows = object.warningRows ?? 0;
    return message;
  },
};

function createBaseDetectDuplicatesRequest(): DetectDuplicatesRequest {
  return { transactions: [], walletId: 0 };
}

export const DetectDuplicatesRequest: MessageFns<DetectDuplicatesRequest> = {
  encode(message: DetectDuplicatesRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.transactions) {
      ParsedTransaction.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.walletId !== 0) {
      writer.uint32(16).int32(message.walletId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DetectDuplicatesRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDetectDuplicatesRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.transactions.push(ParsedTransaction.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.walletId = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DetectDuplicatesRequest {
    return {
      transactions: globalThis.Array.isArray(object?.transactions)
        ? object.transactions.map((e: any) => ParsedTransaction.fromJSON(e))
        : [],
      walletId: isSet(object.walletId)
        ? globalThis.Number(object.walletId)
        : isSet(object.wallet_id)
        ? globalThis.Number(object.wallet_id)
        : 0,
    };
  },

  toJSON(message: DetectDuplicatesRequest): unknown {
    const obj: any = {};
    if (message.transactions?.length) {
      obj.transactions = message.transactions.map((e) => ParsedTransaction.toJSON(e));
    }
    if (message.walletId !== 0) {
      obj.walletId = Math.round(message.walletId);
    }
    return obj;
  },

  create(base?: DeepPartial<DetectDuplicatesRequest>): DetectDuplicatesRequest {
    return DetectDuplicatesRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DetectDuplicatesRequest>): DetectDuplicatesRequest {
    const message = createBaseDetectDuplicatesRequest();
    message.transactions = object.transactions?.map((e) => ParsedTransaction.fromPartial(e)) || [];
    message.walletId = object.walletId ?? 0;
    return message;
  },
};

function createBaseDetectDuplicatesResponse(): DetectDuplicatesResponse {
  return { success: false, message: "", matches: [], timestamp: "" };
}

export const DetectDuplicatesResponse: MessageFns<DetectDuplicatesResponse> = {
  encode(message: DetectDuplicatesResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    if (message.message !== "") {
      writer.uint32(18).string(message.message);
    }
    for (const v of message.matches) {
      DuplicateMatch.encode(v!, writer.uint32(26).fork()).join();
    }
    if (message.timestamp !== "") {
      writer.uint32(34).string(message.timestamp);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DetectDuplicatesResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDetectDuplicatesResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.message = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.matches.push(DuplicateMatch.decode(reader, reader.uint32()));
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.timestamp = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DetectDuplicatesResponse {
    return {
      success: isSet(object.success) ? globalThis.Boolean(object.success) : false,
      message: isSet(object.message) ? globalThis.String(object.message) : "",
      matches: globalThis.Array.isArray(object?.matches)
        ? object.matches.map((e: any) => DuplicateMatch.fromJSON(e))
        : [],
      timestamp: isSet(object.timestamp) ? globalThis.String(object.timestamp) : "",
    };
  },

  toJSON(message: DetectDuplicatesResponse): unknown {
    const obj: any = {};
    if (message.success !== false) {
      obj.success = message.success;
    }
    if (message.message !== "") {
      obj.message = message.message;
    }
    if (message.matches?.length) {
      obj.matches = message.matches.map((e) => DuplicateMatch.toJSON(e));
    }
    if (message.timestamp !== "") {
      obj.timestamp = message.timestamp;
    }
    return obj;
  },

  create(base?: DeepPartial<DetectDuplicatesResponse>): DetectDuplicatesResponse {
    return DetectDuplicatesResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DetectDuplicatesResponse>): DetectDuplicatesResponse {
    const message = createBaseDetectDuplicatesResponse();
    message.success = object.success ?? false;
    message.message = object.message ?? "";
    message.matches = object.matches?.map((e) => DuplicateMatch.fromPartial(e)) || [];
    message.timestamp = object.timestamp ?? "";
    return message;
  },
};

function createBaseDuplicateMatch(): DuplicateMatch {
  return { importedTransaction: undefined, existingTransaction: undefined, confidence: 0, matchReason: "" };
}

export const DuplicateMatch: MessageFns<DuplicateMatch> = {
  encode(message: DuplicateMatch, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.importedTransaction !== undefined) {
      ParsedTransaction.encode(message.importedTransaction, writer.uint32(10).fork()).join();
    }
    if (message.existingTransaction !== undefined) {
      Transaction.encode(message.existingTransaction, writer.uint32(18).fork()).join();
    }
    if (message.confidence !== 0) {
      writer.uint32(24).int32(message.confidence);
    }
    if (message.matchReason !== "") {
      writer.uint32(34).string(message.matchReason);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DuplicateMatch {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDuplicateMatch();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.importedTransaction = ParsedTransaction.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.existingTransaction = Transaction.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.confidence = reader.int32();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.matchReason = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DuplicateMatch {
    return {
      importedTransaction: isSet(object.importedTransaction)
        ? ParsedTransaction.fromJSON(object.importedTransaction)
        : isSet(object.imported_transaction)
        ? ParsedTransaction.fromJSON(object.imported_transaction)
        : undefined,
      existingTransaction: isSet(object.existingTransaction)
        ? Transaction.fromJSON(object.existingTransaction)
        : isSet(object.existing_transaction)
        ? Transaction.fromJSON(object.existing_transaction)
        : undefined,
      confidence: isSet(object.confidence) ? globalThis.Number(object.confidence) : 0,
      matchReason: isSet(object.matchReason)
        ? globalThis.String(object.matchReason)
        : isSet(object.match_reason)
        ? globalThis.String(object.match_reason)
        : "",
    };
  },

  toJSON(message: DuplicateMatch): unknown {
    const obj: any = {};
    if (message.importedTransaction !== undefined) {
      obj.importedTransaction = ParsedTransaction.toJSON(message.importedTransaction);
    }
    if (message.existingTransaction !== undefined) {
      obj.existingTransaction = Transaction.toJSON(message.existingTransaction);
    }
    if (message.confidence !== 0) {
      obj.confidence = Math.round(message.confidence);
    }
    if (message.matchReason !== "") {
      obj.matchReason = message.matchReason;
    }
    return obj;
  },

  create(base?: DeepPartial<DuplicateMatch>): DuplicateMatch {
    return DuplicateMatch.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DuplicateMatch>): DuplicateMatch {
    const message = createBaseDuplicateMatch();
    message.importedTransaction = (object.importedTransaction !== undefined && object.importedTransaction !== null)
      ? ParsedTransaction.fromPartial(object.importedTransaction)
      : undefined;
    message.existingTransaction = (object.existingTransaction !== undefined && object.existingTransaction !== null)
      ? Transaction.fromPartial(object.existingTransaction)
      : undefined;
    message.confidence = object.confidence ?? 0;
    message.matchReason = object.matchReason ?? "";
    return message;
  },
};

function createBaseExecuteImportRequest(): ExecuteImportRequest {
  return {
    fileId: "",
    walletId: 0,
    transactions: [],
    strategy: 0,
    excludedRowNumbers: [],
    dateFilterStart: 0,
    dateFilterEnd: 0,
  };
}

export const ExecuteImportRequest: MessageFns<ExecuteImportRequest> = {
  encode(message: ExecuteImportRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.fileId !== "") {
      writer.uint32(10).string(message.fileId);
    }
    if (message.walletId !== 0) {
      writer.uint32(16).int32(message.walletId);
    }
    for (const v of message.transactions) {
      ParsedTransaction.encode(v!, writer.uint32(26).fork()).join();
    }
    if (message.strategy !== 0) {
      writer.uint32(32).int32(message.strategy);
    }
    writer.uint32(42).fork();
    for (const v of message.excludedRowNumbers) {
      writer.int32(v);
    }
    writer.join();
    if (message.dateFilterStart !== 0) {
      writer.uint32(48).int64(message.dateFilterStart);
    }
    if (message.dateFilterEnd !== 0) {
      writer.uint32(56).int64(message.dateFilterEnd);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ExecuteImportRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseExecuteImportRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.fileId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.walletId = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.transactions.push(ParsedTransaction.decode(reader, reader.uint32()));
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.strategy = reader.int32() as any;
          continue;
        }
        case 5: {
          if (tag === 40) {
            message.excludedRowNumbers.push(reader.int32());

            continue;
          }

          if (tag === 42) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.excludedRowNumbers.push(reader.int32());
            }

            continue;
          }

          break;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.dateFilterStart = longToNumber(reader.int64());
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.dateFilterEnd = longToNumber(reader.int64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ExecuteImportRequest {
    return {
      fileId: isSet(object.fileId)
        ? globalThis.String(object.fileId)
        : isSet(object.file_id)
        ? globalThis.String(object.file_id)
        : "",
      walletId: isSet(object.walletId)
        ? globalThis.Number(object.walletId)
        : isSet(object.wallet_id)
        ? globalThis.Number(object.wallet_id)
        : 0,
      transactions: globalThis.Array.isArray(object?.transactions)
        ? object.transactions.map((e: any) => ParsedTransaction.fromJSON(e))
        : [],
      strategy: isSet(object.strategy) ? duplicateHandlingStrategyFromJSON(object.strategy) : 0,
      excludedRowNumbers: globalThis.Array.isArray(object?.excludedRowNumbers)
        ? object.excludedRowNumbers.map((e: any) => globalThis.Number(e))
        : globalThis.Array.isArray(object?.excluded_row_numbers)
        ? object.excluded_row_numbers.map((e: any) => globalThis.Number(e))
        : [],
      dateFilterStart: isSet(object.dateFilterStart)
        ? globalThis.Number(object.dateFilterStart)
        : isSet(object.date_filter_start)
        ? globalThis.Number(object.date_filter_start)
        : 0,
      dateFilterEnd: isSet(object.dateFilterEnd)
        ? globalThis.Number(object.dateFilterEnd)
        : isSet(object.date_filter_end)
        ? globalThis.Number(object.date_filter_end)
        : 0,
    };
  },

  toJSON(message: ExecuteImportRequest): unknown {
    const obj: any = {};
    if (message.fileId !== "") {
      obj.fileId = message.fileId;
    }
    if (message.walletId !== 0) {
      obj.walletId = Math.round(message.walletId);
    }
    if (message.transactions?.length) {
      obj.transactions = message.transactions.map((e) => ParsedTransaction.toJSON(e));
    }
    if (message.strategy !== 0) {
      obj.strategy = duplicateHandlingStrategyToJSON(message.strategy);
    }
    if (message.excludedRowNumbers?.length) {
      obj.excludedRowNumbers = message.excludedRowNumbers.map((e) => Math.round(e));
    }
    if (message.dateFilterStart !== 0) {
      obj.dateFilterStart = Math.round(message.dateFilterStart);
    }
    if (message.dateFilterEnd !== 0) {
      obj.dateFilterEnd = Math.round(message.dateFilterEnd);
    }
    return obj;
  },

  create(base?: DeepPartial<ExecuteImportRequest>): ExecuteImportRequest {
    return ExecuteImportRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ExecuteImportRequest>): ExecuteImportRequest {
    const message = createBaseExecuteImportRequest();
    message.fileId = object.fileId ?? "";
    message.walletId = object.walletId ?? 0;
    message.transactions = object.transactions?.map((e) => ParsedTransaction.fromPartial(e)) || [];
    message.strategy = object.strategy ?? 0;
    message.excludedRowNumbers = object.excludedRowNumbers?.map((e) => e) || [];
    message.dateFilterStart = object.dateFilterStart ?? 0;
    message.dateFilterEnd = object.dateFilterEnd ?? 0;
    return message;
  },
};

function createBaseExecuteImportResponse(): ExecuteImportResponse {
  return { success: false, message: "", importBatchId: "", summary: undefined, timestamp: "" };
}

export const ExecuteImportResponse: MessageFns<ExecuteImportResponse> = {
  encode(message: ExecuteImportResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    if (message.message !== "") {
      writer.uint32(18).string(message.message);
    }
    if (message.importBatchId !== "") {
      writer.uint32(26).string(message.importBatchId);
    }
    if (message.summary !== undefined) {
      ImportSummary.encode(message.summary, writer.uint32(34).fork()).join();
    }
    if (message.timestamp !== "") {
      writer.uint32(42).string(message.timestamp);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ExecuteImportResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseExecuteImportResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.message = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.importBatchId = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.summary = ImportSummary.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.timestamp = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ExecuteImportResponse {
    return {
      success: isSet(object.success) ? globalThis.Boolean(object.success) : false,
      message: isSet(object.message) ? globalThis.String(object.message) : "",
      importBatchId: isSet(object.importBatchId)
        ? globalThis.String(object.importBatchId)
        : isSet(object.import_batch_id)
        ? globalThis.String(object.import_batch_id)
        : "",
      summary: isSet(object.summary) ? ImportSummary.fromJSON(object.summary) : undefined,
      timestamp: isSet(object.timestamp) ? globalThis.String(object.timestamp) : "",
    };
  },

  toJSON(message: ExecuteImportResponse): unknown {
    const obj: any = {};
    if (message.success !== false) {
      obj.success = message.success;
    }
    if (message.message !== "") {
      obj.message = message.message;
    }
    if (message.importBatchId !== "") {
      obj.importBatchId = message.importBatchId;
    }
    if (message.summary !== undefined) {
      obj.summary = ImportSummary.toJSON(message.summary);
    }
    if (message.timestamp !== "") {
      obj.timestamp = message.timestamp;
    }
    return obj;
  },

  create(base?: DeepPartial<ExecuteImportResponse>): ExecuteImportResponse {
    return ExecuteImportResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ExecuteImportResponse>): ExecuteImportResponse {
    const message = createBaseExecuteImportResponse();
    message.success = object.success ?? false;
    message.message = object.message ?? "";
    message.importBatchId = object.importBatchId ?? "";
    message.summary = (object.summary !== undefined && object.summary !== null)
      ? ImportSummary.fromPartial(object.summary)
      : undefined;
    message.timestamp = object.timestamp ?? "";
    return message;
  },
};

function createBaseImportSummary(): ImportSummary {
  return {
    totalImported: 0,
    totalSkipped: 0,
    duplicatesMerged: 0,
    duplicatesSkipped: 0,
    totalIncome: undefined,
    totalExpenses: undefined,
    netChange: undefined,
    newWalletBalance: undefined,
  };
}

export const ImportSummary: MessageFns<ImportSummary> = {
  encode(message: ImportSummary, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.totalImported !== 0) {
      writer.uint32(8).int32(message.totalImported);
    }
    if (message.totalSkipped !== 0) {
      writer.uint32(16).int32(message.totalSkipped);
    }
    if (message.duplicatesMerged !== 0) {
      writer.uint32(24).int32(message.duplicatesMerged);
    }
    if (message.duplicatesSkipped !== 0) {
      writer.uint32(32).int32(message.duplicatesSkipped);
    }
    if (message.totalIncome !== undefined) {
      Money.encode(message.totalIncome, writer.uint32(42).fork()).join();
    }
    if (message.totalExpenses !== undefined) {
      Money.encode(message.totalExpenses, writer.uint32(50).fork()).join();
    }
    if (message.netChange !== undefined) {
      Money.encode(message.netChange, writer.uint32(58).fork()).join();
    }
    if (message.newWalletBalance !== undefined) {
      Money.encode(message.newWalletBalance, writer.uint32(66).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ImportSummary {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseImportSummary();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.totalImported = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.totalSkipped = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.duplicatesMerged = reader.int32();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.duplicatesSkipped = reader.int32();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.totalIncome = Money.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.totalExpenses = Money.decode(reader, reader.uint32());
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.netChange = Money.decode(reader, reader.uint32());
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.newWalletBalance = Money.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ImportSummary {
    return {
      totalImported: isSet(object.totalImported)
        ? globalThis.Number(object.totalImported)
        : isSet(object.total_imported)
        ? globalThis.Number(object.total_imported)
        : 0,
      totalSkipped: isSet(object.totalSkipped)
        ? globalThis.Number(object.totalSkipped)
        : isSet(object.total_skipped)
        ? globalThis.Number(object.total_skipped)
        : 0,
      duplicatesMerged: isSet(object.duplicatesMerged)
        ? globalThis.Number(object.duplicatesMerged)
        : isSet(object.duplicates_merged)
        ? globalThis.Number(object.duplicates_merged)
        : 0,
      duplicatesSkipped: isSet(object.duplicatesSkipped)
        ? globalThis.Number(object.duplicatesSkipped)
        : isSet(object.duplicates_skipped)
        ? globalThis.Number(object.duplicates_skipped)
        : 0,
      totalIncome: isSet(object.totalIncome)
        ? Money.fromJSON(object.totalIncome)
        : isSet(object.total_income)
        ? Money.fromJSON(object.total_income)
        : undefined,
      totalExpenses: isSet(object.totalExpenses)
        ? Money.fromJSON(object.totalExpenses)
        : isSet(object.total_expenses)
        ? Money.fromJSON(object.total_expenses)
        : undefined,
      netChange: isSet(object.netChange)
        ? Money.fromJSON(object.netChange)
        : isSet(object.net_change)
        ? Money.fromJSON(object.net_change)
        : undefined,
      newWalletBalance: isSet(object.newWalletBalance)
        ? Money.fromJSON(object.newWalletBalance)
        : isSet(object.new_wallet_balance)
        ? Money.fromJSON(object.new_wallet_balance)
        : undefined,
    };
  },

  toJSON(message: ImportSummary): unknown {
    const obj: any = {};
    if (message.totalImported !== 0) {
      obj.totalImported = Math.round(message.totalImported);
    }
    if (message.totalSkipped !== 0) {
      obj.totalSkipped = Math.round(message.totalSkipped);
    }
    if (message.duplicatesMerged !== 0) {
      obj.duplicatesMerged = Math.round(message.duplicatesMerged);
    }
    if (message.duplicatesSkipped !== 0) {
      obj.duplicatesSkipped = Math.round(message.duplicatesSkipped);
    }
    if (message.totalIncome !== undefined) {
      obj.totalIncome = Money.toJSON(message.totalIncome);
    }
    if (message.totalExpenses !== undefined) {
      obj.totalExpenses = Money.toJSON(message.totalExpenses);
    }
    if (message.netChange !== undefined) {
      obj.netChange = Money.toJSON(message.netChange);
    }
    if (message.newWalletBalance !== undefined) {
      obj.newWalletBalance = Money.toJSON(message.newWalletBalance);
    }
    return obj;
  },

  create(base?: DeepPartial<ImportSummary>): ImportSummary {
    return ImportSummary.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ImportSummary>): ImportSummary {
    const message = createBaseImportSummary();
    message.totalImported = object.totalImported ?? 0;
    message.totalSkipped = object.totalSkipped ?? 0;
    message.duplicatesMerged = object.duplicatesMerged ?? 0;
    message.duplicatesSkipped = object.duplicatesSkipped ?? 0;
    message.totalIncome = (object.totalIncome !== undefined && object.totalIncome !== null)
      ? Money.fromPartial(object.totalIncome)
      : undefined;
    message.totalExpenses = (object.totalExpenses !== undefined && object.totalExpenses !== null)
      ? Money.fromPartial(object.totalExpenses)
      : undefined;
    message.netChange = (object.netChange !== undefined && object.netChange !== null)
      ? Money.fromPartial(object.netChange)
      : undefined;
    message.newWalletBalance = (object.newWalletBalance !== undefined && object.newWalletBalance !== null)
      ? Money.fromPartial(object.newWalletBalance)
      : undefined;
    return message;
  },
};

function createBaseListBankTemplatesRequest(): ListBankTemplatesRequest {
  return {};
}

export const ListBankTemplatesRequest: MessageFns<ListBankTemplatesRequest> = {
  encode(_: ListBankTemplatesRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListBankTemplatesRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListBankTemplatesRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): ListBankTemplatesRequest {
    return {};
  },

  toJSON(_: ListBankTemplatesRequest): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<ListBankTemplatesRequest>): ListBankTemplatesRequest {
    return ListBankTemplatesRequest.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<ListBankTemplatesRequest>): ListBankTemplatesRequest {
    const message = createBaseListBankTemplatesRequest();
    return message;
  },
};

function createBaseListBankTemplatesResponse(): ListBankTemplatesResponse {
  return { success: false, message: "", templates: [], timestamp: "" };
}

export const ListBankTemplatesResponse: MessageFns<ListBankTemplatesResponse> = {
  encode(message: ListBankTemplatesResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    if (message.message !== "") {
      writer.uint32(18).string(message.message);
    }
    for (const v of message.templates) {
      BankTemplate.encode(v!, writer.uint32(26).fork()).join();
    }
    if (message.timestamp !== "") {
      writer.uint32(34).string(message.timestamp);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListBankTemplatesResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListBankTemplatesResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.message = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.templates.push(BankTemplate.decode(reader, reader.uint32()));
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.timestamp = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListBankTemplatesResponse {
    return {
      success: isSet(object.success) ? globalThis.Boolean(object.success) : false,
      message: isSet(object.message) ? globalThis.String(object.message) : "",
      templates: globalThis.Array.isArray(object?.templates)
        ? object.templates.map((e: any) => BankTemplate.fromJSON(e))
        : [],
      timestamp: isSet(object.timestamp) ? globalThis.String(object.timestamp) : "",
    };
  },

  toJSON(message: ListBankTemplatesResponse): unknown {
    const obj: any = {};
    if (message.success !== false) {
      obj.success = message.success;
    }
    if (message.message !== "") {
      obj.message = message.message;
    }
    if (message.templates?.length) {
      obj.templates = message.templates.map((e) => BankTemplate.toJSON(e));
    }
    if (message.timestamp !== "") {
      obj.timestamp = message.timestamp;
    }
    return obj;
  },

  create(base?: DeepPartial<ListBankTemplatesResponse>): ListBankTemplatesResponse {
    return ListBankTemplatesResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListBankTemplatesResponse>): ListBankTemplatesResponse {
    const message = createBaseListBankTemplatesResponse();
    message.success = object.success ?? false;
    message.message = object.message ?? "";
    message.templates = object.templates?.map((e) => BankTemplate.fromPartial(e)) || [];
    message.timestamp = object.timestamp ?? "";
    return message;
  },
};

function createBaseBankTemplate(): BankTemplate {
  return { id: "", name: "", bankCode: "", statementType: "", fileFormats: [] };
}

export const BankTemplate: MessageFns<BankTemplate> = {
  encode(message: BankTemplate, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    if (message.bankCode !== "") {
      writer.uint32(26).string(message.bankCode);
    }
    if (message.statementType !== "") {
      writer.uint32(34).string(message.statementType);
    }
    for (const v of message.fileFormats) {
      writer.uint32(42).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BankTemplate {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBankTemplate();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.bankCode = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.statementType = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.fileFormats.push(reader.string());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BankTemplate {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      bankCode: isSet(object.bankCode)
        ? globalThis.String(object.bankCode)
        : isSet(object.bank_code)
        ? globalThis.String(object.bank_code)
        : "",
      statementType: isSet(object.statementType)
        ? globalThis.String(object.statementType)
        : isSet(object.statement_type)
        ? globalThis.String(object.statement_type)
        : "",
      fileFormats: globalThis.Array.isArray(object?.fileFormats)
        ? object.fileFormats.map((e: any) => globalThis.String(e))
        : globalThis.Array.isArray(object?.file_formats)
        ? object.file_formats.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: BankTemplate): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.bankCode !== "") {
      obj.bankCode = message.bankCode;
    }
    if (message.statementType !== "") {
      obj.statementType = message.statementType;
    }
    if (message.fileFormats?.length) {
      obj.fileFormats = message.fileFormats;
    }
    return obj;
  },

  create(base?: DeepPartial<BankTemplate>): BankTemplate {
    return BankTemplate.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<BankTemplate>): BankTemplate {
    const message = createBaseBankTemplate();
    message.id = object.id ?? "";
    message.name = object.name ?? "";
    message.bankCode = object.bankCode ?? "";
    message.statementType = object.statementType ?? "";
    message.fileFormats = object.fileFormats?.map((e) => e) || [];
    return message;
  },
};

function createBaseGetImportHistoryRequest(): GetImportHistoryRequest {
  return { pagination: undefined };
}

export const GetImportHistoryRequest: MessageFns<GetImportHistoryRequest> = {
  encode(message: GetImportHistoryRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.pagination !== undefined) {
      PaginationParams.encode(message.pagination, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetImportHistoryRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetImportHistoryRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.pagination = PaginationParams.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetImportHistoryRequest {
    return { pagination: isSet(object.pagination) ? PaginationParams.fromJSON(object.pagination) : undefined };
  },

  toJSON(message: GetImportHistoryRequest): unknown {
    const obj: any = {};
    if (message.pagination !== undefined) {
      obj.pagination = PaginationParams.toJSON(message.pagination);
    }
    return obj;
  },

  create(base?: DeepPartial<GetImportHistoryRequest>): GetImportHistoryRequest {
    return GetImportHistoryRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetImportHistoryRequest>): GetImportHistoryRequest {
    const message = createBaseGetImportHistoryRequest();
    message.pagination = (object.pagination !== undefined && object.pagination !== null)
      ? PaginationParams.fromPartial(object.pagination)
      : undefined;
    return message;
  },
};

function createBaseGetImportHistoryResponse(): GetImportHistoryResponse {
  return { success: false, message: "", batches: [], pagination: undefined, timestamp: "" };
}

export const GetImportHistoryResponse: MessageFns<GetImportHistoryResponse> = {
  encode(message: GetImportHistoryResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    if (message.message !== "") {
      writer.uint32(18).string(message.message);
    }
    for (const v of message.batches) {
      ImportBatch.encode(v!, writer.uint32(26).fork()).join();
    }
    if (message.pagination !== undefined) {
      PaginationResult.encode(message.pagination, writer.uint32(34).fork()).join();
    }
    if (message.timestamp !== "") {
      writer.uint32(42).string(message.timestamp);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetImportHistoryResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetImportHistoryResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.message = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.batches.push(ImportBatch.decode(reader, reader.uint32()));
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.pagination = PaginationResult.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.timestamp = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetImportHistoryResponse {
    return {
      success: isSet(object.success) ? globalThis.Boolean(object.success) : false,
      message: isSet(object.message) ? globalThis.String(object.message) : "",
      batches: globalThis.Array.isArray(object?.batches) ? object.batches.map((e: any) => ImportBatch.fromJSON(e)) : [],
      pagination: isSet(object.pagination) ? PaginationResult.fromJSON(object.pagination) : undefined,
      timestamp: isSet(object.timestamp) ? globalThis.String(object.timestamp) : "",
    };
  },

  toJSON(message: GetImportHistoryResponse): unknown {
    const obj: any = {};
    if (message.success !== false) {
      obj.success = message.success;
    }
    if (message.message !== "") {
      obj.message = message.message;
    }
    if (message.batches?.length) {
      obj.batches = message.batches.map((e) => ImportBatch.toJSON(e));
    }
    if (message.pagination !== undefined) {
      obj.pagination = PaginationResult.toJSON(message.pagination);
    }
    if (message.timestamp !== "") {
      obj.timestamp = message.timestamp;
    }
    return obj;
  },

  create(base?: DeepPartial<GetImportHistoryResponse>): GetImportHistoryResponse {
    return GetImportHistoryResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetImportHistoryResponse>): GetImportHistoryResponse {
    const message = createBaseGetImportHistoryResponse();
    message.success = object.success ?? false;
    message.message = object.message ?? "";
    message.batches = object.batches?.map((e) => ImportBatch.fromPartial(e)) || [];
    message.pagination = (object.pagination !== undefined && object.pagination !== null)
      ? PaginationResult.fromPartial(object.pagination)
      : undefined;
    message.timestamp = object.timestamp ?? "";
    return message;
  },
};

function createBaseImportBatch(): ImportBatch {
  return {
    id: "",
    userId: 0,
    walletId: 0,
    fileName: "",
    fileType: "",
    bankTemplate: "",
    importedAt: 0,
    summary: undefined,
    canUndo: false,
    undoExpiresAt: 0,
  };
}

export const ImportBatch: MessageFns<ImportBatch> = {
  encode(message: ImportBatch, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.userId !== 0) {
      writer.uint32(16).int32(message.userId);
    }
    if (message.walletId !== 0) {
      writer.uint32(24).int32(message.walletId);
    }
    if (message.fileName !== "") {
      writer.uint32(34).string(message.fileName);
    }
    if (message.fileType !== "") {
      writer.uint32(42).string(message.fileType);
    }
    if (message.bankTemplate !== "") {
      writer.uint32(50).string(message.bankTemplate);
    }
    if (message.importedAt !== 0) {
      writer.uint32(56).int64(message.importedAt);
    }
    if (message.summary !== undefined) {
      ImportSummary.encode(message.summary, writer.uint32(66).fork()).join();
    }
    if (message.canUndo !== false) {
      writer.uint32(72).bool(message.canUndo);
    }
    if (message.undoExpiresAt !== 0) {
      writer.uint32(80).int64(message.undoExpiresAt);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ImportBatch {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseImportBatch();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.userId = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.walletId = reader.int32();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.fileName = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.fileType = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.bankTemplate = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.importedAt = longToNumber(reader.int64());
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.summary = ImportSummary.decode(reader, reader.uint32());
          continue;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }

          message.canUndo = reader.bool();
          continue;
        }
        case 10: {
          if (tag !== 80) {
            break;
          }

          message.undoExpiresAt = longToNumber(reader.int64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ImportBatch {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      userId: isSet(object.userId)
        ? globalThis.Number(object.userId)
        : isSet(object.user_id)
        ? globalThis.Number(object.user_id)
        : 0,
      walletId: isSet(object.walletId)
        ? globalThis.Number(object.walletId)
        : isSet(object.wallet_id)
        ? globalThis.Number(object.wallet_id)
        : 0,
      fileName: isSet(object.fileName)
        ? globalThis.String(object.fileName)
        : isSet(object.file_name)
        ? globalThis.String(object.file_name)
        : "",
      fileType: isSet(object.fileType)
        ? globalThis.String(object.fileType)
        : isSet(object.file_type)
        ? globalThis.String(object.file_type)
        : "",
      bankTemplate: isSet(object.bankTemplate)
        ? globalThis.String(object.bankTemplate)
        : isSet(object.bank_template)
        ? globalThis.String(object.bank_template)
        : "",
      importedAt: isSet(object.importedAt)
        ? globalThis.Number(object.importedAt)
        : isSet(object.imported_at)
        ? globalThis.Number(object.imported_at)
        : 0,
      summary: isSet(object.summary) ? ImportSummary.fromJSON(object.summary) : undefined,
      canUndo: isSet(object.canUndo)
        ? globalThis.Boolean(object.canUndo)
        : isSet(object.can_undo)
        ? globalThis.Boolean(object.can_undo)
        : false,
      undoExpiresAt: isSet(object.undoExpiresAt)
        ? globalThis.Number(object.undoExpiresAt)
        : isSet(object.undo_expires_at)
        ? globalThis.Number(object.undo_expires_at)
        : 0,
    };
  },

  toJSON(message: ImportBatch): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.userId !== 0) {
      obj.userId = Math.round(message.userId);
    }
    if (message.walletId !== 0) {
      obj.walletId = Math.round(message.walletId);
    }
    if (message.fileName !== "") {
      obj.fileName = message.fileName;
    }
    if (message.fileType !== "") {
      obj.fileType = message.fileType;
    }
    if (message.bankTemplate !== "") {
      obj.bankTemplate = message.bankTemplate;
    }
    if (message.importedAt !== 0) {
      obj.importedAt = Math.round(message.importedAt);
    }
    if (message.summary !== undefined) {
      obj.summary = ImportSummary.toJSON(message.summary);
    }
    if (message.canUndo !== false) {
      obj.canUndo = message.canUndo;
    }
    if (message.undoExpiresAt !== 0) {
      obj.undoExpiresAt = Math.round(message.undoExpiresAt);
    }
    return obj;
  },

  create(base?: DeepPartial<ImportBatch>): ImportBatch {
    return ImportBatch.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ImportBatch>): ImportBatch {
    const message = createBaseImportBatch();
    message.id = object.id ?? "";
    message.userId = object.userId ?? 0;
    message.walletId = object.walletId ?? 0;
    message.fileName = object.fileName ?? "";
    message.fileType = object.fileType ?? "";
    message.bankTemplate = object.bankTemplate ?? "";
    message.importedAt = object.importedAt ?? 0;
    message.summary = (object.summary !== undefined && object.summary !== null)
      ? ImportSummary.fromPartial(object.summary)
      : undefined;
    message.canUndo = object.canUndo ?? false;
    message.undoExpiresAt = object.undoExpiresAt ?? 0;
    return message;
  },
};

function createBaseUndoImportRequest(): UndoImportRequest {
  return { importId: "" };
}

export const UndoImportRequest: MessageFns<UndoImportRequest> = {
  encode(message: UndoImportRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.importId !== "") {
      writer.uint32(10).string(message.importId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UndoImportRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUndoImportRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.importId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UndoImportRequest {
    return {
      importId: isSet(object.importId)
        ? globalThis.String(object.importId)
        : isSet(object.import_id)
        ? globalThis.String(object.import_id)
        : "",
    };
  },

  toJSON(message: UndoImportRequest): unknown {
    const obj: any = {};
    if (message.importId !== "") {
      obj.importId = message.importId;
    }
    return obj;
  },

  create(base?: DeepPartial<UndoImportRequest>): UndoImportRequest {
    return UndoImportRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<UndoImportRequest>): UndoImportRequest {
    const message = createBaseUndoImportRequest();
    message.importId = object.importId ?? "";
    return message;
  },
};

function createBaseUndoImportResponse(): UndoImportResponse {
  return { success: false, message: "", timestamp: "" };
}

export const UndoImportResponse: MessageFns<UndoImportResponse> = {
  encode(message: UndoImportResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    if (message.message !== "") {
      writer.uint32(18).string(message.message);
    }
    if (message.timestamp !== "") {
      writer.uint32(26).string(message.timestamp);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UndoImportResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUndoImportResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.message = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.timestamp = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UndoImportResponse {
    return {
      success: isSet(object.success) ? globalThis.Boolean(object.success) : false,
      message: isSet(object.message) ? globalThis.String(object.message) : "",
      timestamp: isSet(object.timestamp) ? globalThis.String(object.timestamp) : "",
    };
  },

  toJSON(message: UndoImportResponse): unknown {
    const obj: any = {};
    if (message.success !== false) {
      obj.success = message.success;
    }
    if (message.message !== "") {
      obj.message = message.message;
    }
    if (message.timestamp !== "") {
      obj.timestamp = message.timestamp;
    }
    return obj;
  },

  create(base?: DeepPartial<UndoImportResponse>): UndoImportResponse {
    return UndoImportResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<UndoImportResponse>): UndoImportResponse {
    const message = createBaseUndoImportResponse();
    message.success = object.success ?? false;
    message.message = object.message ?? "";
    message.timestamp = object.timestamp ?? "";
    return message;
  },
};

function bytesFromBase64(b64: string): Uint8Array {
  if ((globalThis as any).Buffer) {
    return Uint8Array.from(globalThis.Buffer.from(b64, "base64"));
  } else {
    const bin = globalThis.atob(b64);
    const arr = new Uint8Array(bin.length);
    for (let i = 0; i < bin.length; ++i) {
      arr[i] = bin.charCodeAt(i);
    }
    return arr;
  }
}

function base64FromBytes(arr: Uint8Array): string {
  if ((globalThis as any).Buffer) {
    return globalThis.Buffer.from(arr).toString("base64");
  } else {
    const bin: string[] = [];
    arr.forEach((byte) => {
      bin.push(globalThis.String.fromCharCode(byte));
    });
    return globalThis.btoa(bin.join(""));
  }
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends { $case: string } ? { [K in keyof Omit<T, "$case">]?: DeepPartial<T[K]> } & { $case: T["$case"] }
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function longToNumber(int64: { toString(): string }): number {
  const num = globalThis.Number(int64.toString());
  if (num > globalThis.Number.MAX_SAFE_INTEGER) {
    throw new globalThis.Error("Value is larger than Number.MAX_SAFE_INTEGER");
  }
  if (num < globalThis.Number.MIN_SAFE_INTEGER) {
    throw new globalThis.Error("Value is smaller than Number.MIN_SAFE_INTEGER");
  }
  return num;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
