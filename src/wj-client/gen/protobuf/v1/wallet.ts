// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.11.0
//   protoc               unknown
// source: protobuf/v1/wallet.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import { Money, PaginationParams, PaginationResult } from "./common";

export const protobufPackage = "wealthjourney.wallet.v1";

/** Enums */
export const WalletType = { BASIC: 0, INVESTMENT: 1, UNRECOGNIZED: -1 } as const;

export type WalletType = typeof WalletType[keyof typeof WalletType];

export namespace WalletType {
  export type BASIC = typeof WalletType.BASIC;
  export type INVESTMENT = typeof WalletType.INVESTMENT;
  export type UNRECOGNIZED = typeof WalletType.UNRECOGNIZED;
}

export function walletTypeFromJSON(object: any): WalletType {
  switch (object) {
    case 0:
    case "BASIC":
      return WalletType.BASIC;
    case 1:
    case "INVESTMENT":
      return WalletType.INVESTMENT;
    case -1:
    case "UNRECOGNIZED":
    default:
      return WalletType.UNRECOGNIZED;
  }
}

export function walletTypeToJSON(object: WalletType): string {
  switch (object) {
    case WalletType.BASIC:
      return "BASIC";
    case WalletType.INVESTMENT:
      return "INVESTMENT";
    case WalletType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Wallet message */
export interface Wallet {
  id: number;
  userId: number;
  walletName: string;
  balance: Money | undefined;
  createdAt: number;
  updatedAt: number;
  type: WalletType;
}

/** GetWallet request */
export interface GetWalletRequest {
  walletId: number;
}

/** ListWallets request */
export interface ListWalletsRequest {
  pagination: PaginationParams | undefined;
}

/** WalletListData contains the paginated wallet list data */
export interface WalletListData {
  items: Wallet[];
  pagination: PaginationResult | undefined;
}

/** CreateWallet request */
export interface CreateWalletRequest {
  walletName: string;
  initialBalance: Money | undefined;
  type: WalletType;
}

/** UpdateWallet request */
export interface UpdateWalletRequest {
  walletId: number;
  walletName: string;
}

/** DeleteWallet request */
export interface DeleteWalletRequest {
  walletId: number;
}

/** AddFunds request */
export interface AddFundsRequest {
  walletId: number;
  amount: Money | undefined;
}

/** WithdrawFunds request */
export interface WithdrawFundsRequest {
  walletId: number;
  amount: Money | undefined;
}

/** TransferFunds request */
export interface TransferFundsRequest {
  fromWalletId: number;
  toWalletId: number;
  amount: Money | undefined;
}

/** AdjustBalance request */
export interface AdjustBalanceRequest {
  walletId: number;
  /** Can be positive or negative */
  amount:
    | Money
    | undefined;
  /** Optional: why adjustment was made */
  reason: string;
}

/** GetTotalBalance request */
export interface GetTotalBalanceRequest {
}

/** GetWallet response */
export interface GetWalletResponse {
  success: boolean;
  message: string;
  data: Wallet | undefined;
  timestamp: string;
}

/** ListWallets response */
export interface ListWalletsResponse {
  success: boolean;
  message: string;
  wallets: Wallet[];
  pagination: PaginationResult | undefined;
  timestamp: string;
}

/** CreateWallet response */
export interface CreateWalletResponse {
  success: boolean;
  message: string;
  data: Wallet | undefined;
  timestamp: string;
}

/** UpdateWallet response */
export interface UpdateWalletResponse {
  success: boolean;
  message: string;
  data: Wallet | undefined;
  timestamp: string;
}

/** DeleteWallet response */
export interface DeleteWalletResponse {
  success: boolean;
  message: string;
  timestamp: string;
}

/** AddFunds response */
export interface AddFundsResponse {
  success: boolean;
  message: string;
  data: Wallet | undefined;
  timestamp: string;
}

/** WithdrawFunds response */
export interface WithdrawFundsResponse {
  success: boolean;
  message: string;
  data: Wallet | undefined;
  timestamp: string;
}

/** TransferFunds response */
export interface TransferFundsResponse {
  success: boolean;
  message: string;
  timestamp: string;
}

/** AdjustBalance response */
export interface AdjustBalanceResponse {
  success: boolean;
  message: string;
  /** Updated wallet */
  data: Wallet | undefined;
  timestamp: string;
}

/** GetTotalBalance response */
export interface GetTotalBalanceResponse {
  success: boolean;
  message: string;
  data: Money | undefined;
  timestamp: string;
}

/** GetBalanceHistory request */
export interface GetBalanceHistoryRequest {
  /** Optional, if null returns total balance history */
  walletId: number;
  /** Optional, defaults to current year */
  year: number;
  /** Optional, if provided returns daily data for that month */
  month: number;
}

/** BalanceDataPoint represents a single data point in the balance history */
export interface BalanceDataPoint {
  /** Unix timestamp */
  timestamp: number;
  /** Formatted label (e.g., "Jan", "Jan 15") */
  label: string;
  /** Balance at this point */
  balance: number;
  /** Income in this period */
  income: number;
  /** Expense in this period */
  expense: number;
}

/** GetBalanceHistory response */
export interface GetBalanceHistoryResponse {
  success: boolean;
  message: string;
  data: BalanceDataPoint[];
  timestamp: string;
}

/** GetMonthlyDominance request */
export interface GetMonthlyDominanceRequest {
  /** Optional, defaults to current year */
  year: number;
}

/** WalletMonthlyData contains monthly balance data for a single wallet */
export interface WalletMonthlyData {
  walletId: number;
  walletName: string;
  /** 12 values, one for each month */
  monthlyBalances: number[];
}

/** GetMonthlyDominance response */
export interface GetMonthlyDominanceResponse {
  success: boolean;
  message: string;
  data: WalletMonthlyData[];
  timestamp: string;
}

function createBaseWallet(): Wallet {
  return { id: 0, userId: 0, walletName: "", balance: undefined, createdAt: 0, updatedAt: 0, type: 0 };
}

export const Wallet: MessageFns<Wallet> = {
  encode(message: Wallet, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== 0) {
      writer.uint32(8).int32(message.id);
    }
    if (message.userId !== 0) {
      writer.uint32(16).int32(message.userId);
    }
    if (message.walletName !== "") {
      writer.uint32(26).string(message.walletName);
    }
    if (message.balance !== undefined) {
      Money.encode(message.balance, writer.uint32(34).fork()).join();
    }
    if (message.createdAt !== 0) {
      writer.uint32(40).int64(message.createdAt);
    }
    if (message.updatedAt !== 0) {
      writer.uint32(48).int64(message.updatedAt);
    }
    if (message.type !== 0) {
      writer.uint32(56).int32(message.type);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Wallet {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWallet();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.id = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.userId = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.walletName = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.balance = Money.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.createdAt = longToNumber(reader.int64());
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.updatedAt = longToNumber(reader.int64());
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.type = reader.int32() as any;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Wallet {
    return {
      id: isSet(object.id) ? globalThis.Number(object.id) : 0,
      userId: isSet(object.userId) ? globalThis.Number(object.userId) : 0,
      walletName: isSet(object.walletName) ? globalThis.String(object.walletName) : "",
      balance: isSet(object.balance) ? Money.fromJSON(object.balance) : undefined,
      createdAt: isSet(object.createdAt) ? globalThis.Number(object.createdAt) : 0,
      updatedAt: isSet(object.updatedAt) ? globalThis.Number(object.updatedAt) : 0,
      type: isSet(object.type) ? walletTypeFromJSON(object.type) : 0,
    };
  },

  toJSON(message: Wallet): unknown {
    const obj: any = {};
    if (message.id !== 0) {
      obj.id = Math.round(message.id);
    }
    if (message.userId !== 0) {
      obj.userId = Math.round(message.userId);
    }
    if (message.walletName !== "") {
      obj.walletName = message.walletName;
    }
    if (message.balance !== undefined) {
      obj.balance = Money.toJSON(message.balance);
    }
    if (message.createdAt !== 0) {
      obj.createdAt = Math.round(message.createdAt);
    }
    if (message.updatedAt !== 0) {
      obj.updatedAt = Math.round(message.updatedAt);
    }
    if (message.type !== 0) {
      obj.type = walletTypeToJSON(message.type);
    }
    return obj;
  },

  create(base?: DeepPartial<Wallet>): Wallet {
    return Wallet.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Wallet>): Wallet {
    const message = createBaseWallet();
    message.id = object.id ?? 0;
    message.userId = object.userId ?? 0;
    message.walletName = object.walletName ?? "";
    message.balance = (object.balance !== undefined && object.balance !== null)
      ? Money.fromPartial(object.balance)
      : undefined;
    message.createdAt = object.createdAt ?? 0;
    message.updatedAt = object.updatedAt ?? 0;
    message.type = object.type ?? 0;
    return message;
  },
};

function createBaseGetWalletRequest(): GetWalletRequest {
  return { walletId: 0 };
}

export const GetWalletRequest: MessageFns<GetWalletRequest> = {
  encode(message: GetWalletRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.walletId !== 0) {
      writer.uint32(8).int32(message.walletId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetWalletRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetWalletRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.walletId = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetWalletRequest {
    return { walletId: isSet(object.walletId) ? globalThis.Number(object.walletId) : 0 };
  },

  toJSON(message: GetWalletRequest): unknown {
    const obj: any = {};
    if (message.walletId !== 0) {
      obj.walletId = Math.round(message.walletId);
    }
    return obj;
  },

  create(base?: DeepPartial<GetWalletRequest>): GetWalletRequest {
    return GetWalletRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetWalletRequest>): GetWalletRequest {
    const message = createBaseGetWalletRequest();
    message.walletId = object.walletId ?? 0;
    return message;
  },
};

function createBaseListWalletsRequest(): ListWalletsRequest {
  return { pagination: undefined };
}

export const ListWalletsRequest: MessageFns<ListWalletsRequest> = {
  encode(message: ListWalletsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.pagination !== undefined) {
      PaginationParams.encode(message.pagination, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListWalletsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListWalletsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.pagination = PaginationParams.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListWalletsRequest {
    return { pagination: isSet(object.pagination) ? PaginationParams.fromJSON(object.pagination) : undefined };
  },

  toJSON(message: ListWalletsRequest): unknown {
    const obj: any = {};
    if (message.pagination !== undefined) {
      obj.pagination = PaginationParams.toJSON(message.pagination);
    }
    return obj;
  },

  create(base?: DeepPartial<ListWalletsRequest>): ListWalletsRequest {
    return ListWalletsRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListWalletsRequest>): ListWalletsRequest {
    const message = createBaseListWalletsRequest();
    message.pagination = (object.pagination !== undefined && object.pagination !== null)
      ? PaginationParams.fromPartial(object.pagination)
      : undefined;
    return message;
  },
};

function createBaseWalletListData(): WalletListData {
  return { items: [], pagination: undefined };
}

export const WalletListData: MessageFns<WalletListData> = {
  encode(message: WalletListData, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.items) {
      Wallet.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.pagination !== undefined) {
      PaginationResult.encode(message.pagination, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WalletListData {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWalletListData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.items.push(Wallet.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.pagination = PaginationResult.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): WalletListData {
    return {
      items: globalThis.Array.isArray(object?.items) ? object.items.map((e: any) => Wallet.fromJSON(e)) : [],
      pagination: isSet(object.pagination) ? PaginationResult.fromJSON(object.pagination) : undefined,
    };
  },

  toJSON(message: WalletListData): unknown {
    const obj: any = {};
    if (message.items?.length) {
      obj.items = message.items.map((e) => Wallet.toJSON(e));
    }
    if (message.pagination !== undefined) {
      obj.pagination = PaginationResult.toJSON(message.pagination);
    }
    return obj;
  },

  create(base?: DeepPartial<WalletListData>): WalletListData {
    return WalletListData.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<WalletListData>): WalletListData {
    const message = createBaseWalletListData();
    message.items = object.items?.map((e) => Wallet.fromPartial(e)) || [];
    message.pagination = (object.pagination !== undefined && object.pagination !== null)
      ? PaginationResult.fromPartial(object.pagination)
      : undefined;
    return message;
  },
};

function createBaseCreateWalletRequest(): CreateWalletRequest {
  return { walletName: "", initialBalance: undefined, type: 0 };
}

export const CreateWalletRequest: MessageFns<CreateWalletRequest> = {
  encode(message: CreateWalletRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.walletName !== "") {
      writer.uint32(10).string(message.walletName);
    }
    if (message.initialBalance !== undefined) {
      Money.encode(message.initialBalance, writer.uint32(18).fork()).join();
    }
    if (message.type !== 0) {
      writer.uint32(24).int32(message.type);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateWalletRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateWalletRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.walletName = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.initialBalance = Money.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.type = reader.int32() as any;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateWalletRequest {
    return {
      walletName: isSet(object.walletName) ? globalThis.String(object.walletName) : "",
      initialBalance: isSet(object.initialBalance) ? Money.fromJSON(object.initialBalance) : undefined,
      type: isSet(object.type) ? walletTypeFromJSON(object.type) : 0,
    };
  },

  toJSON(message: CreateWalletRequest): unknown {
    const obj: any = {};
    if (message.walletName !== "") {
      obj.walletName = message.walletName;
    }
    if (message.initialBalance !== undefined) {
      obj.initialBalance = Money.toJSON(message.initialBalance);
    }
    if (message.type !== 0) {
      obj.type = walletTypeToJSON(message.type);
    }
    return obj;
  },

  create(base?: DeepPartial<CreateWalletRequest>): CreateWalletRequest {
    return CreateWalletRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CreateWalletRequest>): CreateWalletRequest {
    const message = createBaseCreateWalletRequest();
    message.walletName = object.walletName ?? "";
    message.initialBalance = (object.initialBalance !== undefined && object.initialBalance !== null)
      ? Money.fromPartial(object.initialBalance)
      : undefined;
    message.type = object.type ?? 0;
    return message;
  },
};

function createBaseUpdateWalletRequest(): UpdateWalletRequest {
  return { walletId: 0, walletName: "" };
}

export const UpdateWalletRequest: MessageFns<UpdateWalletRequest> = {
  encode(message: UpdateWalletRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.walletId !== 0) {
      writer.uint32(8).int32(message.walletId);
    }
    if (message.walletName !== "") {
      writer.uint32(18).string(message.walletName);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdateWalletRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateWalletRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.walletId = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.walletName = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateWalletRequest {
    return {
      walletId: isSet(object.walletId) ? globalThis.Number(object.walletId) : 0,
      walletName: isSet(object.walletName) ? globalThis.String(object.walletName) : "",
    };
  },

  toJSON(message: UpdateWalletRequest): unknown {
    const obj: any = {};
    if (message.walletId !== 0) {
      obj.walletId = Math.round(message.walletId);
    }
    if (message.walletName !== "") {
      obj.walletName = message.walletName;
    }
    return obj;
  },

  create(base?: DeepPartial<UpdateWalletRequest>): UpdateWalletRequest {
    return UpdateWalletRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<UpdateWalletRequest>): UpdateWalletRequest {
    const message = createBaseUpdateWalletRequest();
    message.walletId = object.walletId ?? 0;
    message.walletName = object.walletName ?? "";
    return message;
  },
};

function createBaseDeleteWalletRequest(): DeleteWalletRequest {
  return { walletId: 0 };
}

export const DeleteWalletRequest: MessageFns<DeleteWalletRequest> = {
  encode(message: DeleteWalletRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.walletId !== 0) {
      writer.uint32(8).int32(message.walletId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteWalletRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteWalletRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.walletId = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeleteWalletRequest {
    return { walletId: isSet(object.walletId) ? globalThis.Number(object.walletId) : 0 };
  },

  toJSON(message: DeleteWalletRequest): unknown {
    const obj: any = {};
    if (message.walletId !== 0) {
      obj.walletId = Math.round(message.walletId);
    }
    return obj;
  },

  create(base?: DeepPartial<DeleteWalletRequest>): DeleteWalletRequest {
    return DeleteWalletRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DeleteWalletRequest>): DeleteWalletRequest {
    const message = createBaseDeleteWalletRequest();
    message.walletId = object.walletId ?? 0;
    return message;
  },
};

function createBaseAddFundsRequest(): AddFundsRequest {
  return { walletId: 0, amount: undefined };
}

export const AddFundsRequest: MessageFns<AddFundsRequest> = {
  encode(message: AddFundsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.walletId !== 0) {
      writer.uint32(8).int32(message.walletId);
    }
    if (message.amount !== undefined) {
      Money.encode(message.amount, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AddFundsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAddFundsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.walletId = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.amount = Money.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AddFundsRequest {
    return {
      walletId: isSet(object.walletId) ? globalThis.Number(object.walletId) : 0,
      amount: isSet(object.amount) ? Money.fromJSON(object.amount) : undefined,
    };
  },

  toJSON(message: AddFundsRequest): unknown {
    const obj: any = {};
    if (message.walletId !== 0) {
      obj.walletId = Math.round(message.walletId);
    }
    if (message.amount !== undefined) {
      obj.amount = Money.toJSON(message.amount);
    }
    return obj;
  },

  create(base?: DeepPartial<AddFundsRequest>): AddFundsRequest {
    return AddFundsRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AddFundsRequest>): AddFundsRequest {
    const message = createBaseAddFundsRequest();
    message.walletId = object.walletId ?? 0;
    message.amount = (object.amount !== undefined && object.amount !== null)
      ? Money.fromPartial(object.amount)
      : undefined;
    return message;
  },
};

function createBaseWithdrawFundsRequest(): WithdrawFundsRequest {
  return { walletId: 0, amount: undefined };
}

export const WithdrawFundsRequest: MessageFns<WithdrawFundsRequest> = {
  encode(message: WithdrawFundsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.walletId !== 0) {
      writer.uint32(8).int32(message.walletId);
    }
    if (message.amount !== undefined) {
      Money.encode(message.amount, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WithdrawFundsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWithdrawFundsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.walletId = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.amount = Money.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): WithdrawFundsRequest {
    return {
      walletId: isSet(object.walletId) ? globalThis.Number(object.walletId) : 0,
      amount: isSet(object.amount) ? Money.fromJSON(object.amount) : undefined,
    };
  },

  toJSON(message: WithdrawFundsRequest): unknown {
    const obj: any = {};
    if (message.walletId !== 0) {
      obj.walletId = Math.round(message.walletId);
    }
    if (message.amount !== undefined) {
      obj.amount = Money.toJSON(message.amount);
    }
    return obj;
  },

  create(base?: DeepPartial<WithdrawFundsRequest>): WithdrawFundsRequest {
    return WithdrawFundsRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<WithdrawFundsRequest>): WithdrawFundsRequest {
    const message = createBaseWithdrawFundsRequest();
    message.walletId = object.walletId ?? 0;
    message.amount = (object.amount !== undefined && object.amount !== null)
      ? Money.fromPartial(object.amount)
      : undefined;
    return message;
  },
};

function createBaseTransferFundsRequest(): TransferFundsRequest {
  return { fromWalletId: 0, toWalletId: 0, amount: undefined };
}

export const TransferFundsRequest: MessageFns<TransferFundsRequest> = {
  encode(message: TransferFundsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.fromWalletId !== 0) {
      writer.uint32(8).int32(message.fromWalletId);
    }
    if (message.toWalletId !== 0) {
      writer.uint32(16).int32(message.toWalletId);
    }
    if (message.amount !== undefined) {
      Money.encode(message.amount, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TransferFundsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTransferFundsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.fromWalletId = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.toWalletId = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.amount = Money.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TransferFundsRequest {
    return {
      fromWalletId: isSet(object.fromWalletId) ? globalThis.Number(object.fromWalletId) : 0,
      toWalletId: isSet(object.toWalletId) ? globalThis.Number(object.toWalletId) : 0,
      amount: isSet(object.amount) ? Money.fromJSON(object.amount) : undefined,
    };
  },

  toJSON(message: TransferFundsRequest): unknown {
    const obj: any = {};
    if (message.fromWalletId !== 0) {
      obj.fromWalletId = Math.round(message.fromWalletId);
    }
    if (message.toWalletId !== 0) {
      obj.toWalletId = Math.round(message.toWalletId);
    }
    if (message.amount !== undefined) {
      obj.amount = Money.toJSON(message.amount);
    }
    return obj;
  },

  create(base?: DeepPartial<TransferFundsRequest>): TransferFundsRequest {
    return TransferFundsRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TransferFundsRequest>): TransferFundsRequest {
    const message = createBaseTransferFundsRequest();
    message.fromWalletId = object.fromWalletId ?? 0;
    message.toWalletId = object.toWalletId ?? 0;
    message.amount = (object.amount !== undefined && object.amount !== null)
      ? Money.fromPartial(object.amount)
      : undefined;
    return message;
  },
};

function createBaseAdjustBalanceRequest(): AdjustBalanceRequest {
  return { walletId: 0, amount: undefined, reason: "" };
}

export const AdjustBalanceRequest: MessageFns<AdjustBalanceRequest> = {
  encode(message: AdjustBalanceRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.walletId !== 0) {
      writer.uint32(8).int32(message.walletId);
    }
    if (message.amount !== undefined) {
      Money.encode(message.amount, writer.uint32(18).fork()).join();
    }
    if (message.reason !== "") {
      writer.uint32(26).string(message.reason);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AdjustBalanceRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAdjustBalanceRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.walletId = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.amount = Money.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.reason = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AdjustBalanceRequest {
    return {
      walletId: isSet(object.walletId) ? globalThis.Number(object.walletId) : 0,
      amount: isSet(object.amount) ? Money.fromJSON(object.amount) : undefined,
      reason: isSet(object.reason) ? globalThis.String(object.reason) : "",
    };
  },

  toJSON(message: AdjustBalanceRequest): unknown {
    const obj: any = {};
    if (message.walletId !== 0) {
      obj.walletId = Math.round(message.walletId);
    }
    if (message.amount !== undefined) {
      obj.amount = Money.toJSON(message.amount);
    }
    if (message.reason !== "") {
      obj.reason = message.reason;
    }
    return obj;
  },

  create(base?: DeepPartial<AdjustBalanceRequest>): AdjustBalanceRequest {
    return AdjustBalanceRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AdjustBalanceRequest>): AdjustBalanceRequest {
    const message = createBaseAdjustBalanceRequest();
    message.walletId = object.walletId ?? 0;
    message.amount = (object.amount !== undefined && object.amount !== null)
      ? Money.fromPartial(object.amount)
      : undefined;
    message.reason = object.reason ?? "";
    return message;
  },
};

function createBaseGetTotalBalanceRequest(): GetTotalBalanceRequest {
  return {};
}

export const GetTotalBalanceRequest: MessageFns<GetTotalBalanceRequest> = {
  encode(_: GetTotalBalanceRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetTotalBalanceRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetTotalBalanceRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): GetTotalBalanceRequest {
    return {};
  },

  toJSON(_: GetTotalBalanceRequest): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<GetTotalBalanceRequest>): GetTotalBalanceRequest {
    return GetTotalBalanceRequest.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<GetTotalBalanceRequest>): GetTotalBalanceRequest {
    const message = createBaseGetTotalBalanceRequest();
    return message;
  },
};

function createBaseGetWalletResponse(): GetWalletResponse {
  return { success: false, message: "", data: undefined, timestamp: "" };
}

export const GetWalletResponse: MessageFns<GetWalletResponse> = {
  encode(message: GetWalletResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    if (message.message !== "") {
      writer.uint32(18).string(message.message);
    }
    if (message.data !== undefined) {
      Wallet.encode(message.data, writer.uint32(26).fork()).join();
    }
    if (message.timestamp !== "") {
      writer.uint32(34).string(message.timestamp);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetWalletResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetWalletResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.message = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.data = Wallet.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.timestamp = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetWalletResponse {
    return {
      success: isSet(object.success) ? globalThis.Boolean(object.success) : false,
      message: isSet(object.message) ? globalThis.String(object.message) : "",
      data: isSet(object.data) ? Wallet.fromJSON(object.data) : undefined,
      timestamp: isSet(object.timestamp) ? globalThis.String(object.timestamp) : "",
    };
  },

  toJSON(message: GetWalletResponse): unknown {
    const obj: any = {};
    if (message.success !== false) {
      obj.success = message.success;
    }
    if (message.message !== "") {
      obj.message = message.message;
    }
    if (message.data !== undefined) {
      obj.data = Wallet.toJSON(message.data);
    }
    if (message.timestamp !== "") {
      obj.timestamp = message.timestamp;
    }
    return obj;
  },

  create(base?: DeepPartial<GetWalletResponse>): GetWalletResponse {
    return GetWalletResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetWalletResponse>): GetWalletResponse {
    const message = createBaseGetWalletResponse();
    message.success = object.success ?? false;
    message.message = object.message ?? "";
    message.data = (object.data !== undefined && object.data !== null) ? Wallet.fromPartial(object.data) : undefined;
    message.timestamp = object.timestamp ?? "";
    return message;
  },
};

function createBaseListWalletsResponse(): ListWalletsResponse {
  return { success: false, message: "", wallets: [], pagination: undefined, timestamp: "" };
}

export const ListWalletsResponse: MessageFns<ListWalletsResponse> = {
  encode(message: ListWalletsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    if (message.message !== "") {
      writer.uint32(18).string(message.message);
    }
    for (const v of message.wallets) {
      Wallet.encode(v!, writer.uint32(26).fork()).join();
    }
    if (message.pagination !== undefined) {
      PaginationResult.encode(message.pagination, writer.uint32(34).fork()).join();
    }
    if (message.timestamp !== "") {
      writer.uint32(42).string(message.timestamp);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListWalletsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListWalletsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.message = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.wallets.push(Wallet.decode(reader, reader.uint32()));
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.pagination = PaginationResult.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.timestamp = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListWalletsResponse {
    return {
      success: isSet(object.success) ? globalThis.Boolean(object.success) : false,
      message: isSet(object.message) ? globalThis.String(object.message) : "",
      wallets: globalThis.Array.isArray(object?.wallets) ? object.wallets.map((e: any) => Wallet.fromJSON(e)) : [],
      pagination: isSet(object.pagination) ? PaginationResult.fromJSON(object.pagination) : undefined,
      timestamp: isSet(object.timestamp) ? globalThis.String(object.timestamp) : "",
    };
  },

  toJSON(message: ListWalletsResponse): unknown {
    const obj: any = {};
    if (message.success !== false) {
      obj.success = message.success;
    }
    if (message.message !== "") {
      obj.message = message.message;
    }
    if (message.wallets?.length) {
      obj.wallets = message.wallets.map((e) => Wallet.toJSON(e));
    }
    if (message.pagination !== undefined) {
      obj.pagination = PaginationResult.toJSON(message.pagination);
    }
    if (message.timestamp !== "") {
      obj.timestamp = message.timestamp;
    }
    return obj;
  },

  create(base?: DeepPartial<ListWalletsResponse>): ListWalletsResponse {
    return ListWalletsResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListWalletsResponse>): ListWalletsResponse {
    const message = createBaseListWalletsResponse();
    message.success = object.success ?? false;
    message.message = object.message ?? "";
    message.wallets = object.wallets?.map((e) => Wallet.fromPartial(e)) || [];
    message.pagination = (object.pagination !== undefined && object.pagination !== null)
      ? PaginationResult.fromPartial(object.pagination)
      : undefined;
    message.timestamp = object.timestamp ?? "";
    return message;
  },
};

function createBaseCreateWalletResponse(): CreateWalletResponse {
  return { success: false, message: "", data: undefined, timestamp: "" };
}

export const CreateWalletResponse: MessageFns<CreateWalletResponse> = {
  encode(message: CreateWalletResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    if (message.message !== "") {
      writer.uint32(18).string(message.message);
    }
    if (message.data !== undefined) {
      Wallet.encode(message.data, writer.uint32(26).fork()).join();
    }
    if (message.timestamp !== "") {
      writer.uint32(34).string(message.timestamp);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateWalletResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateWalletResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.message = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.data = Wallet.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.timestamp = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateWalletResponse {
    return {
      success: isSet(object.success) ? globalThis.Boolean(object.success) : false,
      message: isSet(object.message) ? globalThis.String(object.message) : "",
      data: isSet(object.data) ? Wallet.fromJSON(object.data) : undefined,
      timestamp: isSet(object.timestamp) ? globalThis.String(object.timestamp) : "",
    };
  },

  toJSON(message: CreateWalletResponse): unknown {
    const obj: any = {};
    if (message.success !== false) {
      obj.success = message.success;
    }
    if (message.message !== "") {
      obj.message = message.message;
    }
    if (message.data !== undefined) {
      obj.data = Wallet.toJSON(message.data);
    }
    if (message.timestamp !== "") {
      obj.timestamp = message.timestamp;
    }
    return obj;
  },

  create(base?: DeepPartial<CreateWalletResponse>): CreateWalletResponse {
    return CreateWalletResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CreateWalletResponse>): CreateWalletResponse {
    const message = createBaseCreateWalletResponse();
    message.success = object.success ?? false;
    message.message = object.message ?? "";
    message.data = (object.data !== undefined && object.data !== null) ? Wallet.fromPartial(object.data) : undefined;
    message.timestamp = object.timestamp ?? "";
    return message;
  },
};

function createBaseUpdateWalletResponse(): UpdateWalletResponse {
  return { success: false, message: "", data: undefined, timestamp: "" };
}

export const UpdateWalletResponse: MessageFns<UpdateWalletResponse> = {
  encode(message: UpdateWalletResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    if (message.message !== "") {
      writer.uint32(18).string(message.message);
    }
    if (message.data !== undefined) {
      Wallet.encode(message.data, writer.uint32(26).fork()).join();
    }
    if (message.timestamp !== "") {
      writer.uint32(34).string(message.timestamp);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdateWalletResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateWalletResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.message = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.data = Wallet.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.timestamp = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateWalletResponse {
    return {
      success: isSet(object.success) ? globalThis.Boolean(object.success) : false,
      message: isSet(object.message) ? globalThis.String(object.message) : "",
      data: isSet(object.data) ? Wallet.fromJSON(object.data) : undefined,
      timestamp: isSet(object.timestamp) ? globalThis.String(object.timestamp) : "",
    };
  },

  toJSON(message: UpdateWalletResponse): unknown {
    const obj: any = {};
    if (message.success !== false) {
      obj.success = message.success;
    }
    if (message.message !== "") {
      obj.message = message.message;
    }
    if (message.data !== undefined) {
      obj.data = Wallet.toJSON(message.data);
    }
    if (message.timestamp !== "") {
      obj.timestamp = message.timestamp;
    }
    return obj;
  },

  create(base?: DeepPartial<UpdateWalletResponse>): UpdateWalletResponse {
    return UpdateWalletResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<UpdateWalletResponse>): UpdateWalletResponse {
    const message = createBaseUpdateWalletResponse();
    message.success = object.success ?? false;
    message.message = object.message ?? "";
    message.data = (object.data !== undefined && object.data !== null) ? Wallet.fromPartial(object.data) : undefined;
    message.timestamp = object.timestamp ?? "";
    return message;
  },
};

function createBaseDeleteWalletResponse(): DeleteWalletResponse {
  return { success: false, message: "", timestamp: "" };
}

export const DeleteWalletResponse: MessageFns<DeleteWalletResponse> = {
  encode(message: DeleteWalletResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    if (message.message !== "") {
      writer.uint32(18).string(message.message);
    }
    if (message.timestamp !== "") {
      writer.uint32(26).string(message.timestamp);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteWalletResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteWalletResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.message = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.timestamp = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeleteWalletResponse {
    return {
      success: isSet(object.success) ? globalThis.Boolean(object.success) : false,
      message: isSet(object.message) ? globalThis.String(object.message) : "",
      timestamp: isSet(object.timestamp) ? globalThis.String(object.timestamp) : "",
    };
  },

  toJSON(message: DeleteWalletResponse): unknown {
    const obj: any = {};
    if (message.success !== false) {
      obj.success = message.success;
    }
    if (message.message !== "") {
      obj.message = message.message;
    }
    if (message.timestamp !== "") {
      obj.timestamp = message.timestamp;
    }
    return obj;
  },

  create(base?: DeepPartial<DeleteWalletResponse>): DeleteWalletResponse {
    return DeleteWalletResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DeleteWalletResponse>): DeleteWalletResponse {
    const message = createBaseDeleteWalletResponse();
    message.success = object.success ?? false;
    message.message = object.message ?? "";
    message.timestamp = object.timestamp ?? "";
    return message;
  },
};

function createBaseAddFundsResponse(): AddFundsResponse {
  return { success: false, message: "", data: undefined, timestamp: "" };
}

export const AddFundsResponse: MessageFns<AddFundsResponse> = {
  encode(message: AddFundsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    if (message.message !== "") {
      writer.uint32(18).string(message.message);
    }
    if (message.data !== undefined) {
      Wallet.encode(message.data, writer.uint32(26).fork()).join();
    }
    if (message.timestamp !== "") {
      writer.uint32(34).string(message.timestamp);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AddFundsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAddFundsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.message = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.data = Wallet.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.timestamp = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AddFundsResponse {
    return {
      success: isSet(object.success) ? globalThis.Boolean(object.success) : false,
      message: isSet(object.message) ? globalThis.String(object.message) : "",
      data: isSet(object.data) ? Wallet.fromJSON(object.data) : undefined,
      timestamp: isSet(object.timestamp) ? globalThis.String(object.timestamp) : "",
    };
  },

  toJSON(message: AddFundsResponse): unknown {
    const obj: any = {};
    if (message.success !== false) {
      obj.success = message.success;
    }
    if (message.message !== "") {
      obj.message = message.message;
    }
    if (message.data !== undefined) {
      obj.data = Wallet.toJSON(message.data);
    }
    if (message.timestamp !== "") {
      obj.timestamp = message.timestamp;
    }
    return obj;
  },

  create(base?: DeepPartial<AddFundsResponse>): AddFundsResponse {
    return AddFundsResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AddFundsResponse>): AddFundsResponse {
    const message = createBaseAddFundsResponse();
    message.success = object.success ?? false;
    message.message = object.message ?? "";
    message.data = (object.data !== undefined && object.data !== null) ? Wallet.fromPartial(object.data) : undefined;
    message.timestamp = object.timestamp ?? "";
    return message;
  },
};

function createBaseWithdrawFundsResponse(): WithdrawFundsResponse {
  return { success: false, message: "", data: undefined, timestamp: "" };
}

export const WithdrawFundsResponse: MessageFns<WithdrawFundsResponse> = {
  encode(message: WithdrawFundsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    if (message.message !== "") {
      writer.uint32(18).string(message.message);
    }
    if (message.data !== undefined) {
      Wallet.encode(message.data, writer.uint32(26).fork()).join();
    }
    if (message.timestamp !== "") {
      writer.uint32(34).string(message.timestamp);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WithdrawFundsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWithdrawFundsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.message = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.data = Wallet.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.timestamp = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): WithdrawFundsResponse {
    return {
      success: isSet(object.success) ? globalThis.Boolean(object.success) : false,
      message: isSet(object.message) ? globalThis.String(object.message) : "",
      data: isSet(object.data) ? Wallet.fromJSON(object.data) : undefined,
      timestamp: isSet(object.timestamp) ? globalThis.String(object.timestamp) : "",
    };
  },

  toJSON(message: WithdrawFundsResponse): unknown {
    const obj: any = {};
    if (message.success !== false) {
      obj.success = message.success;
    }
    if (message.message !== "") {
      obj.message = message.message;
    }
    if (message.data !== undefined) {
      obj.data = Wallet.toJSON(message.data);
    }
    if (message.timestamp !== "") {
      obj.timestamp = message.timestamp;
    }
    return obj;
  },

  create(base?: DeepPartial<WithdrawFundsResponse>): WithdrawFundsResponse {
    return WithdrawFundsResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<WithdrawFundsResponse>): WithdrawFundsResponse {
    const message = createBaseWithdrawFundsResponse();
    message.success = object.success ?? false;
    message.message = object.message ?? "";
    message.data = (object.data !== undefined && object.data !== null) ? Wallet.fromPartial(object.data) : undefined;
    message.timestamp = object.timestamp ?? "";
    return message;
  },
};

function createBaseTransferFundsResponse(): TransferFundsResponse {
  return { success: false, message: "", timestamp: "" };
}

export const TransferFundsResponse: MessageFns<TransferFundsResponse> = {
  encode(message: TransferFundsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    if (message.message !== "") {
      writer.uint32(18).string(message.message);
    }
    if (message.timestamp !== "") {
      writer.uint32(26).string(message.timestamp);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TransferFundsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTransferFundsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.message = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.timestamp = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TransferFundsResponse {
    return {
      success: isSet(object.success) ? globalThis.Boolean(object.success) : false,
      message: isSet(object.message) ? globalThis.String(object.message) : "",
      timestamp: isSet(object.timestamp) ? globalThis.String(object.timestamp) : "",
    };
  },

  toJSON(message: TransferFundsResponse): unknown {
    const obj: any = {};
    if (message.success !== false) {
      obj.success = message.success;
    }
    if (message.message !== "") {
      obj.message = message.message;
    }
    if (message.timestamp !== "") {
      obj.timestamp = message.timestamp;
    }
    return obj;
  },

  create(base?: DeepPartial<TransferFundsResponse>): TransferFundsResponse {
    return TransferFundsResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TransferFundsResponse>): TransferFundsResponse {
    const message = createBaseTransferFundsResponse();
    message.success = object.success ?? false;
    message.message = object.message ?? "";
    message.timestamp = object.timestamp ?? "";
    return message;
  },
};

function createBaseAdjustBalanceResponse(): AdjustBalanceResponse {
  return { success: false, message: "", data: undefined, timestamp: "" };
}

export const AdjustBalanceResponse: MessageFns<AdjustBalanceResponse> = {
  encode(message: AdjustBalanceResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    if (message.message !== "") {
      writer.uint32(18).string(message.message);
    }
    if (message.data !== undefined) {
      Wallet.encode(message.data, writer.uint32(26).fork()).join();
    }
    if (message.timestamp !== "") {
      writer.uint32(34).string(message.timestamp);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AdjustBalanceResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAdjustBalanceResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.message = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.data = Wallet.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.timestamp = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AdjustBalanceResponse {
    return {
      success: isSet(object.success) ? globalThis.Boolean(object.success) : false,
      message: isSet(object.message) ? globalThis.String(object.message) : "",
      data: isSet(object.data) ? Wallet.fromJSON(object.data) : undefined,
      timestamp: isSet(object.timestamp) ? globalThis.String(object.timestamp) : "",
    };
  },

  toJSON(message: AdjustBalanceResponse): unknown {
    const obj: any = {};
    if (message.success !== false) {
      obj.success = message.success;
    }
    if (message.message !== "") {
      obj.message = message.message;
    }
    if (message.data !== undefined) {
      obj.data = Wallet.toJSON(message.data);
    }
    if (message.timestamp !== "") {
      obj.timestamp = message.timestamp;
    }
    return obj;
  },

  create(base?: DeepPartial<AdjustBalanceResponse>): AdjustBalanceResponse {
    return AdjustBalanceResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AdjustBalanceResponse>): AdjustBalanceResponse {
    const message = createBaseAdjustBalanceResponse();
    message.success = object.success ?? false;
    message.message = object.message ?? "";
    message.data = (object.data !== undefined && object.data !== null) ? Wallet.fromPartial(object.data) : undefined;
    message.timestamp = object.timestamp ?? "";
    return message;
  },
};

function createBaseGetTotalBalanceResponse(): GetTotalBalanceResponse {
  return { success: false, message: "", data: undefined, timestamp: "" };
}

export const GetTotalBalanceResponse: MessageFns<GetTotalBalanceResponse> = {
  encode(message: GetTotalBalanceResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    if (message.message !== "") {
      writer.uint32(18).string(message.message);
    }
    if (message.data !== undefined) {
      Money.encode(message.data, writer.uint32(26).fork()).join();
    }
    if (message.timestamp !== "") {
      writer.uint32(34).string(message.timestamp);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetTotalBalanceResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetTotalBalanceResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.message = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.data = Money.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.timestamp = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetTotalBalanceResponse {
    return {
      success: isSet(object.success) ? globalThis.Boolean(object.success) : false,
      message: isSet(object.message) ? globalThis.String(object.message) : "",
      data: isSet(object.data) ? Money.fromJSON(object.data) : undefined,
      timestamp: isSet(object.timestamp) ? globalThis.String(object.timestamp) : "",
    };
  },

  toJSON(message: GetTotalBalanceResponse): unknown {
    const obj: any = {};
    if (message.success !== false) {
      obj.success = message.success;
    }
    if (message.message !== "") {
      obj.message = message.message;
    }
    if (message.data !== undefined) {
      obj.data = Money.toJSON(message.data);
    }
    if (message.timestamp !== "") {
      obj.timestamp = message.timestamp;
    }
    return obj;
  },

  create(base?: DeepPartial<GetTotalBalanceResponse>): GetTotalBalanceResponse {
    return GetTotalBalanceResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetTotalBalanceResponse>): GetTotalBalanceResponse {
    const message = createBaseGetTotalBalanceResponse();
    message.success = object.success ?? false;
    message.message = object.message ?? "";
    message.data = (object.data !== undefined && object.data !== null) ? Money.fromPartial(object.data) : undefined;
    message.timestamp = object.timestamp ?? "";
    return message;
  },
};

function createBaseGetBalanceHistoryRequest(): GetBalanceHistoryRequest {
  return { walletId: 0, year: 0, month: 0 };
}

export const GetBalanceHistoryRequest: MessageFns<GetBalanceHistoryRequest> = {
  encode(message: GetBalanceHistoryRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.walletId !== 0) {
      writer.uint32(8).int32(message.walletId);
    }
    if (message.year !== 0) {
      writer.uint32(16).int32(message.year);
    }
    if (message.month !== 0) {
      writer.uint32(24).int32(message.month);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetBalanceHistoryRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetBalanceHistoryRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.walletId = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.year = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.month = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetBalanceHistoryRequest {
    return {
      walletId: isSet(object.walletId) ? globalThis.Number(object.walletId) : 0,
      year: isSet(object.year) ? globalThis.Number(object.year) : 0,
      month: isSet(object.month) ? globalThis.Number(object.month) : 0,
    };
  },

  toJSON(message: GetBalanceHistoryRequest): unknown {
    const obj: any = {};
    if (message.walletId !== 0) {
      obj.walletId = Math.round(message.walletId);
    }
    if (message.year !== 0) {
      obj.year = Math.round(message.year);
    }
    if (message.month !== 0) {
      obj.month = Math.round(message.month);
    }
    return obj;
  },

  create(base?: DeepPartial<GetBalanceHistoryRequest>): GetBalanceHistoryRequest {
    return GetBalanceHistoryRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetBalanceHistoryRequest>): GetBalanceHistoryRequest {
    const message = createBaseGetBalanceHistoryRequest();
    message.walletId = object.walletId ?? 0;
    message.year = object.year ?? 0;
    message.month = object.month ?? 0;
    return message;
  },
};

function createBaseBalanceDataPoint(): BalanceDataPoint {
  return { timestamp: 0, label: "", balance: 0, income: 0, expense: 0 };
}

export const BalanceDataPoint: MessageFns<BalanceDataPoint> = {
  encode(message: BalanceDataPoint, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.timestamp !== 0) {
      writer.uint32(8).int64(message.timestamp);
    }
    if (message.label !== "") {
      writer.uint32(18).string(message.label);
    }
    if (message.balance !== 0) {
      writer.uint32(24).int64(message.balance);
    }
    if (message.income !== 0) {
      writer.uint32(32).int64(message.income);
    }
    if (message.expense !== 0) {
      writer.uint32(40).int64(message.expense);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BalanceDataPoint {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBalanceDataPoint();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.timestamp = longToNumber(reader.int64());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.label = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.balance = longToNumber(reader.int64());
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.income = longToNumber(reader.int64());
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.expense = longToNumber(reader.int64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BalanceDataPoint {
    return {
      timestamp: isSet(object.timestamp) ? globalThis.Number(object.timestamp) : 0,
      label: isSet(object.label) ? globalThis.String(object.label) : "",
      balance: isSet(object.balance) ? globalThis.Number(object.balance) : 0,
      income: isSet(object.income) ? globalThis.Number(object.income) : 0,
      expense: isSet(object.expense) ? globalThis.Number(object.expense) : 0,
    };
  },

  toJSON(message: BalanceDataPoint): unknown {
    const obj: any = {};
    if (message.timestamp !== 0) {
      obj.timestamp = Math.round(message.timestamp);
    }
    if (message.label !== "") {
      obj.label = message.label;
    }
    if (message.balance !== 0) {
      obj.balance = Math.round(message.balance);
    }
    if (message.income !== 0) {
      obj.income = Math.round(message.income);
    }
    if (message.expense !== 0) {
      obj.expense = Math.round(message.expense);
    }
    return obj;
  },

  create(base?: DeepPartial<BalanceDataPoint>): BalanceDataPoint {
    return BalanceDataPoint.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<BalanceDataPoint>): BalanceDataPoint {
    const message = createBaseBalanceDataPoint();
    message.timestamp = object.timestamp ?? 0;
    message.label = object.label ?? "";
    message.balance = object.balance ?? 0;
    message.income = object.income ?? 0;
    message.expense = object.expense ?? 0;
    return message;
  },
};

function createBaseGetBalanceHistoryResponse(): GetBalanceHistoryResponse {
  return { success: false, message: "", data: [], timestamp: "" };
}

export const GetBalanceHistoryResponse: MessageFns<GetBalanceHistoryResponse> = {
  encode(message: GetBalanceHistoryResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    if (message.message !== "") {
      writer.uint32(18).string(message.message);
    }
    for (const v of message.data) {
      BalanceDataPoint.encode(v!, writer.uint32(26).fork()).join();
    }
    if (message.timestamp !== "") {
      writer.uint32(34).string(message.timestamp);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetBalanceHistoryResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetBalanceHistoryResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.message = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.data.push(BalanceDataPoint.decode(reader, reader.uint32()));
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.timestamp = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetBalanceHistoryResponse {
    return {
      success: isSet(object.success) ? globalThis.Boolean(object.success) : false,
      message: isSet(object.message) ? globalThis.String(object.message) : "",
      data: globalThis.Array.isArray(object?.data) ? object.data.map((e: any) => BalanceDataPoint.fromJSON(e)) : [],
      timestamp: isSet(object.timestamp) ? globalThis.String(object.timestamp) : "",
    };
  },

  toJSON(message: GetBalanceHistoryResponse): unknown {
    const obj: any = {};
    if (message.success !== false) {
      obj.success = message.success;
    }
    if (message.message !== "") {
      obj.message = message.message;
    }
    if (message.data?.length) {
      obj.data = message.data.map((e) => BalanceDataPoint.toJSON(e));
    }
    if (message.timestamp !== "") {
      obj.timestamp = message.timestamp;
    }
    return obj;
  },

  create(base?: DeepPartial<GetBalanceHistoryResponse>): GetBalanceHistoryResponse {
    return GetBalanceHistoryResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetBalanceHistoryResponse>): GetBalanceHistoryResponse {
    const message = createBaseGetBalanceHistoryResponse();
    message.success = object.success ?? false;
    message.message = object.message ?? "";
    message.data = object.data?.map((e) => BalanceDataPoint.fromPartial(e)) || [];
    message.timestamp = object.timestamp ?? "";
    return message;
  },
};

function createBaseGetMonthlyDominanceRequest(): GetMonthlyDominanceRequest {
  return { year: 0 };
}

export const GetMonthlyDominanceRequest: MessageFns<GetMonthlyDominanceRequest> = {
  encode(message: GetMonthlyDominanceRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.year !== 0) {
      writer.uint32(8).int32(message.year);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetMonthlyDominanceRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetMonthlyDominanceRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.year = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetMonthlyDominanceRequest {
    return { year: isSet(object.year) ? globalThis.Number(object.year) : 0 };
  },

  toJSON(message: GetMonthlyDominanceRequest): unknown {
    const obj: any = {};
    if (message.year !== 0) {
      obj.year = Math.round(message.year);
    }
    return obj;
  },

  create(base?: DeepPartial<GetMonthlyDominanceRequest>): GetMonthlyDominanceRequest {
    return GetMonthlyDominanceRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetMonthlyDominanceRequest>): GetMonthlyDominanceRequest {
    const message = createBaseGetMonthlyDominanceRequest();
    message.year = object.year ?? 0;
    return message;
  },
};

function createBaseWalletMonthlyData(): WalletMonthlyData {
  return { walletId: 0, walletName: "", monthlyBalances: [] };
}

export const WalletMonthlyData: MessageFns<WalletMonthlyData> = {
  encode(message: WalletMonthlyData, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.walletId !== 0) {
      writer.uint32(8).int32(message.walletId);
    }
    if (message.walletName !== "") {
      writer.uint32(18).string(message.walletName);
    }
    writer.uint32(26).fork();
    for (const v of message.monthlyBalances) {
      writer.int64(v);
    }
    writer.join();
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WalletMonthlyData {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWalletMonthlyData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.walletId = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.walletName = reader.string();
          continue;
        }
        case 3: {
          if (tag === 24) {
            message.monthlyBalances.push(longToNumber(reader.int64()));

            continue;
          }

          if (tag === 26) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.monthlyBalances.push(longToNumber(reader.int64()));
            }

            continue;
          }

          break;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): WalletMonthlyData {
    return {
      walletId: isSet(object.walletId) ? globalThis.Number(object.walletId) : 0,
      walletName: isSet(object.walletName) ? globalThis.String(object.walletName) : "",
      monthlyBalances: globalThis.Array.isArray(object?.monthlyBalances)
        ? object.monthlyBalances.map((e: any) => globalThis.Number(e))
        : [],
    };
  },

  toJSON(message: WalletMonthlyData): unknown {
    const obj: any = {};
    if (message.walletId !== 0) {
      obj.walletId = Math.round(message.walletId);
    }
    if (message.walletName !== "") {
      obj.walletName = message.walletName;
    }
    if (message.monthlyBalances?.length) {
      obj.monthlyBalances = message.monthlyBalances.map((e) => Math.round(e));
    }
    return obj;
  },

  create(base?: DeepPartial<WalletMonthlyData>): WalletMonthlyData {
    return WalletMonthlyData.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<WalletMonthlyData>): WalletMonthlyData {
    const message = createBaseWalletMonthlyData();
    message.walletId = object.walletId ?? 0;
    message.walletName = object.walletName ?? "";
    message.monthlyBalances = object.monthlyBalances?.map((e) => e) || [];
    return message;
  },
};

function createBaseGetMonthlyDominanceResponse(): GetMonthlyDominanceResponse {
  return { success: false, message: "", data: [], timestamp: "" };
}

export const GetMonthlyDominanceResponse: MessageFns<GetMonthlyDominanceResponse> = {
  encode(message: GetMonthlyDominanceResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    if (message.message !== "") {
      writer.uint32(18).string(message.message);
    }
    for (const v of message.data) {
      WalletMonthlyData.encode(v!, writer.uint32(26).fork()).join();
    }
    if (message.timestamp !== "") {
      writer.uint32(34).string(message.timestamp);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetMonthlyDominanceResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetMonthlyDominanceResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.message = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.data.push(WalletMonthlyData.decode(reader, reader.uint32()));
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.timestamp = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetMonthlyDominanceResponse {
    return {
      success: isSet(object.success) ? globalThis.Boolean(object.success) : false,
      message: isSet(object.message) ? globalThis.String(object.message) : "",
      data: globalThis.Array.isArray(object?.data) ? object.data.map((e: any) => WalletMonthlyData.fromJSON(e)) : [],
      timestamp: isSet(object.timestamp) ? globalThis.String(object.timestamp) : "",
    };
  },

  toJSON(message: GetMonthlyDominanceResponse): unknown {
    const obj: any = {};
    if (message.success !== false) {
      obj.success = message.success;
    }
    if (message.message !== "") {
      obj.message = message.message;
    }
    if (message.data?.length) {
      obj.data = message.data.map((e) => WalletMonthlyData.toJSON(e));
    }
    if (message.timestamp !== "") {
      obj.timestamp = message.timestamp;
    }
    return obj;
  },

  create(base?: DeepPartial<GetMonthlyDominanceResponse>): GetMonthlyDominanceResponse {
    return GetMonthlyDominanceResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetMonthlyDominanceResponse>): GetMonthlyDominanceResponse {
    const message = createBaseGetMonthlyDominanceResponse();
    message.success = object.success ?? false;
    message.message = object.message ?? "";
    message.data = object.data?.map((e) => WalletMonthlyData.fromPartial(e)) || [];
    message.timestamp = object.timestamp ?? "";
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends { $case: string } ? { [K in keyof Omit<T, "$case">]?: DeepPartial<T[K]> } & { $case: T["$case"] }
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function longToNumber(int64: { toString(): string }): number {
  const num = globalThis.Number(int64.toString());
  if (num > globalThis.Number.MAX_SAFE_INTEGER) {
    throw new globalThis.Error("Value is larger than Number.MAX_SAFE_INTEGER");
  }
  if (num < globalThis.Number.MIN_SAFE_INTEGER) {
    throw new globalThis.Error("Value is smaller than Number.MIN_SAFE_INTEGER");
  }
  return num;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
