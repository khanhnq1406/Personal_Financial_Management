// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.11.1
//   protoc               unknown
// source: protobuf/v1/investment.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import { Money, PaginationParams, PaginationResult } from "./common";

export const protobufPackage = "wealthjourney.investment.v1";

export const InvestmentType = {
  INVESTMENT_TYPE_UNSPECIFIED: 0,
  INVESTMENT_TYPE_CRYPTOCURRENCY: 1,
  INVESTMENT_TYPE_STOCK: 2,
  INVESTMENT_TYPE_ETF: 3,
  INVESTMENT_TYPE_MUTUAL_FUND: 4,
  INVESTMENT_TYPE_BOND: 5,
  INVESTMENT_TYPE_COMMODITY: 6,
  INVESTMENT_TYPE_OTHER: 7,
  UNRECOGNIZED: -1,
} as const;

export type InvestmentType = typeof InvestmentType[keyof typeof InvestmentType];

export namespace InvestmentType {
  export type INVESTMENT_TYPE_UNSPECIFIED = typeof InvestmentType.INVESTMENT_TYPE_UNSPECIFIED;
  export type INVESTMENT_TYPE_CRYPTOCURRENCY = typeof InvestmentType.INVESTMENT_TYPE_CRYPTOCURRENCY;
  export type INVESTMENT_TYPE_STOCK = typeof InvestmentType.INVESTMENT_TYPE_STOCK;
  export type INVESTMENT_TYPE_ETF = typeof InvestmentType.INVESTMENT_TYPE_ETF;
  export type INVESTMENT_TYPE_MUTUAL_FUND = typeof InvestmentType.INVESTMENT_TYPE_MUTUAL_FUND;
  export type INVESTMENT_TYPE_BOND = typeof InvestmentType.INVESTMENT_TYPE_BOND;
  export type INVESTMENT_TYPE_COMMODITY = typeof InvestmentType.INVESTMENT_TYPE_COMMODITY;
  export type INVESTMENT_TYPE_OTHER = typeof InvestmentType.INVESTMENT_TYPE_OTHER;
  export type UNRECOGNIZED = typeof InvestmentType.UNRECOGNIZED;
}

export function investmentTypeFromJSON(object: any): InvestmentType {
  switch (object) {
    case 0:
    case "INVESTMENT_TYPE_UNSPECIFIED":
      return InvestmentType.INVESTMENT_TYPE_UNSPECIFIED;
    case 1:
    case "INVESTMENT_TYPE_CRYPTOCURRENCY":
      return InvestmentType.INVESTMENT_TYPE_CRYPTOCURRENCY;
    case 2:
    case "INVESTMENT_TYPE_STOCK":
      return InvestmentType.INVESTMENT_TYPE_STOCK;
    case 3:
    case "INVESTMENT_TYPE_ETF":
      return InvestmentType.INVESTMENT_TYPE_ETF;
    case 4:
    case "INVESTMENT_TYPE_MUTUAL_FUND":
      return InvestmentType.INVESTMENT_TYPE_MUTUAL_FUND;
    case 5:
    case "INVESTMENT_TYPE_BOND":
      return InvestmentType.INVESTMENT_TYPE_BOND;
    case 6:
    case "INVESTMENT_TYPE_COMMODITY":
      return InvestmentType.INVESTMENT_TYPE_COMMODITY;
    case 7:
    case "INVESTMENT_TYPE_OTHER":
      return InvestmentType.INVESTMENT_TYPE_OTHER;
    case -1:
    case "UNRECOGNIZED":
    default:
      return InvestmentType.UNRECOGNIZED;
  }
}

export function investmentTypeToJSON(object: InvestmentType): string {
  switch (object) {
    case InvestmentType.INVESTMENT_TYPE_UNSPECIFIED:
      return "INVESTMENT_TYPE_UNSPECIFIED";
    case InvestmentType.INVESTMENT_TYPE_CRYPTOCURRENCY:
      return "INVESTMENT_TYPE_CRYPTOCURRENCY";
    case InvestmentType.INVESTMENT_TYPE_STOCK:
      return "INVESTMENT_TYPE_STOCK";
    case InvestmentType.INVESTMENT_TYPE_ETF:
      return "INVESTMENT_TYPE_ETF";
    case InvestmentType.INVESTMENT_TYPE_MUTUAL_FUND:
      return "INVESTMENT_TYPE_MUTUAL_FUND";
    case InvestmentType.INVESTMENT_TYPE_BOND:
      return "INVESTMENT_TYPE_BOND";
    case InvestmentType.INVESTMENT_TYPE_COMMODITY:
      return "INVESTMENT_TYPE_COMMODITY";
    case InvestmentType.INVESTMENT_TYPE_OTHER:
      return "INVESTMENT_TYPE_OTHER";
    case InvestmentType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export const InvestmentTransactionType = {
  INVESTMENT_TRANSACTION_TYPE_UNSPECIFIED: 0,
  INVESTMENT_TRANSACTION_TYPE_BUY: 1,
  INVESTMENT_TRANSACTION_TYPE_SELL: 2,
  INVESTMENT_TRANSACTION_TYPE_DIVIDEND: 3,
  INVESTMENT_TRANSACTION_TYPE_SPLIT: 4,
  UNRECOGNIZED: -1,
} as const;

export type InvestmentTransactionType = typeof InvestmentTransactionType[keyof typeof InvestmentTransactionType];

export namespace InvestmentTransactionType {
  export type INVESTMENT_TRANSACTION_TYPE_UNSPECIFIED =
    typeof InvestmentTransactionType.INVESTMENT_TRANSACTION_TYPE_UNSPECIFIED;
  export type INVESTMENT_TRANSACTION_TYPE_BUY = typeof InvestmentTransactionType.INVESTMENT_TRANSACTION_TYPE_BUY;
  export type INVESTMENT_TRANSACTION_TYPE_SELL = typeof InvestmentTransactionType.INVESTMENT_TRANSACTION_TYPE_SELL;
  export type INVESTMENT_TRANSACTION_TYPE_DIVIDEND =
    typeof InvestmentTransactionType.INVESTMENT_TRANSACTION_TYPE_DIVIDEND;
  export type INVESTMENT_TRANSACTION_TYPE_SPLIT = typeof InvestmentTransactionType.INVESTMENT_TRANSACTION_TYPE_SPLIT;
  export type UNRECOGNIZED = typeof InvestmentTransactionType.UNRECOGNIZED;
}

export function investmentTransactionTypeFromJSON(object: any): InvestmentTransactionType {
  switch (object) {
    case 0:
    case "INVESTMENT_TRANSACTION_TYPE_UNSPECIFIED":
      return InvestmentTransactionType.INVESTMENT_TRANSACTION_TYPE_UNSPECIFIED;
    case 1:
    case "INVESTMENT_TRANSACTION_TYPE_BUY":
      return InvestmentTransactionType.INVESTMENT_TRANSACTION_TYPE_BUY;
    case 2:
    case "INVESTMENT_TRANSACTION_TYPE_SELL":
      return InvestmentTransactionType.INVESTMENT_TRANSACTION_TYPE_SELL;
    case 3:
    case "INVESTMENT_TRANSACTION_TYPE_DIVIDEND":
      return InvestmentTransactionType.INVESTMENT_TRANSACTION_TYPE_DIVIDEND;
    case 4:
    case "INVESTMENT_TRANSACTION_TYPE_SPLIT":
      return InvestmentTransactionType.INVESTMENT_TRANSACTION_TYPE_SPLIT;
    case -1:
    case "UNRECOGNIZED":
    default:
      return InvestmentTransactionType.UNRECOGNIZED;
  }
}

export function investmentTransactionTypeToJSON(object: InvestmentTransactionType): string {
  switch (object) {
    case InvestmentTransactionType.INVESTMENT_TRANSACTION_TYPE_UNSPECIFIED:
      return "INVESTMENT_TRANSACTION_TYPE_UNSPECIFIED";
    case InvestmentTransactionType.INVESTMENT_TRANSACTION_TYPE_BUY:
      return "INVESTMENT_TRANSACTION_TYPE_BUY";
    case InvestmentTransactionType.INVESTMENT_TRANSACTION_TYPE_SELL:
      return "INVESTMENT_TRANSACTION_TYPE_SELL";
    case InvestmentTransactionType.INVESTMENT_TRANSACTION_TYPE_DIVIDEND:
      return "INVESTMENT_TRANSACTION_TYPE_DIVIDEND";
    case InvestmentTransactionType.INVESTMENT_TRANSACTION_TYPE_SPLIT:
      return "INVESTMENT_TRANSACTION_TYPE_SPLIT";
    case InvestmentTransactionType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Investment represents an individual holding within an investment wallet */
export interface Investment {
  id: number;
  walletId: number;
  /** e.g., "BTC", "AAPL", "VFINX" */
  symbol: string;
  /** e.g., "Bitcoin", "Apple Inc.", "Vanguard 500 Index" */
  name: string;
  type: InvestmentType;
  /** in smallest units (satoshis for crypto, shares for stocks * 10000) */
  quantity: number;
  /** Average cost per unit in currency's smallest unit */
  averageCost: number;
  /** Total cost basis (quantity * average_cost) */
  totalCost: number;
  /** ISO 4217 code */
  currency: string;
  /** Latest market price (0 if not available) */
  currentPrice: number;
  /** quantity * current_price */
  currentValue: number;
  /** current_value - total_cost */
  unrealizedPnl: number;
  /** ((current_value - total_cost) / total_cost) * 100 */
  unrealizedPnlPercent: number;
  /** From sold positions */
  realizedPnl: number;
  createdAt: number;
  updatedAt: number;
  /** Conversion fields (populated when user's preferred currency differs from investment currency) */
  displayTotalCost:
    | Money
    | undefined;
  /** Current value in user's preferred currency */
  displayCurrentValue:
    | Money
    | undefined;
  /** Unrealized PNL in user's preferred currency */
  displayUnrealizedPnl:
    | Money
    | undefined;
  /** Realized PNL in user's preferred currency */
  displayRealizedPnl:
    | Money
    | undefined;
  /** User's preferred currency code */
  displayCurrency: string;
}

/** InvestmentTransaction represents a buy or sell transaction */
export interface InvestmentTransaction {
  id: number;
  investmentId: number;
  walletId: number;
  type: InvestmentTransactionType;
  /** Quantity transacted */
  quantity: number;
  /** Price per unit */
  price: number;
  /** Total cost (quantity * price + fees) */
  cost: number;
  /** Transaction fees */
  fees: number;
  /** Unix timestamp */
  transactionDate: number;
  notes: string;
  createdAt: number;
  updatedAt: number;
  /** Lot tracking for FIFO */
  lotId: number;
  /** For buy lots: how much is left to sell */
  remainingQuantity: number;
}

/** Portfolio summary for dashboard */
export interface PortfolioSummary {
  totalValue: number;
  totalCost: number;
  totalPnl: number;
  totalPnlPercent: number;
  realizedPnl: number;
  unrealizedPnl: number;
  totalInvestments: number;
  investmentsByType: InvestmentByType[];
  /** Conversion fields (populated when user's preferred currency differs from summary currency) */
  currency: string;
  /** Total value in user's preferred currency */
  displayTotalValue:
    | Money
    | undefined;
  /** Total cost in user's preferred currency */
  displayTotalCost:
    | Money
    | undefined;
  /** Total PNL in user's preferred currency */
  displayTotalPnl:
    | Money
    | undefined;
  /** Realized PNL in user's preferred currency */
  displayRealizedPnl:
    | Money
    | undefined;
  /** Unrealized PNL in user's preferred currency */
  displayUnrealizedPnl:
    | Money
    | undefined;
  /** User's preferred currency code */
  displayCurrency: string;
}

export interface InvestmentByType {
  type: InvestmentType;
  totalValue: number;
  count: number;
}

/** Request/Response messages */
export interface ListInvestmentsRequest {
  walletId: number;
  pagination:
    | PaginationParams
    | undefined;
  /** Optional filter by type */
  typeFilter: InvestmentType;
}

export interface ListInvestmentsResponse {
  success: boolean;
  message: string;
  data: Investment[];
  timestamp: string;
  pagination: PaginationResult | undefined;
}

export interface GetInvestmentRequest {
  id: number;
}

export interface GetInvestmentResponse {
  success: boolean;
  message: string;
  data: Investment | undefined;
  timestamp: string;
}

export interface CreateInvestmentRequest {
  walletId: number;
  symbol: string;
  name: string;
  type: InvestmentType;
  initialQuantity: number;
  initialCost: number;
  currency: string;
}

export interface CreateInvestmentResponse {
  success: boolean;
  message: string;
  data: Investment | undefined;
  timestamp: string;
}

export interface UpdateInvestmentRequest {
  id: number;
  name: string;
  /** Manual price override */
  currentPrice: number;
}

export interface UpdateInvestmentResponse {
  success: boolean;
  message: string;
  data: Investment | undefined;
  timestamp: string;
}

export interface DeleteInvestmentRequest {
  id: number;
}

export interface DeleteInvestmentResponse {
  success: boolean;
  message: string;
  timestamp: string;
}

export interface AddTransactionRequest {
  investmentId: number;
  type: InvestmentTransactionType;
  quantity: number;
  price: number;
  fees: number;
  transactionDate: number;
  notes: string;
}

export interface AddTransactionResponse {
  success: boolean;
  message: string;
  data:
    | InvestmentTransaction
    | undefined;
  /** Investment with updated quantities */
  updatedInvestment: Investment | undefined;
  timestamp: string;
}

export interface ListInvestmentTransactionsRequest {
  investmentId: number;
  pagination: PaginationParams | undefined;
  typeFilter: InvestmentTransactionType;
}

export interface ListInvestmentTransactionsResponse {
  success: boolean;
  message: string;
  data: InvestmentTransaction[];
  timestamp: string;
  pagination: PaginationResult | undefined;
}

export interface EditInvestmentTransactionRequest {
  id: number;
  quantity: number;
  price: number;
  fees: number;
  transactionDate: number;
  notes: string;
}

export interface EditInvestmentTransactionResponse {
  success: boolean;
  message: string;
  data: InvestmentTransaction | undefined;
  timestamp: string;
}

export interface DeleteInvestmentTransactionRequest {
  id: number;
}

export interface DeleteInvestmentTransactionResponse {
  success: boolean;
  message: string;
  timestamp: string;
}

export interface GetPortfolioSummaryRequest {
  walletId: number;
}

export interface GetPortfolioSummaryResponse {
  success: boolean;
  message: string;
  data: PortfolioSummary | undefined;
  timestamp: string;
}

export interface UpdatePricesRequest {
  /** Empty = update all */
  investmentIds: number[];
  /** Force API call even if recently updated */
  forceRefresh: boolean;
}

export interface UpdatePricesResponse {
  success: boolean;
  message: string;
  updatedInvestments: Investment[];
  timestamp: string;
}

/** SearchSymbolsRequest represents the search request parameters */
export interface SearchSymbolsRequest {
  /** Search query (e.g., "AAPL", "Apple", "Bitcoin") */
  query: string;
  /** Max results to return (default: 10, max: 20) */
  limit: number;
}

/** SearchResult represents a single search result from Yahoo Finance */
export interface SearchResult {
  /** Ticker symbol (e.g., "AAPL", "BTC-USD") */
  symbol: string;
  /** Company/asset name */
  name: string;
  /** Type from quoteType (EQUITY, ETF, CRYPTOCURRENCY, etc.) */
  type: string;
  /** Exchange code (NAS, NMS, VSE, etc.) */
  exchange: string;
  /** Display name for exchange */
  exchDisp: string;
}

/** SearchSymbolsResponse represents the search response */
export interface SearchSymbolsResponse {
  success: boolean;
  message: string;
  data: SearchResult[];
  timestamp: string;
}

function createBaseInvestment(): Investment {
  return {
    id: 0,
    walletId: 0,
    symbol: "",
    name: "",
    type: 0,
    quantity: 0,
    averageCost: 0,
    totalCost: 0,
    currency: "",
    currentPrice: 0,
    currentValue: 0,
    unrealizedPnl: 0,
    unrealizedPnlPercent: 0,
    realizedPnl: 0,
    createdAt: 0,
    updatedAt: 0,
    displayTotalCost: undefined,
    displayCurrentValue: undefined,
    displayUnrealizedPnl: undefined,
    displayRealizedPnl: undefined,
    displayCurrency: "",
  };
}

export const Investment: MessageFns<Investment> = {
  encode(message: Investment, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== 0) {
      writer.uint32(8).int32(message.id);
    }
    if (message.walletId !== 0) {
      writer.uint32(16).int32(message.walletId);
    }
    if (message.symbol !== "") {
      writer.uint32(26).string(message.symbol);
    }
    if (message.name !== "") {
      writer.uint32(34).string(message.name);
    }
    if (message.type !== 0) {
      writer.uint32(40).int32(message.type);
    }
    if (message.quantity !== 0) {
      writer.uint32(48).int64(message.quantity);
    }
    if (message.averageCost !== 0) {
      writer.uint32(56).int64(message.averageCost);
    }
    if (message.totalCost !== 0) {
      writer.uint32(64).int64(message.totalCost);
    }
    if (message.currency !== "") {
      writer.uint32(74).string(message.currency);
    }
    if (message.currentPrice !== 0) {
      writer.uint32(80).int64(message.currentPrice);
    }
    if (message.currentValue !== 0) {
      writer.uint32(88).int64(message.currentValue);
    }
    if (message.unrealizedPnl !== 0) {
      writer.uint32(96).int64(message.unrealizedPnl);
    }
    if (message.unrealizedPnlPercent !== 0) {
      writer.uint32(105).double(message.unrealizedPnlPercent);
    }
    if (message.realizedPnl !== 0) {
      writer.uint32(112).int64(message.realizedPnl);
    }
    if (message.createdAt !== 0) {
      writer.uint32(120).int64(message.createdAt);
    }
    if (message.updatedAt !== 0) {
      writer.uint32(128).int64(message.updatedAt);
    }
    if (message.displayTotalCost !== undefined) {
      Money.encode(message.displayTotalCost, writer.uint32(138).fork()).join();
    }
    if (message.displayCurrentValue !== undefined) {
      Money.encode(message.displayCurrentValue, writer.uint32(146).fork()).join();
    }
    if (message.displayUnrealizedPnl !== undefined) {
      Money.encode(message.displayUnrealizedPnl, writer.uint32(154).fork()).join();
    }
    if (message.displayRealizedPnl !== undefined) {
      Money.encode(message.displayRealizedPnl, writer.uint32(162).fork()).join();
    }
    if (message.displayCurrency !== "") {
      writer.uint32(170).string(message.displayCurrency);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Investment {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseInvestment();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.id = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.walletId = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.symbol = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.type = reader.int32() as any;
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.quantity = longToNumber(reader.int64());
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.averageCost = longToNumber(reader.int64());
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.totalCost = longToNumber(reader.int64());
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.currency = reader.string();
          continue;
        }
        case 10: {
          if (tag !== 80) {
            break;
          }

          message.currentPrice = longToNumber(reader.int64());
          continue;
        }
        case 11: {
          if (tag !== 88) {
            break;
          }

          message.currentValue = longToNumber(reader.int64());
          continue;
        }
        case 12: {
          if (tag !== 96) {
            break;
          }

          message.unrealizedPnl = longToNumber(reader.int64());
          continue;
        }
        case 13: {
          if (tag !== 105) {
            break;
          }

          message.unrealizedPnlPercent = reader.double();
          continue;
        }
        case 14: {
          if (tag !== 112) {
            break;
          }

          message.realizedPnl = longToNumber(reader.int64());
          continue;
        }
        case 15: {
          if (tag !== 120) {
            break;
          }

          message.createdAt = longToNumber(reader.int64());
          continue;
        }
        case 16: {
          if (tag !== 128) {
            break;
          }

          message.updatedAt = longToNumber(reader.int64());
          continue;
        }
        case 17: {
          if (tag !== 138) {
            break;
          }

          message.displayTotalCost = Money.decode(reader, reader.uint32());
          continue;
        }
        case 18: {
          if (tag !== 146) {
            break;
          }

          message.displayCurrentValue = Money.decode(reader, reader.uint32());
          continue;
        }
        case 19: {
          if (tag !== 154) {
            break;
          }

          message.displayUnrealizedPnl = Money.decode(reader, reader.uint32());
          continue;
        }
        case 20: {
          if (tag !== 162) {
            break;
          }

          message.displayRealizedPnl = Money.decode(reader, reader.uint32());
          continue;
        }
        case 21: {
          if (tag !== 170) {
            break;
          }

          message.displayCurrency = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Investment {
    return {
      id: isSet(object.id) ? globalThis.Number(object.id) : 0,
      walletId: isSet(object.walletId) ? globalThis.Number(object.walletId) : 0,
      symbol: isSet(object.symbol) ? globalThis.String(object.symbol) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      type: isSet(object.type) ? investmentTypeFromJSON(object.type) : 0,
      quantity: isSet(object.quantity) ? globalThis.Number(object.quantity) : 0,
      averageCost: isSet(object.averageCost) ? globalThis.Number(object.averageCost) : 0,
      totalCost: isSet(object.totalCost) ? globalThis.Number(object.totalCost) : 0,
      currency: isSet(object.currency) ? globalThis.String(object.currency) : "",
      currentPrice: isSet(object.currentPrice) ? globalThis.Number(object.currentPrice) : 0,
      currentValue: isSet(object.currentValue) ? globalThis.Number(object.currentValue) : 0,
      unrealizedPnl: isSet(object.unrealizedPnl) ? globalThis.Number(object.unrealizedPnl) : 0,
      unrealizedPnlPercent: isSet(object.unrealizedPnlPercent) ? globalThis.Number(object.unrealizedPnlPercent) : 0,
      realizedPnl: isSet(object.realizedPnl) ? globalThis.Number(object.realizedPnl) : 0,
      createdAt: isSet(object.createdAt) ? globalThis.Number(object.createdAt) : 0,
      updatedAt: isSet(object.updatedAt) ? globalThis.Number(object.updatedAt) : 0,
      displayTotalCost: isSet(object.displayTotalCost) ? Money.fromJSON(object.displayTotalCost) : undefined,
      displayCurrentValue: isSet(object.displayCurrentValue) ? Money.fromJSON(object.displayCurrentValue) : undefined,
      displayUnrealizedPnl: isSet(object.displayUnrealizedPnl)
        ? Money.fromJSON(object.displayUnrealizedPnl)
        : undefined,
      displayRealizedPnl: isSet(object.displayRealizedPnl) ? Money.fromJSON(object.displayRealizedPnl) : undefined,
      displayCurrency: isSet(object.displayCurrency) ? globalThis.String(object.displayCurrency) : "",
    };
  },

  toJSON(message: Investment): unknown {
    const obj: any = {};
    if (message.id !== 0) {
      obj.id = Math.round(message.id);
    }
    if (message.walletId !== 0) {
      obj.walletId = Math.round(message.walletId);
    }
    if (message.symbol !== "") {
      obj.symbol = message.symbol;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.type !== 0) {
      obj.type = investmentTypeToJSON(message.type);
    }
    if (message.quantity !== 0) {
      obj.quantity = Math.round(message.quantity);
    }
    if (message.averageCost !== 0) {
      obj.averageCost = Math.round(message.averageCost);
    }
    if (message.totalCost !== 0) {
      obj.totalCost = Math.round(message.totalCost);
    }
    if (message.currency !== "") {
      obj.currency = message.currency;
    }
    if (message.currentPrice !== 0) {
      obj.currentPrice = Math.round(message.currentPrice);
    }
    if (message.currentValue !== 0) {
      obj.currentValue = Math.round(message.currentValue);
    }
    if (message.unrealizedPnl !== 0) {
      obj.unrealizedPnl = Math.round(message.unrealizedPnl);
    }
    if (message.unrealizedPnlPercent !== 0) {
      obj.unrealizedPnlPercent = message.unrealizedPnlPercent;
    }
    if (message.realizedPnl !== 0) {
      obj.realizedPnl = Math.round(message.realizedPnl);
    }
    if (message.createdAt !== 0) {
      obj.createdAt = Math.round(message.createdAt);
    }
    if (message.updatedAt !== 0) {
      obj.updatedAt = Math.round(message.updatedAt);
    }
    if (message.displayTotalCost !== undefined) {
      obj.displayTotalCost = Money.toJSON(message.displayTotalCost);
    }
    if (message.displayCurrentValue !== undefined) {
      obj.displayCurrentValue = Money.toJSON(message.displayCurrentValue);
    }
    if (message.displayUnrealizedPnl !== undefined) {
      obj.displayUnrealizedPnl = Money.toJSON(message.displayUnrealizedPnl);
    }
    if (message.displayRealizedPnl !== undefined) {
      obj.displayRealizedPnl = Money.toJSON(message.displayRealizedPnl);
    }
    if (message.displayCurrency !== "") {
      obj.displayCurrency = message.displayCurrency;
    }
    return obj;
  },

  create(base?: DeepPartial<Investment>): Investment {
    return Investment.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Investment>): Investment {
    const message = createBaseInvestment();
    message.id = object.id ?? 0;
    message.walletId = object.walletId ?? 0;
    message.symbol = object.symbol ?? "";
    message.name = object.name ?? "";
    message.type = object.type ?? 0;
    message.quantity = object.quantity ?? 0;
    message.averageCost = object.averageCost ?? 0;
    message.totalCost = object.totalCost ?? 0;
    message.currency = object.currency ?? "";
    message.currentPrice = object.currentPrice ?? 0;
    message.currentValue = object.currentValue ?? 0;
    message.unrealizedPnl = object.unrealizedPnl ?? 0;
    message.unrealizedPnlPercent = object.unrealizedPnlPercent ?? 0;
    message.realizedPnl = object.realizedPnl ?? 0;
    message.createdAt = object.createdAt ?? 0;
    message.updatedAt = object.updatedAt ?? 0;
    message.displayTotalCost = (object.displayTotalCost !== undefined && object.displayTotalCost !== null)
      ? Money.fromPartial(object.displayTotalCost)
      : undefined;
    message.displayCurrentValue = (object.displayCurrentValue !== undefined && object.displayCurrentValue !== null)
      ? Money.fromPartial(object.displayCurrentValue)
      : undefined;
    message.displayUnrealizedPnl = (object.displayUnrealizedPnl !== undefined && object.displayUnrealizedPnl !== null)
      ? Money.fromPartial(object.displayUnrealizedPnl)
      : undefined;
    message.displayRealizedPnl = (object.displayRealizedPnl !== undefined && object.displayRealizedPnl !== null)
      ? Money.fromPartial(object.displayRealizedPnl)
      : undefined;
    message.displayCurrency = object.displayCurrency ?? "";
    return message;
  },
};

function createBaseInvestmentTransaction(): InvestmentTransaction {
  return {
    id: 0,
    investmentId: 0,
    walletId: 0,
    type: 0,
    quantity: 0,
    price: 0,
    cost: 0,
    fees: 0,
    transactionDate: 0,
    notes: "",
    createdAt: 0,
    updatedAt: 0,
    lotId: 0,
    remainingQuantity: 0,
  };
}

export const InvestmentTransaction: MessageFns<InvestmentTransaction> = {
  encode(message: InvestmentTransaction, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== 0) {
      writer.uint32(8).int32(message.id);
    }
    if (message.investmentId !== 0) {
      writer.uint32(16).int32(message.investmentId);
    }
    if (message.walletId !== 0) {
      writer.uint32(24).int32(message.walletId);
    }
    if (message.type !== 0) {
      writer.uint32(32).int32(message.type);
    }
    if (message.quantity !== 0) {
      writer.uint32(40).int64(message.quantity);
    }
    if (message.price !== 0) {
      writer.uint32(48).int64(message.price);
    }
    if (message.cost !== 0) {
      writer.uint32(56).int64(message.cost);
    }
    if (message.fees !== 0) {
      writer.uint32(64).int64(message.fees);
    }
    if (message.transactionDate !== 0) {
      writer.uint32(72).int64(message.transactionDate);
    }
    if (message.notes !== "") {
      writer.uint32(82).string(message.notes);
    }
    if (message.createdAt !== 0) {
      writer.uint32(88).int64(message.createdAt);
    }
    if (message.updatedAt !== 0) {
      writer.uint32(96).int64(message.updatedAt);
    }
    if (message.lotId !== 0) {
      writer.uint32(104).int32(message.lotId);
    }
    if (message.remainingQuantity !== 0) {
      writer.uint32(112).int32(message.remainingQuantity);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): InvestmentTransaction {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseInvestmentTransaction();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.id = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.investmentId = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.walletId = reader.int32();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.type = reader.int32() as any;
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.quantity = longToNumber(reader.int64());
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.price = longToNumber(reader.int64());
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.cost = longToNumber(reader.int64());
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.fees = longToNumber(reader.int64());
          continue;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }

          message.transactionDate = longToNumber(reader.int64());
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.notes = reader.string();
          continue;
        }
        case 11: {
          if (tag !== 88) {
            break;
          }

          message.createdAt = longToNumber(reader.int64());
          continue;
        }
        case 12: {
          if (tag !== 96) {
            break;
          }

          message.updatedAt = longToNumber(reader.int64());
          continue;
        }
        case 13: {
          if (tag !== 104) {
            break;
          }

          message.lotId = reader.int32();
          continue;
        }
        case 14: {
          if (tag !== 112) {
            break;
          }

          message.remainingQuantity = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): InvestmentTransaction {
    return {
      id: isSet(object.id) ? globalThis.Number(object.id) : 0,
      investmentId: isSet(object.investmentId) ? globalThis.Number(object.investmentId) : 0,
      walletId: isSet(object.walletId) ? globalThis.Number(object.walletId) : 0,
      type: isSet(object.type) ? investmentTransactionTypeFromJSON(object.type) : 0,
      quantity: isSet(object.quantity) ? globalThis.Number(object.quantity) : 0,
      price: isSet(object.price) ? globalThis.Number(object.price) : 0,
      cost: isSet(object.cost) ? globalThis.Number(object.cost) : 0,
      fees: isSet(object.fees) ? globalThis.Number(object.fees) : 0,
      transactionDate: isSet(object.transactionDate) ? globalThis.Number(object.transactionDate) : 0,
      notes: isSet(object.notes) ? globalThis.String(object.notes) : "",
      createdAt: isSet(object.createdAt) ? globalThis.Number(object.createdAt) : 0,
      updatedAt: isSet(object.updatedAt) ? globalThis.Number(object.updatedAt) : 0,
      lotId: isSet(object.lotId) ? globalThis.Number(object.lotId) : 0,
      remainingQuantity: isSet(object.remainingQuantity) ? globalThis.Number(object.remainingQuantity) : 0,
    };
  },

  toJSON(message: InvestmentTransaction): unknown {
    const obj: any = {};
    if (message.id !== 0) {
      obj.id = Math.round(message.id);
    }
    if (message.investmentId !== 0) {
      obj.investmentId = Math.round(message.investmentId);
    }
    if (message.walletId !== 0) {
      obj.walletId = Math.round(message.walletId);
    }
    if (message.type !== 0) {
      obj.type = investmentTransactionTypeToJSON(message.type);
    }
    if (message.quantity !== 0) {
      obj.quantity = Math.round(message.quantity);
    }
    if (message.price !== 0) {
      obj.price = Math.round(message.price);
    }
    if (message.cost !== 0) {
      obj.cost = Math.round(message.cost);
    }
    if (message.fees !== 0) {
      obj.fees = Math.round(message.fees);
    }
    if (message.transactionDate !== 0) {
      obj.transactionDate = Math.round(message.transactionDate);
    }
    if (message.notes !== "") {
      obj.notes = message.notes;
    }
    if (message.createdAt !== 0) {
      obj.createdAt = Math.round(message.createdAt);
    }
    if (message.updatedAt !== 0) {
      obj.updatedAt = Math.round(message.updatedAt);
    }
    if (message.lotId !== 0) {
      obj.lotId = Math.round(message.lotId);
    }
    if (message.remainingQuantity !== 0) {
      obj.remainingQuantity = Math.round(message.remainingQuantity);
    }
    return obj;
  },

  create(base?: DeepPartial<InvestmentTransaction>): InvestmentTransaction {
    return InvestmentTransaction.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<InvestmentTransaction>): InvestmentTransaction {
    const message = createBaseInvestmentTransaction();
    message.id = object.id ?? 0;
    message.investmentId = object.investmentId ?? 0;
    message.walletId = object.walletId ?? 0;
    message.type = object.type ?? 0;
    message.quantity = object.quantity ?? 0;
    message.price = object.price ?? 0;
    message.cost = object.cost ?? 0;
    message.fees = object.fees ?? 0;
    message.transactionDate = object.transactionDate ?? 0;
    message.notes = object.notes ?? "";
    message.createdAt = object.createdAt ?? 0;
    message.updatedAt = object.updatedAt ?? 0;
    message.lotId = object.lotId ?? 0;
    message.remainingQuantity = object.remainingQuantity ?? 0;
    return message;
  },
};

function createBasePortfolioSummary(): PortfolioSummary {
  return {
    totalValue: 0,
    totalCost: 0,
    totalPnl: 0,
    totalPnlPercent: 0,
    realizedPnl: 0,
    unrealizedPnl: 0,
    totalInvestments: 0,
    investmentsByType: [],
    currency: "",
    displayTotalValue: undefined,
    displayTotalCost: undefined,
    displayTotalPnl: undefined,
    displayRealizedPnl: undefined,
    displayUnrealizedPnl: undefined,
    displayCurrency: "",
  };
}

export const PortfolioSummary: MessageFns<PortfolioSummary> = {
  encode(message: PortfolioSummary, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.totalValue !== 0) {
      writer.uint32(8).int64(message.totalValue);
    }
    if (message.totalCost !== 0) {
      writer.uint32(16).int64(message.totalCost);
    }
    if (message.totalPnl !== 0) {
      writer.uint32(24).int64(message.totalPnl);
    }
    if (message.totalPnlPercent !== 0) {
      writer.uint32(33).double(message.totalPnlPercent);
    }
    if (message.realizedPnl !== 0) {
      writer.uint32(40).int64(message.realizedPnl);
    }
    if (message.unrealizedPnl !== 0) {
      writer.uint32(48).int64(message.unrealizedPnl);
    }
    if (message.totalInvestments !== 0) {
      writer.uint32(56).int32(message.totalInvestments);
    }
    for (const v of message.investmentsByType) {
      InvestmentByType.encode(v!, writer.uint32(66).fork()).join();
    }
    if (message.currency !== "") {
      writer.uint32(74).string(message.currency);
    }
    if (message.displayTotalValue !== undefined) {
      Money.encode(message.displayTotalValue, writer.uint32(82).fork()).join();
    }
    if (message.displayTotalCost !== undefined) {
      Money.encode(message.displayTotalCost, writer.uint32(90).fork()).join();
    }
    if (message.displayTotalPnl !== undefined) {
      Money.encode(message.displayTotalPnl, writer.uint32(98).fork()).join();
    }
    if (message.displayRealizedPnl !== undefined) {
      Money.encode(message.displayRealizedPnl, writer.uint32(106).fork()).join();
    }
    if (message.displayUnrealizedPnl !== undefined) {
      Money.encode(message.displayUnrealizedPnl, writer.uint32(114).fork()).join();
    }
    if (message.displayCurrency !== "") {
      writer.uint32(122).string(message.displayCurrency);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PortfolioSummary {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePortfolioSummary();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.totalValue = longToNumber(reader.int64());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.totalCost = longToNumber(reader.int64());
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.totalPnl = longToNumber(reader.int64());
          continue;
        }
        case 4: {
          if (tag !== 33) {
            break;
          }

          message.totalPnlPercent = reader.double();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.realizedPnl = longToNumber(reader.int64());
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.unrealizedPnl = longToNumber(reader.int64());
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.totalInvestments = reader.int32();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.investmentsByType.push(InvestmentByType.decode(reader, reader.uint32()));
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.currency = reader.string();
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.displayTotalValue = Money.decode(reader, reader.uint32());
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.displayTotalCost = Money.decode(reader, reader.uint32());
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.displayTotalPnl = Money.decode(reader, reader.uint32());
          continue;
        }
        case 13: {
          if (tag !== 106) {
            break;
          }

          message.displayRealizedPnl = Money.decode(reader, reader.uint32());
          continue;
        }
        case 14: {
          if (tag !== 114) {
            break;
          }

          message.displayUnrealizedPnl = Money.decode(reader, reader.uint32());
          continue;
        }
        case 15: {
          if (tag !== 122) {
            break;
          }

          message.displayCurrency = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PortfolioSummary {
    return {
      totalValue: isSet(object.totalValue) ? globalThis.Number(object.totalValue) : 0,
      totalCost: isSet(object.totalCost) ? globalThis.Number(object.totalCost) : 0,
      totalPnl: isSet(object.totalPnl) ? globalThis.Number(object.totalPnl) : 0,
      totalPnlPercent: isSet(object.totalPnlPercent) ? globalThis.Number(object.totalPnlPercent) : 0,
      realizedPnl: isSet(object.realizedPnl) ? globalThis.Number(object.realizedPnl) : 0,
      unrealizedPnl: isSet(object.unrealizedPnl) ? globalThis.Number(object.unrealizedPnl) : 0,
      totalInvestments: isSet(object.totalInvestments) ? globalThis.Number(object.totalInvestments) : 0,
      investmentsByType: globalThis.Array.isArray(object?.investmentsByType)
        ? object.investmentsByType.map((e: any) => InvestmentByType.fromJSON(e))
        : [],
      currency: isSet(object.currency) ? globalThis.String(object.currency) : "",
      displayTotalValue: isSet(object.displayTotalValue) ? Money.fromJSON(object.displayTotalValue) : undefined,
      displayTotalCost: isSet(object.displayTotalCost) ? Money.fromJSON(object.displayTotalCost) : undefined,
      displayTotalPnl: isSet(object.displayTotalPnl) ? Money.fromJSON(object.displayTotalPnl) : undefined,
      displayRealizedPnl: isSet(object.displayRealizedPnl) ? Money.fromJSON(object.displayRealizedPnl) : undefined,
      displayUnrealizedPnl: isSet(object.displayUnrealizedPnl)
        ? Money.fromJSON(object.displayUnrealizedPnl)
        : undefined,
      displayCurrency: isSet(object.displayCurrency) ? globalThis.String(object.displayCurrency) : "",
    };
  },

  toJSON(message: PortfolioSummary): unknown {
    const obj: any = {};
    if (message.totalValue !== 0) {
      obj.totalValue = Math.round(message.totalValue);
    }
    if (message.totalCost !== 0) {
      obj.totalCost = Math.round(message.totalCost);
    }
    if (message.totalPnl !== 0) {
      obj.totalPnl = Math.round(message.totalPnl);
    }
    if (message.totalPnlPercent !== 0) {
      obj.totalPnlPercent = message.totalPnlPercent;
    }
    if (message.realizedPnl !== 0) {
      obj.realizedPnl = Math.round(message.realizedPnl);
    }
    if (message.unrealizedPnl !== 0) {
      obj.unrealizedPnl = Math.round(message.unrealizedPnl);
    }
    if (message.totalInvestments !== 0) {
      obj.totalInvestments = Math.round(message.totalInvestments);
    }
    if (message.investmentsByType?.length) {
      obj.investmentsByType = message.investmentsByType.map((e) => InvestmentByType.toJSON(e));
    }
    if (message.currency !== "") {
      obj.currency = message.currency;
    }
    if (message.displayTotalValue !== undefined) {
      obj.displayTotalValue = Money.toJSON(message.displayTotalValue);
    }
    if (message.displayTotalCost !== undefined) {
      obj.displayTotalCost = Money.toJSON(message.displayTotalCost);
    }
    if (message.displayTotalPnl !== undefined) {
      obj.displayTotalPnl = Money.toJSON(message.displayTotalPnl);
    }
    if (message.displayRealizedPnl !== undefined) {
      obj.displayRealizedPnl = Money.toJSON(message.displayRealizedPnl);
    }
    if (message.displayUnrealizedPnl !== undefined) {
      obj.displayUnrealizedPnl = Money.toJSON(message.displayUnrealizedPnl);
    }
    if (message.displayCurrency !== "") {
      obj.displayCurrency = message.displayCurrency;
    }
    return obj;
  },

  create(base?: DeepPartial<PortfolioSummary>): PortfolioSummary {
    return PortfolioSummary.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<PortfolioSummary>): PortfolioSummary {
    const message = createBasePortfolioSummary();
    message.totalValue = object.totalValue ?? 0;
    message.totalCost = object.totalCost ?? 0;
    message.totalPnl = object.totalPnl ?? 0;
    message.totalPnlPercent = object.totalPnlPercent ?? 0;
    message.realizedPnl = object.realizedPnl ?? 0;
    message.unrealizedPnl = object.unrealizedPnl ?? 0;
    message.totalInvestments = object.totalInvestments ?? 0;
    message.investmentsByType = object.investmentsByType?.map((e) => InvestmentByType.fromPartial(e)) || [];
    message.currency = object.currency ?? "";
    message.displayTotalValue = (object.displayTotalValue !== undefined && object.displayTotalValue !== null)
      ? Money.fromPartial(object.displayTotalValue)
      : undefined;
    message.displayTotalCost = (object.displayTotalCost !== undefined && object.displayTotalCost !== null)
      ? Money.fromPartial(object.displayTotalCost)
      : undefined;
    message.displayTotalPnl = (object.displayTotalPnl !== undefined && object.displayTotalPnl !== null)
      ? Money.fromPartial(object.displayTotalPnl)
      : undefined;
    message.displayRealizedPnl = (object.displayRealizedPnl !== undefined && object.displayRealizedPnl !== null)
      ? Money.fromPartial(object.displayRealizedPnl)
      : undefined;
    message.displayUnrealizedPnl = (object.displayUnrealizedPnl !== undefined && object.displayUnrealizedPnl !== null)
      ? Money.fromPartial(object.displayUnrealizedPnl)
      : undefined;
    message.displayCurrency = object.displayCurrency ?? "";
    return message;
  },
};

function createBaseInvestmentByType(): InvestmentByType {
  return { type: 0, totalValue: 0, count: 0 };
}

export const InvestmentByType: MessageFns<InvestmentByType> = {
  encode(message: InvestmentByType, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.type !== 0) {
      writer.uint32(8).int32(message.type);
    }
    if (message.totalValue !== 0) {
      writer.uint32(16).int64(message.totalValue);
    }
    if (message.count !== 0) {
      writer.uint32(24).int32(message.count);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): InvestmentByType {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseInvestmentByType();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.type = reader.int32() as any;
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.totalValue = longToNumber(reader.int64());
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.count = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): InvestmentByType {
    return {
      type: isSet(object.type) ? investmentTypeFromJSON(object.type) : 0,
      totalValue: isSet(object.totalValue) ? globalThis.Number(object.totalValue) : 0,
      count: isSet(object.count) ? globalThis.Number(object.count) : 0,
    };
  },

  toJSON(message: InvestmentByType): unknown {
    const obj: any = {};
    if (message.type !== 0) {
      obj.type = investmentTypeToJSON(message.type);
    }
    if (message.totalValue !== 0) {
      obj.totalValue = Math.round(message.totalValue);
    }
    if (message.count !== 0) {
      obj.count = Math.round(message.count);
    }
    return obj;
  },

  create(base?: DeepPartial<InvestmentByType>): InvestmentByType {
    return InvestmentByType.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<InvestmentByType>): InvestmentByType {
    const message = createBaseInvestmentByType();
    message.type = object.type ?? 0;
    message.totalValue = object.totalValue ?? 0;
    message.count = object.count ?? 0;
    return message;
  },
};

function createBaseListInvestmentsRequest(): ListInvestmentsRequest {
  return { walletId: 0, pagination: undefined, typeFilter: 0 };
}

export const ListInvestmentsRequest: MessageFns<ListInvestmentsRequest> = {
  encode(message: ListInvestmentsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.walletId !== 0) {
      writer.uint32(8).int32(message.walletId);
    }
    if (message.pagination !== undefined) {
      PaginationParams.encode(message.pagination, writer.uint32(18).fork()).join();
    }
    if (message.typeFilter !== 0) {
      writer.uint32(24).int32(message.typeFilter);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListInvestmentsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListInvestmentsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.walletId = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.pagination = PaginationParams.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.typeFilter = reader.int32() as any;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListInvestmentsRequest {
    return {
      walletId: isSet(object.walletId) ? globalThis.Number(object.walletId) : 0,
      pagination: isSet(object.pagination) ? PaginationParams.fromJSON(object.pagination) : undefined,
      typeFilter: isSet(object.typeFilter) ? investmentTypeFromJSON(object.typeFilter) : 0,
    };
  },

  toJSON(message: ListInvestmentsRequest): unknown {
    const obj: any = {};
    if (message.walletId !== 0) {
      obj.walletId = Math.round(message.walletId);
    }
    if (message.pagination !== undefined) {
      obj.pagination = PaginationParams.toJSON(message.pagination);
    }
    if (message.typeFilter !== 0) {
      obj.typeFilter = investmentTypeToJSON(message.typeFilter);
    }
    return obj;
  },

  create(base?: DeepPartial<ListInvestmentsRequest>): ListInvestmentsRequest {
    return ListInvestmentsRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListInvestmentsRequest>): ListInvestmentsRequest {
    const message = createBaseListInvestmentsRequest();
    message.walletId = object.walletId ?? 0;
    message.pagination = (object.pagination !== undefined && object.pagination !== null)
      ? PaginationParams.fromPartial(object.pagination)
      : undefined;
    message.typeFilter = object.typeFilter ?? 0;
    return message;
  },
};

function createBaseListInvestmentsResponse(): ListInvestmentsResponse {
  return { success: false, message: "", data: [], timestamp: "", pagination: undefined };
}

export const ListInvestmentsResponse: MessageFns<ListInvestmentsResponse> = {
  encode(message: ListInvestmentsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    if (message.message !== "") {
      writer.uint32(18).string(message.message);
    }
    for (const v of message.data) {
      Investment.encode(v!, writer.uint32(26).fork()).join();
    }
    if (message.timestamp !== "") {
      writer.uint32(34).string(message.timestamp);
    }
    if (message.pagination !== undefined) {
      PaginationResult.encode(message.pagination, writer.uint32(42).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListInvestmentsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListInvestmentsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.message = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.data.push(Investment.decode(reader, reader.uint32()));
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.timestamp = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.pagination = PaginationResult.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListInvestmentsResponse {
    return {
      success: isSet(object.success) ? globalThis.Boolean(object.success) : false,
      message: isSet(object.message) ? globalThis.String(object.message) : "",
      data: globalThis.Array.isArray(object?.data) ? object.data.map((e: any) => Investment.fromJSON(e)) : [],
      timestamp: isSet(object.timestamp) ? globalThis.String(object.timestamp) : "",
      pagination: isSet(object.pagination) ? PaginationResult.fromJSON(object.pagination) : undefined,
    };
  },

  toJSON(message: ListInvestmentsResponse): unknown {
    const obj: any = {};
    if (message.success !== false) {
      obj.success = message.success;
    }
    if (message.message !== "") {
      obj.message = message.message;
    }
    if (message.data?.length) {
      obj.data = message.data.map((e) => Investment.toJSON(e));
    }
    if (message.timestamp !== "") {
      obj.timestamp = message.timestamp;
    }
    if (message.pagination !== undefined) {
      obj.pagination = PaginationResult.toJSON(message.pagination);
    }
    return obj;
  },

  create(base?: DeepPartial<ListInvestmentsResponse>): ListInvestmentsResponse {
    return ListInvestmentsResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListInvestmentsResponse>): ListInvestmentsResponse {
    const message = createBaseListInvestmentsResponse();
    message.success = object.success ?? false;
    message.message = object.message ?? "";
    message.data = object.data?.map((e) => Investment.fromPartial(e)) || [];
    message.timestamp = object.timestamp ?? "";
    message.pagination = (object.pagination !== undefined && object.pagination !== null)
      ? PaginationResult.fromPartial(object.pagination)
      : undefined;
    return message;
  },
};

function createBaseGetInvestmentRequest(): GetInvestmentRequest {
  return { id: 0 };
}

export const GetInvestmentRequest: MessageFns<GetInvestmentRequest> = {
  encode(message: GetInvestmentRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== 0) {
      writer.uint32(8).int32(message.id);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetInvestmentRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetInvestmentRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.id = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetInvestmentRequest {
    return { id: isSet(object.id) ? globalThis.Number(object.id) : 0 };
  },

  toJSON(message: GetInvestmentRequest): unknown {
    const obj: any = {};
    if (message.id !== 0) {
      obj.id = Math.round(message.id);
    }
    return obj;
  },

  create(base?: DeepPartial<GetInvestmentRequest>): GetInvestmentRequest {
    return GetInvestmentRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetInvestmentRequest>): GetInvestmentRequest {
    const message = createBaseGetInvestmentRequest();
    message.id = object.id ?? 0;
    return message;
  },
};

function createBaseGetInvestmentResponse(): GetInvestmentResponse {
  return { success: false, message: "", data: undefined, timestamp: "" };
}

export const GetInvestmentResponse: MessageFns<GetInvestmentResponse> = {
  encode(message: GetInvestmentResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    if (message.message !== "") {
      writer.uint32(18).string(message.message);
    }
    if (message.data !== undefined) {
      Investment.encode(message.data, writer.uint32(26).fork()).join();
    }
    if (message.timestamp !== "") {
      writer.uint32(34).string(message.timestamp);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetInvestmentResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetInvestmentResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.message = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.data = Investment.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.timestamp = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetInvestmentResponse {
    return {
      success: isSet(object.success) ? globalThis.Boolean(object.success) : false,
      message: isSet(object.message) ? globalThis.String(object.message) : "",
      data: isSet(object.data) ? Investment.fromJSON(object.data) : undefined,
      timestamp: isSet(object.timestamp) ? globalThis.String(object.timestamp) : "",
    };
  },

  toJSON(message: GetInvestmentResponse): unknown {
    const obj: any = {};
    if (message.success !== false) {
      obj.success = message.success;
    }
    if (message.message !== "") {
      obj.message = message.message;
    }
    if (message.data !== undefined) {
      obj.data = Investment.toJSON(message.data);
    }
    if (message.timestamp !== "") {
      obj.timestamp = message.timestamp;
    }
    return obj;
  },

  create(base?: DeepPartial<GetInvestmentResponse>): GetInvestmentResponse {
    return GetInvestmentResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetInvestmentResponse>): GetInvestmentResponse {
    const message = createBaseGetInvestmentResponse();
    message.success = object.success ?? false;
    message.message = object.message ?? "";
    message.data = (object.data !== undefined && object.data !== null)
      ? Investment.fromPartial(object.data)
      : undefined;
    message.timestamp = object.timestamp ?? "";
    return message;
  },
};

function createBaseCreateInvestmentRequest(): CreateInvestmentRequest {
  return { walletId: 0, symbol: "", name: "", type: 0, initialQuantity: 0, initialCost: 0, currency: "" };
}

export const CreateInvestmentRequest: MessageFns<CreateInvestmentRequest> = {
  encode(message: CreateInvestmentRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.walletId !== 0) {
      writer.uint32(8).int32(message.walletId);
    }
    if (message.symbol !== "") {
      writer.uint32(18).string(message.symbol);
    }
    if (message.name !== "") {
      writer.uint32(26).string(message.name);
    }
    if (message.type !== 0) {
      writer.uint32(32).int32(message.type);
    }
    if (message.initialQuantity !== 0) {
      writer.uint32(40).int64(message.initialQuantity);
    }
    if (message.initialCost !== 0) {
      writer.uint32(48).int64(message.initialCost);
    }
    if (message.currency !== "") {
      writer.uint32(58).string(message.currency);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateInvestmentRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateInvestmentRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.walletId = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.symbol = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.type = reader.int32() as any;
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.initialQuantity = longToNumber(reader.int64());
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.initialCost = longToNumber(reader.int64());
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.currency = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateInvestmentRequest {
    return {
      walletId: isSet(object.walletId) ? globalThis.Number(object.walletId) : 0,
      symbol: isSet(object.symbol) ? globalThis.String(object.symbol) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      type: isSet(object.type) ? investmentTypeFromJSON(object.type) : 0,
      initialQuantity: isSet(object.initialQuantity) ? globalThis.Number(object.initialQuantity) : 0,
      initialCost: isSet(object.initialCost) ? globalThis.Number(object.initialCost) : 0,
      currency: isSet(object.currency) ? globalThis.String(object.currency) : "",
    };
  },

  toJSON(message: CreateInvestmentRequest): unknown {
    const obj: any = {};
    if (message.walletId !== 0) {
      obj.walletId = Math.round(message.walletId);
    }
    if (message.symbol !== "") {
      obj.symbol = message.symbol;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.type !== 0) {
      obj.type = investmentTypeToJSON(message.type);
    }
    if (message.initialQuantity !== 0) {
      obj.initialQuantity = Math.round(message.initialQuantity);
    }
    if (message.initialCost !== 0) {
      obj.initialCost = Math.round(message.initialCost);
    }
    if (message.currency !== "") {
      obj.currency = message.currency;
    }
    return obj;
  },

  create(base?: DeepPartial<CreateInvestmentRequest>): CreateInvestmentRequest {
    return CreateInvestmentRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CreateInvestmentRequest>): CreateInvestmentRequest {
    const message = createBaseCreateInvestmentRequest();
    message.walletId = object.walletId ?? 0;
    message.symbol = object.symbol ?? "";
    message.name = object.name ?? "";
    message.type = object.type ?? 0;
    message.initialQuantity = object.initialQuantity ?? 0;
    message.initialCost = object.initialCost ?? 0;
    message.currency = object.currency ?? "";
    return message;
  },
};

function createBaseCreateInvestmentResponse(): CreateInvestmentResponse {
  return { success: false, message: "", data: undefined, timestamp: "" };
}

export const CreateInvestmentResponse: MessageFns<CreateInvestmentResponse> = {
  encode(message: CreateInvestmentResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    if (message.message !== "") {
      writer.uint32(18).string(message.message);
    }
    if (message.data !== undefined) {
      Investment.encode(message.data, writer.uint32(26).fork()).join();
    }
    if (message.timestamp !== "") {
      writer.uint32(34).string(message.timestamp);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateInvestmentResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateInvestmentResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.message = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.data = Investment.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.timestamp = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateInvestmentResponse {
    return {
      success: isSet(object.success) ? globalThis.Boolean(object.success) : false,
      message: isSet(object.message) ? globalThis.String(object.message) : "",
      data: isSet(object.data) ? Investment.fromJSON(object.data) : undefined,
      timestamp: isSet(object.timestamp) ? globalThis.String(object.timestamp) : "",
    };
  },

  toJSON(message: CreateInvestmentResponse): unknown {
    const obj: any = {};
    if (message.success !== false) {
      obj.success = message.success;
    }
    if (message.message !== "") {
      obj.message = message.message;
    }
    if (message.data !== undefined) {
      obj.data = Investment.toJSON(message.data);
    }
    if (message.timestamp !== "") {
      obj.timestamp = message.timestamp;
    }
    return obj;
  },

  create(base?: DeepPartial<CreateInvestmentResponse>): CreateInvestmentResponse {
    return CreateInvestmentResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CreateInvestmentResponse>): CreateInvestmentResponse {
    const message = createBaseCreateInvestmentResponse();
    message.success = object.success ?? false;
    message.message = object.message ?? "";
    message.data = (object.data !== undefined && object.data !== null)
      ? Investment.fromPartial(object.data)
      : undefined;
    message.timestamp = object.timestamp ?? "";
    return message;
  },
};

function createBaseUpdateInvestmentRequest(): UpdateInvestmentRequest {
  return { id: 0, name: "", currentPrice: 0 };
}

export const UpdateInvestmentRequest: MessageFns<UpdateInvestmentRequest> = {
  encode(message: UpdateInvestmentRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== 0) {
      writer.uint32(8).int32(message.id);
    }
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    if (message.currentPrice !== 0) {
      writer.uint32(24).int64(message.currentPrice);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdateInvestmentRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateInvestmentRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.id = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.currentPrice = longToNumber(reader.int64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateInvestmentRequest {
    return {
      id: isSet(object.id) ? globalThis.Number(object.id) : 0,
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      currentPrice: isSet(object.currentPrice) ? globalThis.Number(object.currentPrice) : 0,
    };
  },

  toJSON(message: UpdateInvestmentRequest): unknown {
    const obj: any = {};
    if (message.id !== 0) {
      obj.id = Math.round(message.id);
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.currentPrice !== 0) {
      obj.currentPrice = Math.round(message.currentPrice);
    }
    return obj;
  },

  create(base?: DeepPartial<UpdateInvestmentRequest>): UpdateInvestmentRequest {
    return UpdateInvestmentRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<UpdateInvestmentRequest>): UpdateInvestmentRequest {
    const message = createBaseUpdateInvestmentRequest();
    message.id = object.id ?? 0;
    message.name = object.name ?? "";
    message.currentPrice = object.currentPrice ?? 0;
    return message;
  },
};

function createBaseUpdateInvestmentResponse(): UpdateInvestmentResponse {
  return { success: false, message: "", data: undefined, timestamp: "" };
}

export const UpdateInvestmentResponse: MessageFns<UpdateInvestmentResponse> = {
  encode(message: UpdateInvestmentResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    if (message.message !== "") {
      writer.uint32(18).string(message.message);
    }
    if (message.data !== undefined) {
      Investment.encode(message.data, writer.uint32(26).fork()).join();
    }
    if (message.timestamp !== "") {
      writer.uint32(34).string(message.timestamp);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdateInvestmentResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateInvestmentResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.message = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.data = Investment.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.timestamp = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateInvestmentResponse {
    return {
      success: isSet(object.success) ? globalThis.Boolean(object.success) : false,
      message: isSet(object.message) ? globalThis.String(object.message) : "",
      data: isSet(object.data) ? Investment.fromJSON(object.data) : undefined,
      timestamp: isSet(object.timestamp) ? globalThis.String(object.timestamp) : "",
    };
  },

  toJSON(message: UpdateInvestmentResponse): unknown {
    const obj: any = {};
    if (message.success !== false) {
      obj.success = message.success;
    }
    if (message.message !== "") {
      obj.message = message.message;
    }
    if (message.data !== undefined) {
      obj.data = Investment.toJSON(message.data);
    }
    if (message.timestamp !== "") {
      obj.timestamp = message.timestamp;
    }
    return obj;
  },

  create(base?: DeepPartial<UpdateInvestmentResponse>): UpdateInvestmentResponse {
    return UpdateInvestmentResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<UpdateInvestmentResponse>): UpdateInvestmentResponse {
    const message = createBaseUpdateInvestmentResponse();
    message.success = object.success ?? false;
    message.message = object.message ?? "";
    message.data = (object.data !== undefined && object.data !== null)
      ? Investment.fromPartial(object.data)
      : undefined;
    message.timestamp = object.timestamp ?? "";
    return message;
  },
};

function createBaseDeleteInvestmentRequest(): DeleteInvestmentRequest {
  return { id: 0 };
}

export const DeleteInvestmentRequest: MessageFns<DeleteInvestmentRequest> = {
  encode(message: DeleteInvestmentRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== 0) {
      writer.uint32(8).int32(message.id);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteInvestmentRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteInvestmentRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.id = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeleteInvestmentRequest {
    return { id: isSet(object.id) ? globalThis.Number(object.id) : 0 };
  },

  toJSON(message: DeleteInvestmentRequest): unknown {
    const obj: any = {};
    if (message.id !== 0) {
      obj.id = Math.round(message.id);
    }
    return obj;
  },

  create(base?: DeepPartial<DeleteInvestmentRequest>): DeleteInvestmentRequest {
    return DeleteInvestmentRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DeleteInvestmentRequest>): DeleteInvestmentRequest {
    const message = createBaseDeleteInvestmentRequest();
    message.id = object.id ?? 0;
    return message;
  },
};

function createBaseDeleteInvestmentResponse(): DeleteInvestmentResponse {
  return { success: false, message: "", timestamp: "" };
}

export const DeleteInvestmentResponse: MessageFns<DeleteInvestmentResponse> = {
  encode(message: DeleteInvestmentResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    if (message.message !== "") {
      writer.uint32(18).string(message.message);
    }
    if (message.timestamp !== "") {
      writer.uint32(26).string(message.timestamp);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteInvestmentResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteInvestmentResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.message = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.timestamp = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeleteInvestmentResponse {
    return {
      success: isSet(object.success) ? globalThis.Boolean(object.success) : false,
      message: isSet(object.message) ? globalThis.String(object.message) : "",
      timestamp: isSet(object.timestamp) ? globalThis.String(object.timestamp) : "",
    };
  },

  toJSON(message: DeleteInvestmentResponse): unknown {
    const obj: any = {};
    if (message.success !== false) {
      obj.success = message.success;
    }
    if (message.message !== "") {
      obj.message = message.message;
    }
    if (message.timestamp !== "") {
      obj.timestamp = message.timestamp;
    }
    return obj;
  },

  create(base?: DeepPartial<DeleteInvestmentResponse>): DeleteInvestmentResponse {
    return DeleteInvestmentResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DeleteInvestmentResponse>): DeleteInvestmentResponse {
    const message = createBaseDeleteInvestmentResponse();
    message.success = object.success ?? false;
    message.message = object.message ?? "";
    message.timestamp = object.timestamp ?? "";
    return message;
  },
};

function createBaseAddTransactionRequest(): AddTransactionRequest {
  return { investmentId: 0, type: 0, quantity: 0, price: 0, fees: 0, transactionDate: 0, notes: "" };
}

export const AddTransactionRequest: MessageFns<AddTransactionRequest> = {
  encode(message: AddTransactionRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.investmentId !== 0) {
      writer.uint32(8).int32(message.investmentId);
    }
    if (message.type !== 0) {
      writer.uint32(16).int32(message.type);
    }
    if (message.quantity !== 0) {
      writer.uint32(24).int64(message.quantity);
    }
    if (message.price !== 0) {
      writer.uint32(32).int64(message.price);
    }
    if (message.fees !== 0) {
      writer.uint32(40).int64(message.fees);
    }
    if (message.transactionDate !== 0) {
      writer.uint32(48).int64(message.transactionDate);
    }
    if (message.notes !== "") {
      writer.uint32(58).string(message.notes);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AddTransactionRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAddTransactionRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.investmentId = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.type = reader.int32() as any;
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.quantity = longToNumber(reader.int64());
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.price = longToNumber(reader.int64());
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.fees = longToNumber(reader.int64());
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.transactionDate = longToNumber(reader.int64());
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.notes = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AddTransactionRequest {
    return {
      investmentId: isSet(object.investmentId) ? globalThis.Number(object.investmentId) : 0,
      type: isSet(object.type) ? investmentTransactionTypeFromJSON(object.type) : 0,
      quantity: isSet(object.quantity) ? globalThis.Number(object.quantity) : 0,
      price: isSet(object.price) ? globalThis.Number(object.price) : 0,
      fees: isSet(object.fees) ? globalThis.Number(object.fees) : 0,
      transactionDate: isSet(object.transactionDate) ? globalThis.Number(object.transactionDate) : 0,
      notes: isSet(object.notes) ? globalThis.String(object.notes) : "",
    };
  },

  toJSON(message: AddTransactionRequest): unknown {
    const obj: any = {};
    if (message.investmentId !== 0) {
      obj.investmentId = Math.round(message.investmentId);
    }
    if (message.type !== 0) {
      obj.type = investmentTransactionTypeToJSON(message.type);
    }
    if (message.quantity !== 0) {
      obj.quantity = Math.round(message.quantity);
    }
    if (message.price !== 0) {
      obj.price = Math.round(message.price);
    }
    if (message.fees !== 0) {
      obj.fees = Math.round(message.fees);
    }
    if (message.transactionDate !== 0) {
      obj.transactionDate = Math.round(message.transactionDate);
    }
    if (message.notes !== "") {
      obj.notes = message.notes;
    }
    return obj;
  },

  create(base?: DeepPartial<AddTransactionRequest>): AddTransactionRequest {
    return AddTransactionRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AddTransactionRequest>): AddTransactionRequest {
    const message = createBaseAddTransactionRequest();
    message.investmentId = object.investmentId ?? 0;
    message.type = object.type ?? 0;
    message.quantity = object.quantity ?? 0;
    message.price = object.price ?? 0;
    message.fees = object.fees ?? 0;
    message.transactionDate = object.transactionDate ?? 0;
    message.notes = object.notes ?? "";
    return message;
  },
};

function createBaseAddTransactionResponse(): AddTransactionResponse {
  return { success: false, message: "", data: undefined, updatedInvestment: undefined, timestamp: "" };
}

export const AddTransactionResponse: MessageFns<AddTransactionResponse> = {
  encode(message: AddTransactionResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    if (message.message !== "") {
      writer.uint32(18).string(message.message);
    }
    if (message.data !== undefined) {
      InvestmentTransaction.encode(message.data, writer.uint32(26).fork()).join();
    }
    if (message.updatedInvestment !== undefined) {
      Investment.encode(message.updatedInvestment, writer.uint32(34).fork()).join();
    }
    if (message.timestamp !== "") {
      writer.uint32(42).string(message.timestamp);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AddTransactionResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAddTransactionResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.message = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.data = InvestmentTransaction.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.updatedInvestment = Investment.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.timestamp = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AddTransactionResponse {
    return {
      success: isSet(object.success) ? globalThis.Boolean(object.success) : false,
      message: isSet(object.message) ? globalThis.String(object.message) : "",
      data: isSet(object.data) ? InvestmentTransaction.fromJSON(object.data) : undefined,
      updatedInvestment: isSet(object.updatedInvestment) ? Investment.fromJSON(object.updatedInvestment) : undefined,
      timestamp: isSet(object.timestamp) ? globalThis.String(object.timestamp) : "",
    };
  },

  toJSON(message: AddTransactionResponse): unknown {
    const obj: any = {};
    if (message.success !== false) {
      obj.success = message.success;
    }
    if (message.message !== "") {
      obj.message = message.message;
    }
    if (message.data !== undefined) {
      obj.data = InvestmentTransaction.toJSON(message.data);
    }
    if (message.updatedInvestment !== undefined) {
      obj.updatedInvestment = Investment.toJSON(message.updatedInvestment);
    }
    if (message.timestamp !== "") {
      obj.timestamp = message.timestamp;
    }
    return obj;
  },

  create(base?: DeepPartial<AddTransactionResponse>): AddTransactionResponse {
    return AddTransactionResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AddTransactionResponse>): AddTransactionResponse {
    const message = createBaseAddTransactionResponse();
    message.success = object.success ?? false;
    message.message = object.message ?? "";
    message.data = (object.data !== undefined && object.data !== null)
      ? InvestmentTransaction.fromPartial(object.data)
      : undefined;
    message.updatedInvestment = (object.updatedInvestment !== undefined && object.updatedInvestment !== null)
      ? Investment.fromPartial(object.updatedInvestment)
      : undefined;
    message.timestamp = object.timestamp ?? "";
    return message;
  },
};

function createBaseListInvestmentTransactionsRequest(): ListInvestmentTransactionsRequest {
  return { investmentId: 0, pagination: undefined, typeFilter: 0 };
}

export const ListInvestmentTransactionsRequest: MessageFns<ListInvestmentTransactionsRequest> = {
  encode(message: ListInvestmentTransactionsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.investmentId !== 0) {
      writer.uint32(8).int32(message.investmentId);
    }
    if (message.pagination !== undefined) {
      PaginationParams.encode(message.pagination, writer.uint32(18).fork()).join();
    }
    if (message.typeFilter !== 0) {
      writer.uint32(24).int32(message.typeFilter);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListInvestmentTransactionsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListInvestmentTransactionsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.investmentId = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.pagination = PaginationParams.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.typeFilter = reader.int32() as any;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListInvestmentTransactionsRequest {
    return {
      investmentId: isSet(object.investmentId) ? globalThis.Number(object.investmentId) : 0,
      pagination: isSet(object.pagination) ? PaginationParams.fromJSON(object.pagination) : undefined,
      typeFilter: isSet(object.typeFilter) ? investmentTransactionTypeFromJSON(object.typeFilter) : 0,
    };
  },

  toJSON(message: ListInvestmentTransactionsRequest): unknown {
    const obj: any = {};
    if (message.investmentId !== 0) {
      obj.investmentId = Math.round(message.investmentId);
    }
    if (message.pagination !== undefined) {
      obj.pagination = PaginationParams.toJSON(message.pagination);
    }
    if (message.typeFilter !== 0) {
      obj.typeFilter = investmentTransactionTypeToJSON(message.typeFilter);
    }
    return obj;
  },

  create(base?: DeepPartial<ListInvestmentTransactionsRequest>): ListInvestmentTransactionsRequest {
    return ListInvestmentTransactionsRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListInvestmentTransactionsRequest>): ListInvestmentTransactionsRequest {
    const message = createBaseListInvestmentTransactionsRequest();
    message.investmentId = object.investmentId ?? 0;
    message.pagination = (object.pagination !== undefined && object.pagination !== null)
      ? PaginationParams.fromPartial(object.pagination)
      : undefined;
    message.typeFilter = object.typeFilter ?? 0;
    return message;
  },
};

function createBaseListInvestmentTransactionsResponse(): ListInvestmentTransactionsResponse {
  return { success: false, message: "", data: [], timestamp: "", pagination: undefined };
}

export const ListInvestmentTransactionsResponse: MessageFns<ListInvestmentTransactionsResponse> = {
  encode(message: ListInvestmentTransactionsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    if (message.message !== "") {
      writer.uint32(18).string(message.message);
    }
    for (const v of message.data) {
      InvestmentTransaction.encode(v!, writer.uint32(26).fork()).join();
    }
    if (message.timestamp !== "") {
      writer.uint32(34).string(message.timestamp);
    }
    if (message.pagination !== undefined) {
      PaginationResult.encode(message.pagination, writer.uint32(42).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListInvestmentTransactionsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListInvestmentTransactionsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.message = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.data.push(InvestmentTransaction.decode(reader, reader.uint32()));
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.timestamp = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.pagination = PaginationResult.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListInvestmentTransactionsResponse {
    return {
      success: isSet(object.success) ? globalThis.Boolean(object.success) : false,
      message: isSet(object.message) ? globalThis.String(object.message) : "",
      data: globalThis.Array.isArray(object?.data)
        ? object.data.map((e: any) => InvestmentTransaction.fromJSON(e))
        : [],
      timestamp: isSet(object.timestamp) ? globalThis.String(object.timestamp) : "",
      pagination: isSet(object.pagination) ? PaginationResult.fromJSON(object.pagination) : undefined,
    };
  },

  toJSON(message: ListInvestmentTransactionsResponse): unknown {
    const obj: any = {};
    if (message.success !== false) {
      obj.success = message.success;
    }
    if (message.message !== "") {
      obj.message = message.message;
    }
    if (message.data?.length) {
      obj.data = message.data.map((e) => InvestmentTransaction.toJSON(e));
    }
    if (message.timestamp !== "") {
      obj.timestamp = message.timestamp;
    }
    if (message.pagination !== undefined) {
      obj.pagination = PaginationResult.toJSON(message.pagination);
    }
    return obj;
  },

  create(base?: DeepPartial<ListInvestmentTransactionsResponse>): ListInvestmentTransactionsResponse {
    return ListInvestmentTransactionsResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListInvestmentTransactionsResponse>): ListInvestmentTransactionsResponse {
    const message = createBaseListInvestmentTransactionsResponse();
    message.success = object.success ?? false;
    message.message = object.message ?? "";
    message.data = object.data?.map((e) => InvestmentTransaction.fromPartial(e)) || [];
    message.timestamp = object.timestamp ?? "";
    message.pagination = (object.pagination !== undefined && object.pagination !== null)
      ? PaginationResult.fromPartial(object.pagination)
      : undefined;
    return message;
  },
};

function createBaseEditInvestmentTransactionRequest(): EditInvestmentTransactionRequest {
  return { id: 0, quantity: 0, price: 0, fees: 0, transactionDate: 0, notes: "" };
}

export const EditInvestmentTransactionRequest: MessageFns<EditInvestmentTransactionRequest> = {
  encode(message: EditInvestmentTransactionRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== 0) {
      writer.uint32(8).int32(message.id);
    }
    if (message.quantity !== 0) {
      writer.uint32(16).int64(message.quantity);
    }
    if (message.price !== 0) {
      writer.uint32(24).int64(message.price);
    }
    if (message.fees !== 0) {
      writer.uint32(32).int64(message.fees);
    }
    if (message.transactionDate !== 0) {
      writer.uint32(40).int64(message.transactionDate);
    }
    if (message.notes !== "") {
      writer.uint32(50).string(message.notes);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EditInvestmentTransactionRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEditInvestmentTransactionRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.id = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.quantity = longToNumber(reader.int64());
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.price = longToNumber(reader.int64());
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.fees = longToNumber(reader.int64());
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.transactionDate = longToNumber(reader.int64());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.notes = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EditInvestmentTransactionRequest {
    return {
      id: isSet(object.id) ? globalThis.Number(object.id) : 0,
      quantity: isSet(object.quantity) ? globalThis.Number(object.quantity) : 0,
      price: isSet(object.price) ? globalThis.Number(object.price) : 0,
      fees: isSet(object.fees) ? globalThis.Number(object.fees) : 0,
      transactionDate: isSet(object.transactionDate) ? globalThis.Number(object.transactionDate) : 0,
      notes: isSet(object.notes) ? globalThis.String(object.notes) : "",
    };
  },

  toJSON(message: EditInvestmentTransactionRequest): unknown {
    const obj: any = {};
    if (message.id !== 0) {
      obj.id = Math.round(message.id);
    }
    if (message.quantity !== 0) {
      obj.quantity = Math.round(message.quantity);
    }
    if (message.price !== 0) {
      obj.price = Math.round(message.price);
    }
    if (message.fees !== 0) {
      obj.fees = Math.round(message.fees);
    }
    if (message.transactionDate !== 0) {
      obj.transactionDate = Math.round(message.transactionDate);
    }
    if (message.notes !== "") {
      obj.notes = message.notes;
    }
    return obj;
  },

  create(base?: DeepPartial<EditInvestmentTransactionRequest>): EditInvestmentTransactionRequest {
    return EditInvestmentTransactionRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<EditInvestmentTransactionRequest>): EditInvestmentTransactionRequest {
    const message = createBaseEditInvestmentTransactionRequest();
    message.id = object.id ?? 0;
    message.quantity = object.quantity ?? 0;
    message.price = object.price ?? 0;
    message.fees = object.fees ?? 0;
    message.transactionDate = object.transactionDate ?? 0;
    message.notes = object.notes ?? "";
    return message;
  },
};

function createBaseEditInvestmentTransactionResponse(): EditInvestmentTransactionResponse {
  return { success: false, message: "", data: undefined, timestamp: "" };
}

export const EditInvestmentTransactionResponse: MessageFns<EditInvestmentTransactionResponse> = {
  encode(message: EditInvestmentTransactionResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    if (message.message !== "") {
      writer.uint32(18).string(message.message);
    }
    if (message.data !== undefined) {
      InvestmentTransaction.encode(message.data, writer.uint32(26).fork()).join();
    }
    if (message.timestamp !== "") {
      writer.uint32(34).string(message.timestamp);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EditInvestmentTransactionResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEditInvestmentTransactionResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.message = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.data = InvestmentTransaction.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.timestamp = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EditInvestmentTransactionResponse {
    return {
      success: isSet(object.success) ? globalThis.Boolean(object.success) : false,
      message: isSet(object.message) ? globalThis.String(object.message) : "",
      data: isSet(object.data) ? InvestmentTransaction.fromJSON(object.data) : undefined,
      timestamp: isSet(object.timestamp) ? globalThis.String(object.timestamp) : "",
    };
  },

  toJSON(message: EditInvestmentTransactionResponse): unknown {
    const obj: any = {};
    if (message.success !== false) {
      obj.success = message.success;
    }
    if (message.message !== "") {
      obj.message = message.message;
    }
    if (message.data !== undefined) {
      obj.data = InvestmentTransaction.toJSON(message.data);
    }
    if (message.timestamp !== "") {
      obj.timestamp = message.timestamp;
    }
    return obj;
  },

  create(base?: DeepPartial<EditInvestmentTransactionResponse>): EditInvestmentTransactionResponse {
    return EditInvestmentTransactionResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<EditInvestmentTransactionResponse>): EditInvestmentTransactionResponse {
    const message = createBaseEditInvestmentTransactionResponse();
    message.success = object.success ?? false;
    message.message = object.message ?? "";
    message.data = (object.data !== undefined && object.data !== null)
      ? InvestmentTransaction.fromPartial(object.data)
      : undefined;
    message.timestamp = object.timestamp ?? "";
    return message;
  },
};

function createBaseDeleteInvestmentTransactionRequest(): DeleteInvestmentTransactionRequest {
  return { id: 0 };
}

export const DeleteInvestmentTransactionRequest: MessageFns<DeleteInvestmentTransactionRequest> = {
  encode(message: DeleteInvestmentTransactionRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== 0) {
      writer.uint32(8).int32(message.id);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteInvestmentTransactionRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteInvestmentTransactionRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.id = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeleteInvestmentTransactionRequest {
    return { id: isSet(object.id) ? globalThis.Number(object.id) : 0 };
  },

  toJSON(message: DeleteInvestmentTransactionRequest): unknown {
    const obj: any = {};
    if (message.id !== 0) {
      obj.id = Math.round(message.id);
    }
    return obj;
  },

  create(base?: DeepPartial<DeleteInvestmentTransactionRequest>): DeleteInvestmentTransactionRequest {
    return DeleteInvestmentTransactionRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DeleteInvestmentTransactionRequest>): DeleteInvestmentTransactionRequest {
    const message = createBaseDeleteInvestmentTransactionRequest();
    message.id = object.id ?? 0;
    return message;
  },
};

function createBaseDeleteInvestmentTransactionResponse(): DeleteInvestmentTransactionResponse {
  return { success: false, message: "", timestamp: "" };
}

export const DeleteInvestmentTransactionResponse: MessageFns<DeleteInvestmentTransactionResponse> = {
  encode(message: DeleteInvestmentTransactionResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    if (message.message !== "") {
      writer.uint32(18).string(message.message);
    }
    if (message.timestamp !== "") {
      writer.uint32(26).string(message.timestamp);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteInvestmentTransactionResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteInvestmentTransactionResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.message = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.timestamp = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeleteInvestmentTransactionResponse {
    return {
      success: isSet(object.success) ? globalThis.Boolean(object.success) : false,
      message: isSet(object.message) ? globalThis.String(object.message) : "",
      timestamp: isSet(object.timestamp) ? globalThis.String(object.timestamp) : "",
    };
  },

  toJSON(message: DeleteInvestmentTransactionResponse): unknown {
    const obj: any = {};
    if (message.success !== false) {
      obj.success = message.success;
    }
    if (message.message !== "") {
      obj.message = message.message;
    }
    if (message.timestamp !== "") {
      obj.timestamp = message.timestamp;
    }
    return obj;
  },

  create(base?: DeepPartial<DeleteInvestmentTransactionResponse>): DeleteInvestmentTransactionResponse {
    return DeleteInvestmentTransactionResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DeleteInvestmentTransactionResponse>): DeleteInvestmentTransactionResponse {
    const message = createBaseDeleteInvestmentTransactionResponse();
    message.success = object.success ?? false;
    message.message = object.message ?? "";
    message.timestamp = object.timestamp ?? "";
    return message;
  },
};

function createBaseGetPortfolioSummaryRequest(): GetPortfolioSummaryRequest {
  return { walletId: 0 };
}

export const GetPortfolioSummaryRequest: MessageFns<GetPortfolioSummaryRequest> = {
  encode(message: GetPortfolioSummaryRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.walletId !== 0) {
      writer.uint32(8).int32(message.walletId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetPortfolioSummaryRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetPortfolioSummaryRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.walletId = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetPortfolioSummaryRequest {
    return { walletId: isSet(object.walletId) ? globalThis.Number(object.walletId) : 0 };
  },

  toJSON(message: GetPortfolioSummaryRequest): unknown {
    const obj: any = {};
    if (message.walletId !== 0) {
      obj.walletId = Math.round(message.walletId);
    }
    return obj;
  },

  create(base?: DeepPartial<GetPortfolioSummaryRequest>): GetPortfolioSummaryRequest {
    return GetPortfolioSummaryRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetPortfolioSummaryRequest>): GetPortfolioSummaryRequest {
    const message = createBaseGetPortfolioSummaryRequest();
    message.walletId = object.walletId ?? 0;
    return message;
  },
};

function createBaseGetPortfolioSummaryResponse(): GetPortfolioSummaryResponse {
  return { success: false, message: "", data: undefined, timestamp: "" };
}

export const GetPortfolioSummaryResponse: MessageFns<GetPortfolioSummaryResponse> = {
  encode(message: GetPortfolioSummaryResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    if (message.message !== "") {
      writer.uint32(18).string(message.message);
    }
    if (message.data !== undefined) {
      PortfolioSummary.encode(message.data, writer.uint32(26).fork()).join();
    }
    if (message.timestamp !== "") {
      writer.uint32(34).string(message.timestamp);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetPortfolioSummaryResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetPortfolioSummaryResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.message = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.data = PortfolioSummary.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.timestamp = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetPortfolioSummaryResponse {
    return {
      success: isSet(object.success) ? globalThis.Boolean(object.success) : false,
      message: isSet(object.message) ? globalThis.String(object.message) : "",
      data: isSet(object.data) ? PortfolioSummary.fromJSON(object.data) : undefined,
      timestamp: isSet(object.timestamp) ? globalThis.String(object.timestamp) : "",
    };
  },

  toJSON(message: GetPortfolioSummaryResponse): unknown {
    const obj: any = {};
    if (message.success !== false) {
      obj.success = message.success;
    }
    if (message.message !== "") {
      obj.message = message.message;
    }
    if (message.data !== undefined) {
      obj.data = PortfolioSummary.toJSON(message.data);
    }
    if (message.timestamp !== "") {
      obj.timestamp = message.timestamp;
    }
    return obj;
  },

  create(base?: DeepPartial<GetPortfolioSummaryResponse>): GetPortfolioSummaryResponse {
    return GetPortfolioSummaryResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetPortfolioSummaryResponse>): GetPortfolioSummaryResponse {
    const message = createBaseGetPortfolioSummaryResponse();
    message.success = object.success ?? false;
    message.message = object.message ?? "";
    message.data = (object.data !== undefined && object.data !== null)
      ? PortfolioSummary.fromPartial(object.data)
      : undefined;
    message.timestamp = object.timestamp ?? "";
    return message;
  },
};

function createBaseUpdatePricesRequest(): UpdatePricesRequest {
  return { investmentIds: [], forceRefresh: false };
}

export const UpdatePricesRequest: MessageFns<UpdatePricesRequest> = {
  encode(message: UpdatePricesRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    writer.uint32(10).fork();
    for (const v of message.investmentIds) {
      writer.int32(v);
    }
    writer.join();
    if (message.forceRefresh !== false) {
      writer.uint32(16).bool(message.forceRefresh);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdatePricesRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdatePricesRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag === 8) {
            message.investmentIds.push(reader.int32());

            continue;
          }

          if (tag === 10) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.investmentIds.push(reader.int32());
            }

            continue;
          }

          break;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.forceRefresh = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdatePricesRequest {
    return {
      investmentIds: globalThis.Array.isArray(object?.investmentIds)
        ? object.investmentIds.map((e: any) => globalThis.Number(e))
        : [],
      forceRefresh: isSet(object.forceRefresh) ? globalThis.Boolean(object.forceRefresh) : false,
    };
  },

  toJSON(message: UpdatePricesRequest): unknown {
    const obj: any = {};
    if (message.investmentIds?.length) {
      obj.investmentIds = message.investmentIds.map((e) => Math.round(e));
    }
    if (message.forceRefresh !== false) {
      obj.forceRefresh = message.forceRefresh;
    }
    return obj;
  },

  create(base?: DeepPartial<UpdatePricesRequest>): UpdatePricesRequest {
    return UpdatePricesRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<UpdatePricesRequest>): UpdatePricesRequest {
    const message = createBaseUpdatePricesRequest();
    message.investmentIds = object.investmentIds?.map((e) => e) || [];
    message.forceRefresh = object.forceRefresh ?? false;
    return message;
  },
};

function createBaseUpdatePricesResponse(): UpdatePricesResponse {
  return { success: false, message: "", updatedInvestments: [], timestamp: "" };
}

export const UpdatePricesResponse: MessageFns<UpdatePricesResponse> = {
  encode(message: UpdatePricesResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    if (message.message !== "") {
      writer.uint32(18).string(message.message);
    }
    for (const v of message.updatedInvestments) {
      Investment.encode(v!, writer.uint32(26).fork()).join();
    }
    if (message.timestamp !== "") {
      writer.uint32(34).string(message.timestamp);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdatePricesResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdatePricesResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.message = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.updatedInvestments.push(Investment.decode(reader, reader.uint32()));
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.timestamp = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdatePricesResponse {
    return {
      success: isSet(object.success) ? globalThis.Boolean(object.success) : false,
      message: isSet(object.message) ? globalThis.String(object.message) : "",
      updatedInvestments: globalThis.Array.isArray(object?.updatedInvestments)
        ? object.updatedInvestments.map((e: any) => Investment.fromJSON(e))
        : [],
      timestamp: isSet(object.timestamp) ? globalThis.String(object.timestamp) : "",
    };
  },

  toJSON(message: UpdatePricesResponse): unknown {
    const obj: any = {};
    if (message.success !== false) {
      obj.success = message.success;
    }
    if (message.message !== "") {
      obj.message = message.message;
    }
    if (message.updatedInvestments?.length) {
      obj.updatedInvestments = message.updatedInvestments.map((e) => Investment.toJSON(e));
    }
    if (message.timestamp !== "") {
      obj.timestamp = message.timestamp;
    }
    return obj;
  },

  create(base?: DeepPartial<UpdatePricesResponse>): UpdatePricesResponse {
    return UpdatePricesResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<UpdatePricesResponse>): UpdatePricesResponse {
    const message = createBaseUpdatePricesResponse();
    message.success = object.success ?? false;
    message.message = object.message ?? "";
    message.updatedInvestments = object.updatedInvestments?.map((e) => Investment.fromPartial(e)) || [];
    message.timestamp = object.timestamp ?? "";
    return message;
  },
};

function createBaseSearchSymbolsRequest(): SearchSymbolsRequest {
  return { query: "", limit: 0 };
}

export const SearchSymbolsRequest: MessageFns<SearchSymbolsRequest> = {
  encode(message: SearchSymbolsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.query !== "") {
      writer.uint32(10).string(message.query);
    }
    if (message.limit !== 0) {
      writer.uint32(16).int32(message.limit);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SearchSymbolsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSearchSymbolsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.query = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.limit = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SearchSymbolsRequest {
    return {
      query: isSet(object.query) ? globalThis.String(object.query) : "",
      limit: isSet(object.limit) ? globalThis.Number(object.limit) : 0,
    };
  },

  toJSON(message: SearchSymbolsRequest): unknown {
    const obj: any = {};
    if (message.query !== "") {
      obj.query = message.query;
    }
    if (message.limit !== 0) {
      obj.limit = Math.round(message.limit);
    }
    return obj;
  },

  create(base?: DeepPartial<SearchSymbolsRequest>): SearchSymbolsRequest {
    return SearchSymbolsRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SearchSymbolsRequest>): SearchSymbolsRequest {
    const message = createBaseSearchSymbolsRequest();
    message.query = object.query ?? "";
    message.limit = object.limit ?? 0;
    return message;
  },
};

function createBaseSearchResult(): SearchResult {
  return { symbol: "", name: "", type: "", exchange: "", exchDisp: "" };
}

export const SearchResult: MessageFns<SearchResult> = {
  encode(message: SearchResult, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.symbol !== "") {
      writer.uint32(10).string(message.symbol);
    }
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    if (message.type !== "") {
      writer.uint32(26).string(message.type);
    }
    if (message.exchange !== "") {
      writer.uint32(34).string(message.exchange);
    }
    if (message.exchDisp !== "") {
      writer.uint32(42).string(message.exchDisp);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SearchResult {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSearchResult();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.symbol = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.type = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.exchange = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.exchDisp = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SearchResult {
    return {
      symbol: isSet(object.symbol) ? globalThis.String(object.symbol) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      type: isSet(object.type) ? globalThis.String(object.type) : "",
      exchange: isSet(object.exchange) ? globalThis.String(object.exchange) : "",
      exchDisp: isSet(object.exchDisp) ? globalThis.String(object.exchDisp) : "",
    };
  },

  toJSON(message: SearchResult): unknown {
    const obj: any = {};
    if (message.symbol !== "") {
      obj.symbol = message.symbol;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.type !== "") {
      obj.type = message.type;
    }
    if (message.exchange !== "") {
      obj.exchange = message.exchange;
    }
    if (message.exchDisp !== "") {
      obj.exchDisp = message.exchDisp;
    }
    return obj;
  },

  create(base?: DeepPartial<SearchResult>): SearchResult {
    return SearchResult.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SearchResult>): SearchResult {
    const message = createBaseSearchResult();
    message.symbol = object.symbol ?? "";
    message.name = object.name ?? "";
    message.type = object.type ?? "";
    message.exchange = object.exchange ?? "";
    message.exchDisp = object.exchDisp ?? "";
    return message;
  },
};

function createBaseSearchSymbolsResponse(): SearchSymbolsResponse {
  return { success: false, message: "", data: [], timestamp: "" };
}

export const SearchSymbolsResponse: MessageFns<SearchSymbolsResponse> = {
  encode(message: SearchSymbolsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    if (message.message !== "") {
      writer.uint32(18).string(message.message);
    }
    for (const v of message.data) {
      SearchResult.encode(v!, writer.uint32(26).fork()).join();
    }
    if (message.timestamp !== "") {
      writer.uint32(34).string(message.timestamp);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SearchSymbolsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSearchSymbolsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.message = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.data.push(SearchResult.decode(reader, reader.uint32()));
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.timestamp = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SearchSymbolsResponse {
    return {
      success: isSet(object.success) ? globalThis.Boolean(object.success) : false,
      message: isSet(object.message) ? globalThis.String(object.message) : "",
      data: globalThis.Array.isArray(object?.data) ? object.data.map((e: any) => SearchResult.fromJSON(e)) : [],
      timestamp: isSet(object.timestamp) ? globalThis.String(object.timestamp) : "",
    };
  },

  toJSON(message: SearchSymbolsResponse): unknown {
    const obj: any = {};
    if (message.success !== false) {
      obj.success = message.success;
    }
    if (message.message !== "") {
      obj.message = message.message;
    }
    if (message.data?.length) {
      obj.data = message.data.map((e) => SearchResult.toJSON(e));
    }
    if (message.timestamp !== "") {
      obj.timestamp = message.timestamp;
    }
    return obj;
  },

  create(base?: DeepPartial<SearchSymbolsResponse>): SearchSymbolsResponse {
    return SearchSymbolsResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SearchSymbolsResponse>): SearchSymbolsResponse {
    const message = createBaseSearchSymbolsResponse();
    message.success = object.success ?? false;
    message.message = object.message ?? "";
    message.data = object.data?.map((e) => SearchResult.fromPartial(e)) || [];
    message.timestamp = object.timestamp ?? "";
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends { $case: string } ? { [K in keyof Omit<T, "$case">]?: DeepPartial<T[K]> } & { $case: T["$case"] }
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function longToNumber(int64: { toString(): string }): number {
  const num = globalThis.Number(int64.toString());
  if (num > globalThis.Number.MAX_SAFE_INTEGER) {
    throw new globalThis.Error("Value is larger than Number.MAX_SAFE_INTEGER");
  }
  if (num < globalThis.Number.MIN_SAFE_INTEGER) {
    throw new globalThis.Error("Value is smaller than Number.MIN_SAFE_INTEGER");
  }
  return num;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
