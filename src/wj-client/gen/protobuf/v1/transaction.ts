// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.11.0
//   protoc               unknown
// source: protobuf/v1/transaction.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import { Money, PaginationParams, PaginationResult } from "./common";

export const protobufPackage = "wealthjourney.transaction.v1";

/** Enums */
export const TransactionType = {
  TRANSACTION_TYPE_UNSPECIFIED: 0,
  TRANSACTION_TYPE_INCOME: 1,
  TRANSACTION_TYPE_EXPENSE: 2,
  UNRECOGNIZED: -1,
} as const;

export type TransactionType = typeof TransactionType[keyof typeof TransactionType];

export namespace TransactionType {
  export type TRANSACTION_TYPE_UNSPECIFIED = typeof TransactionType.TRANSACTION_TYPE_UNSPECIFIED;
  export type TRANSACTION_TYPE_INCOME = typeof TransactionType.TRANSACTION_TYPE_INCOME;
  export type TRANSACTION_TYPE_EXPENSE = typeof TransactionType.TRANSACTION_TYPE_EXPENSE;
  export type UNRECOGNIZED = typeof TransactionType.UNRECOGNIZED;
}

export function transactionTypeFromJSON(object: any): TransactionType {
  switch (object) {
    case 0:
    case "TRANSACTION_TYPE_UNSPECIFIED":
      return TransactionType.TRANSACTION_TYPE_UNSPECIFIED;
    case 1:
    case "TRANSACTION_TYPE_INCOME":
      return TransactionType.TRANSACTION_TYPE_INCOME;
    case 2:
    case "TRANSACTION_TYPE_EXPENSE":
      return TransactionType.TRANSACTION_TYPE_EXPENSE;
    case -1:
    case "UNRECOGNIZED":
    default:
      return TransactionType.UNRECOGNIZED;
  }
}

export function transactionTypeToJSON(object: TransactionType): string {
  switch (object) {
    case TransactionType.TRANSACTION_TYPE_UNSPECIFIED:
      return "TRANSACTION_TYPE_UNSPECIFIED";
    case TransactionType.TRANSACTION_TYPE_INCOME:
      return "TRANSACTION_TYPE_INCOME";
    case TransactionType.TRANSACTION_TYPE_EXPENSE:
      return "TRANSACTION_TYPE_EXPENSE";
    case TransactionType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export const CategoryType = {
  CATEGORY_TYPE_UNSPECIFIED: 0,
  CATEGORY_TYPE_INCOME: 1,
  CATEGORY_TYPE_EXPENSE: 2,
  UNRECOGNIZED: -1,
} as const;

export type CategoryType = typeof CategoryType[keyof typeof CategoryType];

export namespace CategoryType {
  export type CATEGORY_TYPE_UNSPECIFIED = typeof CategoryType.CATEGORY_TYPE_UNSPECIFIED;
  export type CATEGORY_TYPE_INCOME = typeof CategoryType.CATEGORY_TYPE_INCOME;
  export type CATEGORY_TYPE_EXPENSE = typeof CategoryType.CATEGORY_TYPE_EXPENSE;
  export type UNRECOGNIZED = typeof CategoryType.UNRECOGNIZED;
}

export function categoryTypeFromJSON(object: any): CategoryType {
  switch (object) {
    case 0:
    case "CATEGORY_TYPE_UNSPECIFIED":
      return CategoryType.CATEGORY_TYPE_UNSPECIFIED;
    case 1:
    case "CATEGORY_TYPE_INCOME":
      return CategoryType.CATEGORY_TYPE_INCOME;
    case 2:
    case "CATEGORY_TYPE_EXPENSE":
      return CategoryType.CATEGORY_TYPE_EXPENSE;
    case -1:
    case "UNRECOGNIZED":
    default:
      return CategoryType.UNRECOGNIZED;
  }
}

export function categoryTypeToJSON(object: CategoryType): string {
  switch (object) {
    case CategoryType.CATEGORY_TYPE_UNSPECIFIED:
      return "CATEGORY_TYPE_UNSPECIFIED";
    case CategoryType.CATEGORY_TYPE_INCOME:
      return "CATEGORY_TYPE_INCOME";
    case CategoryType.CATEGORY_TYPE_EXPENSE:
      return "CATEGORY_TYPE_EXPENSE";
    case CategoryType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export const SortField = {
  SORT_FIELD_UNSPECIFIED: 0,
  DATE: 1,
  AMOUNT: 2,
  CREATED_AT: 3,
  UPDATED_AT: 4,
  UNRECOGNIZED: -1,
} as const;

export type SortField = typeof SortField[keyof typeof SortField];

export namespace SortField {
  export type SORT_FIELD_UNSPECIFIED = typeof SortField.SORT_FIELD_UNSPECIFIED;
  export type DATE = typeof SortField.DATE;
  export type AMOUNT = typeof SortField.AMOUNT;
  export type CREATED_AT = typeof SortField.CREATED_AT;
  export type UPDATED_AT = typeof SortField.UPDATED_AT;
  export type UNRECOGNIZED = typeof SortField.UNRECOGNIZED;
}

export function sortFieldFromJSON(object: any): SortField {
  switch (object) {
    case 0:
    case "SORT_FIELD_UNSPECIFIED":
      return SortField.SORT_FIELD_UNSPECIFIED;
    case 1:
    case "DATE":
      return SortField.DATE;
    case 2:
    case "AMOUNT":
      return SortField.AMOUNT;
    case 3:
    case "CREATED_AT":
      return SortField.CREATED_AT;
    case 4:
    case "UPDATED_AT":
      return SortField.UPDATED_AT;
    case -1:
    case "UNRECOGNIZED":
    default:
      return SortField.UNRECOGNIZED;
  }
}

export function sortFieldToJSON(object: SortField): string {
  switch (object) {
    case SortField.SORT_FIELD_UNSPECIFIED:
      return "SORT_FIELD_UNSPECIFIED";
    case SortField.DATE:
      return "DATE";
    case SortField.AMOUNT:
      return "AMOUNT";
    case SortField.CREATED_AT:
      return "CREATED_AT";
    case SortField.UPDATED_AT:
      return "UPDATED_AT";
    case SortField.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Transaction message */
export interface Transaction {
  id: number;
  walletId: number;
  categoryId: number;
  amount: Money | undefined;
  date: number;
  note: string;
  createdAt: number;
  updatedAt: number;
}

/** Category message */
export interface Category {
  id: number;
  userId: number;
  name: string;
  type: CategoryType;
  createdAt: number;
  updatedAt: number;
}

/** TransactionFilter for advanced filtering */
export interface TransactionFilter {
  walletId?: number | undefined;
  categoryId?: number | undefined;
  type?: TransactionType | undefined;
  startDate?: number | undefined;
  endDate?: number | undefined;
  minAmount?: number | undefined;
  maxAmount?: number | undefined;
  searchNote?: string | undefined;
}

/** GetTransaction request */
export interface GetTransactionRequest {
  transactionId: number;
}

/** ListTransactions request */
export interface ListTransactionsRequest {
  pagination: PaginationParams | undefined;
  filter: TransactionFilter | undefined;
  sortField: SortField;
  /** "asc" or "desc" */
  sortOrder: string;
}

/** CreateTransaction request */
export interface CreateTransactionRequest {
  walletId: number;
  categoryId?: number | undefined;
  amount: Money | undefined;
  date?: number | undefined;
  note?: string | undefined;
}

/** UpdateTransaction request */
export interface UpdateTransactionRequest {
  transactionId: number;
  walletId?: number | undefined;
  categoryId?: number | undefined;
  amount?: Money | undefined;
  date?: number | undefined;
  note?: string | undefined;
}

/** DeleteTransaction request */
export interface DeleteTransactionRequest {
  transactionId: number;
}

/** GetTransaction response */
export interface GetTransactionResponse {
  success: boolean;
  message: string;
  data: Transaction | undefined;
  timestamp: string;
}

/** ListTransactions response */
export interface ListTransactionsResponse {
  success: boolean;
  message: string;
  transactions: Transaction[];
  pagination: PaginationResult | undefined;
  timestamp: string;
}

/** CreateTransaction response */
export interface CreateTransactionResponse {
  success: boolean;
  message: string;
  data: Transaction | undefined;
  newBalance: Money | undefined;
  timestamp: string;
}

/** UpdateTransaction response */
export interface UpdateTransactionResponse {
  success: boolean;
  message: string;
  data: Transaction | undefined;
  newBalance: Money | undefined;
  timestamp: string;
}

/** DeleteTransaction response */
export interface DeleteTransactionResponse {
  success: boolean;
  message: string;
  newBalance: Money | undefined;
  timestamp: string;
}

/** GetCategory request */
export interface GetCategoryRequest {
  categoryId: number;
}

/** ListCategories request */
export interface ListCategoriesRequest {
  pagination: PaginationParams | undefined;
  type?: CategoryType | undefined;
}

/** CreateCategory request */
export interface CreateCategoryRequest {
  name: string;
  type: CategoryType;
}

/** UpdateCategory request */
export interface UpdateCategoryRequest {
  categoryId: number;
  name: string;
}

/** DeleteCategory request */
export interface DeleteCategoryRequest {
  categoryId: number;
}

/** GetCategory response */
export interface GetCategoryResponse {
  success: boolean;
  message: string;
  data: Category | undefined;
  timestamp: string;
}

/** ListCategories response */
export interface ListCategoriesResponse {
  success: boolean;
  message: string;
  categories: Category[];
  pagination: PaginationResult | undefined;
  timestamp: string;
}

/** CreateCategory response */
export interface CreateCategoryResponse {
  success: boolean;
  message: string;
  data: Category | undefined;
  timestamp: string;
}

/** UpdateCategory response */
export interface UpdateCategoryResponse {
  success: boolean;
  message: string;
  data: Category | undefined;
  timestamp: string;
}

/** DeleteCategory response */
export interface DeleteCategoryResponse {
  success: boolean;
  message: string;
  timestamp: string;
}

/** GetAvailableYears request */
export interface GetAvailableYearsRequest {
}

/** GetAvailableYears response */
export interface GetAvailableYearsResponse {
  success: boolean;
  message: string;
  years: number[];
  timestamp: string;
}

function createBaseTransaction(): Transaction {
  return { id: 0, walletId: 0, categoryId: 0, amount: undefined, date: 0, note: "", createdAt: 0, updatedAt: 0 };
}

export const Transaction: MessageFns<Transaction> = {
  encode(message: Transaction, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== 0) {
      writer.uint32(8).int32(message.id);
    }
    if (message.walletId !== 0) {
      writer.uint32(16).int32(message.walletId);
    }
    if (message.categoryId !== 0) {
      writer.uint32(24).int32(message.categoryId);
    }
    if (message.amount !== undefined) {
      Money.encode(message.amount, writer.uint32(34).fork()).join();
    }
    if (message.date !== 0) {
      writer.uint32(40).int64(message.date);
    }
    if (message.note !== "") {
      writer.uint32(50).string(message.note);
    }
    if (message.createdAt !== 0) {
      writer.uint32(56).int64(message.createdAt);
    }
    if (message.updatedAt !== 0) {
      writer.uint32(64).int64(message.updatedAt);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Transaction {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTransaction();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.id = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.walletId = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.categoryId = reader.int32();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.amount = Money.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.date = longToNumber(reader.int64());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.note = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.createdAt = longToNumber(reader.int64());
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.updatedAt = longToNumber(reader.int64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Transaction {
    return {
      id: isSet(object.id) ? globalThis.Number(object.id) : 0,
      walletId: isSet(object.walletId) ? globalThis.Number(object.walletId) : 0,
      categoryId: isSet(object.categoryId) ? globalThis.Number(object.categoryId) : 0,
      amount: isSet(object.amount) ? Money.fromJSON(object.amount) : undefined,
      date: isSet(object.date) ? globalThis.Number(object.date) : 0,
      note: isSet(object.note) ? globalThis.String(object.note) : "",
      createdAt: isSet(object.createdAt) ? globalThis.Number(object.createdAt) : 0,
      updatedAt: isSet(object.updatedAt) ? globalThis.Number(object.updatedAt) : 0,
    };
  },

  toJSON(message: Transaction): unknown {
    const obj: any = {};
    if (message.id !== 0) {
      obj.id = Math.round(message.id);
    }
    if (message.walletId !== 0) {
      obj.walletId = Math.round(message.walletId);
    }
    if (message.categoryId !== 0) {
      obj.categoryId = Math.round(message.categoryId);
    }
    if (message.amount !== undefined) {
      obj.amount = Money.toJSON(message.amount);
    }
    if (message.date !== 0) {
      obj.date = Math.round(message.date);
    }
    if (message.note !== "") {
      obj.note = message.note;
    }
    if (message.createdAt !== 0) {
      obj.createdAt = Math.round(message.createdAt);
    }
    if (message.updatedAt !== 0) {
      obj.updatedAt = Math.round(message.updatedAt);
    }
    return obj;
  },

  create(base?: DeepPartial<Transaction>): Transaction {
    return Transaction.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Transaction>): Transaction {
    const message = createBaseTransaction();
    message.id = object.id ?? 0;
    message.walletId = object.walletId ?? 0;
    message.categoryId = object.categoryId ?? 0;
    message.amount = (object.amount !== undefined && object.amount !== null)
      ? Money.fromPartial(object.amount)
      : undefined;
    message.date = object.date ?? 0;
    message.note = object.note ?? "";
    message.createdAt = object.createdAt ?? 0;
    message.updatedAt = object.updatedAt ?? 0;
    return message;
  },
};

function createBaseCategory(): Category {
  return { id: 0, userId: 0, name: "", type: 0, createdAt: 0, updatedAt: 0 };
}

export const Category: MessageFns<Category> = {
  encode(message: Category, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== 0) {
      writer.uint32(8).int32(message.id);
    }
    if (message.userId !== 0) {
      writer.uint32(16).int32(message.userId);
    }
    if (message.name !== "") {
      writer.uint32(26).string(message.name);
    }
    if (message.type !== 0) {
      writer.uint32(32).int32(message.type);
    }
    if (message.createdAt !== 0) {
      writer.uint32(40).int64(message.createdAt);
    }
    if (message.updatedAt !== 0) {
      writer.uint32(48).int64(message.updatedAt);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Category {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCategory();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.id = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.userId = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.type = reader.int32() as any;
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.createdAt = longToNumber(reader.int64());
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.updatedAt = longToNumber(reader.int64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Category {
    return {
      id: isSet(object.id) ? globalThis.Number(object.id) : 0,
      userId: isSet(object.userId) ? globalThis.Number(object.userId) : 0,
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      type: isSet(object.type) ? categoryTypeFromJSON(object.type) : 0,
      createdAt: isSet(object.createdAt) ? globalThis.Number(object.createdAt) : 0,
      updatedAt: isSet(object.updatedAt) ? globalThis.Number(object.updatedAt) : 0,
    };
  },

  toJSON(message: Category): unknown {
    const obj: any = {};
    if (message.id !== 0) {
      obj.id = Math.round(message.id);
    }
    if (message.userId !== 0) {
      obj.userId = Math.round(message.userId);
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.type !== 0) {
      obj.type = categoryTypeToJSON(message.type);
    }
    if (message.createdAt !== 0) {
      obj.createdAt = Math.round(message.createdAt);
    }
    if (message.updatedAt !== 0) {
      obj.updatedAt = Math.round(message.updatedAt);
    }
    return obj;
  },

  create(base?: DeepPartial<Category>): Category {
    return Category.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Category>): Category {
    const message = createBaseCategory();
    message.id = object.id ?? 0;
    message.userId = object.userId ?? 0;
    message.name = object.name ?? "";
    message.type = object.type ?? 0;
    message.createdAt = object.createdAt ?? 0;
    message.updatedAt = object.updatedAt ?? 0;
    return message;
  },
};

function createBaseTransactionFilter(): TransactionFilter {
  return {
    walletId: undefined,
    categoryId: undefined,
    type: undefined,
    startDate: undefined,
    endDate: undefined,
    minAmount: undefined,
    maxAmount: undefined,
    searchNote: undefined,
  };
}

export const TransactionFilter: MessageFns<TransactionFilter> = {
  encode(message: TransactionFilter, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.walletId !== undefined) {
      writer.uint32(8).int32(message.walletId);
    }
    if (message.categoryId !== undefined) {
      writer.uint32(16).int32(message.categoryId);
    }
    if (message.type !== undefined) {
      writer.uint32(24).int32(message.type);
    }
    if (message.startDate !== undefined) {
      writer.uint32(32).int64(message.startDate);
    }
    if (message.endDate !== undefined) {
      writer.uint32(40).int64(message.endDate);
    }
    if (message.minAmount !== undefined) {
      writer.uint32(48).int64(message.minAmount);
    }
    if (message.maxAmount !== undefined) {
      writer.uint32(56).int64(message.maxAmount);
    }
    if (message.searchNote !== undefined) {
      writer.uint32(66).string(message.searchNote);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TransactionFilter {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTransactionFilter();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.walletId = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.categoryId = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.type = reader.int32() as any;
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.startDate = longToNumber(reader.int64());
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.endDate = longToNumber(reader.int64());
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.minAmount = longToNumber(reader.int64());
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.maxAmount = longToNumber(reader.int64());
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.searchNote = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TransactionFilter {
    return {
      walletId: isSet(object.walletId) ? globalThis.Number(object.walletId) : undefined,
      categoryId: isSet(object.categoryId) ? globalThis.Number(object.categoryId) : undefined,
      type: isSet(object.type) ? transactionTypeFromJSON(object.type) : undefined,
      startDate: isSet(object.startDate) ? globalThis.Number(object.startDate) : undefined,
      endDate: isSet(object.endDate) ? globalThis.Number(object.endDate) : undefined,
      minAmount: isSet(object.minAmount) ? globalThis.Number(object.minAmount) : undefined,
      maxAmount: isSet(object.maxAmount) ? globalThis.Number(object.maxAmount) : undefined,
      searchNote: isSet(object.searchNote) ? globalThis.String(object.searchNote) : undefined,
    };
  },

  toJSON(message: TransactionFilter): unknown {
    const obj: any = {};
    if (message.walletId !== undefined) {
      obj.walletId = Math.round(message.walletId);
    }
    if (message.categoryId !== undefined) {
      obj.categoryId = Math.round(message.categoryId);
    }
    if (message.type !== undefined) {
      obj.type = transactionTypeToJSON(message.type);
    }
    if (message.startDate !== undefined) {
      obj.startDate = Math.round(message.startDate);
    }
    if (message.endDate !== undefined) {
      obj.endDate = Math.round(message.endDate);
    }
    if (message.minAmount !== undefined) {
      obj.minAmount = Math.round(message.minAmount);
    }
    if (message.maxAmount !== undefined) {
      obj.maxAmount = Math.round(message.maxAmount);
    }
    if (message.searchNote !== undefined) {
      obj.searchNote = message.searchNote;
    }
    return obj;
  },

  create(base?: DeepPartial<TransactionFilter>): TransactionFilter {
    return TransactionFilter.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TransactionFilter>): TransactionFilter {
    const message = createBaseTransactionFilter();
    message.walletId = object.walletId ?? undefined;
    message.categoryId = object.categoryId ?? undefined;
    message.type = object.type ?? undefined;
    message.startDate = object.startDate ?? undefined;
    message.endDate = object.endDate ?? undefined;
    message.minAmount = object.minAmount ?? undefined;
    message.maxAmount = object.maxAmount ?? undefined;
    message.searchNote = object.searchNote ?? undefined;
    return message;
  },
};

function createBaseGetTransactionRequest(): GetTransactionRequest {
  return { transactionId: 0 };
}

export const GetTransactionRequest: MessageFns<GetTransactionRequest> = {
  encode(message: GetTransactionRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.transactionId !== 0) {
      writer.uint32(8).int32(message.transactionId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetTransactionRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetTransactionRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.transactionId = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetTransactionRequest {
    return { transactionId: isSet(object.transactionId) ? globalThis.Number(object.transactionId) : 0 };
  },

  toJSON(message: GetTransactionRequest): unknown {
    const obj: any = {};
    if (message.transactionId !== 0) {
      obj.transactionId = Math.round(message.transactionId);
    }
    return obj;
  },

  create(base?: DeepPartial<GetTransactionRequest>): GetTransactionRequest {
    return GetTransactionRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetTransactionRequest>): GetTransactionRequest {
    const message = createBaseGetTransactionRequest();
    message.transactionId = object.transactionId ?? 0;
    return message;
  },
};

function createBaseListTransactionsRequest(): ListTransactionsRequest {
  return { pagination: undefined, filter: undefined, sortField: 0, sortOrder: "" };
}

export const ListTransactionsRequest: MessageFns<ListTransactionsRequest> = {
  encode(message: ListTransactionsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.pagination !== undefined) {
      PaginationParams.encode(message.pagination, writer.uint32(10).fork()).join();
    }
    if (message.filter !== undefined) {
      TransactionFilter.encode(message.filter, writer.uint32(18).fork()).join();
    }
    if (message.sortField !== 0) {
      writer.uint32(24).int32(message.sortField);
    }
    if (message.sortOrder !== "") {
      writer.uint32(34).string(message.sortOrder);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListTransactionsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListTransactionsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.pagination = PaginationParams.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.filter = TransactionFilter.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.sortField = reader.int32() as any;
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.sortOrder = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListTransactionsRequest {
    return {
      pagination: isSet(object.pagination) ? PaginationParams.fromJSON(object.pagination) : undefined,
      filter: isSet(object.filter) ? TransactionFilter.fromJSON(object.filter) : undefined,
      sortField: isSet(object.sortField) ? sortFieldFromJSON(object.sortField) : 0,
      sortOrder: isSet(object.sortOrder) ? globalThis.String(object.sortOrder) : "",
    };
  },

  toJSON(message: ListTransactionsRequest): unknown {
    const obj: any = {};
    if (message.pagination !== undefined) {
      obj.pagination = PaginationParams.toJSON(message.pagination);
    }
    if (message.filter !== undefined) {
      obj.filter = TransactionFilter.toJSON(message.filter);
    }
    if (message.sortField !== 0) {
      obj.sortField = sortFieldToJSON(message.sortField);
    }
    if (message.sortOrder !== "") {
      obj.sortOrder = message.sortOrder;
    }
    return obj;
  },

  create(base?: DeepPartial<ListTransactionsRequest>): ListTransactionsRequest {
    return ListTransactionsRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListTransactionsRequest>): ListTransactionsRequest {
    const message = createBaseListTransactionsRequest();
    message.pagination = (object.pagination !== undefined && object.pagination !== null)
      ? PaginationParams.fromPartial(object.pagination)
      : undefined;
    message.filter = (object.filter !== undefined && object.filter !== null)
      ? TransactionFilter.fromPartial(object.filter)
      : undefined;
    message.sortField = object.sortField ?? 0;
    message.sortOrder = object.sortOrder ?? "";
    return message;
  },
};

function createBaseCreateTransactionRequest(): CreateTransactionRequest {
  return { walletId: 0, categoryId: undefined, amount: undefined, date: undefined, note: undefined };
}

export const CreateTransactionRequest: MessageFns<CreateTransactionRequest> = {
  encode(message: CreateTransactionRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.walletId !== 0) {
      writer.uint32(8).int32(message.walletId);
    }
    if (message.categoryId !== undefined) {
      writer.uint32(16).int32(message.categoryId);
    }
    if (message.amount !== undefined) {
      Money.encode(message.amount, writer.uint32(26).fork()).join();
    }
    if (message.date !== undefined) {
      writer.uint32(32).int64(message.date);
    }
    if (message.note !== undefined) {
      writer.uint32(42).string(message.note);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateTransactionRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateTransactionRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.walletId = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.categoryId = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.amount = Money.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.date = longToNumber(reader.int64());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.note = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateTransactionRequest {
    return {
      walletId: isSet(object.walletId) ? globalThis.Number(object.walletId) : 0,
      categoryId: isSet(object.categoryId) ? globalThis.Number(object.categoryId) : undefined,
      amount: isSet(object.amount) ? Money.fromJSON(object.amount) : undefined,
      date: isSet(object.date) ? globalThis.Number(object.date) : undefined,
      note: isSet(object.note) ? globalThis.String(object.note) : undefined,
    };
  },

  toJSON(message: CreateTransactionRequest): unknown {
    const obj: any = {};
    if (message.walletId !== 0) {
      obj.walletId = Math.round(message.walletId);
    }
    if (message.categoryId !== undefined) {
      obj.categoryId = Math.round(message.categoryId);
    }
    if (message.amount !== undefined) {
      obj.amount = Money.toJSON(message.amount);
    }
    if (message.date !== undefined) {
      obj.date = Math.round(message.date);
    }
    if (message.note !== undefined) {
      obj.note = message.note;
    }
    return obj;
  },

  create(base?: DeepPartial<CreateTransactionRequest>): CreateTransactionRequest {
    return CreateTransactionRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CreateTransactionRequest>): CreateTransactionRequest {
    const message = createBaseCreateTransactionRequest();
    message.walletId = object.walletId ?? 0;
    message.categoryId = object.categoryId ?? undefined;
    message.amount = (object.amount !== undefined && object.amount !== null)
      ? Money.fromPartial(object.amount)
      : undefined;
    message.date = object.date ?? undefined;
    message.note = object.note ?? undefined;
    return message;
  },
};

function createBaseUpdateTransactionRequest(): UpdateTransactionRequest {
  return {
    transactionId: 0,
    walletId: undefined,
    categoryId: undefined,
    amount: undefined,
    date: undefined,
    note: undefined,
  };
}

export const UpdateTransactionRequest: MessageFns<UpdateTransactionRequest> = {
  encode(message: UpdateTransactionRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.transactionId !== 0) {
      writer.uint32(8).int32(message.transactionId);
    }
    if (message.walletId !== undefined) {
      writer.uint32(16).int32(message.walletId);
    }
    if (message.categoryId !== undefined) {
      writer.uint32(24).int32(message.categoryId);
    }
    if (message.amount !== undefined) {
      Money.encode(message.amount, writer.uint32(34).fork()).join();
    }
    if (message.date !== undefined) {
      writer.uint32(40).int64(message.date);
    }
    if (message.note !== undefined) {
      writer.uint32(50).string(message.note);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdateTransactionRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateTransactionRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.transactionId = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.walletId = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.categoryId = reader.int32();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.amount = Money.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.date = longToNumber(reader.int64());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.note = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateTransactionRequest {
    return {
      transactionId: isSet(object.transactionId) ? globalThis.Number(object.transactionId) : 0,
      walletId: isSet(object.walletId) ? globalThis.Number(object.walletId) : undefined,
      categoryId: isSet(object.categoryId) ? globalThis.Number(object.categoryId) : undefined,
      amount: isSet(object.amount) ? Money.fromJSON(object.amount) : undefined,
      date: isSet(object.date) ? globalThis.Number(object.date) : undefined,
      note: isSet(object.note) ? globalThis.String(object.note) : undefined,
    };
  },

  toJSON(message: UpdateTransactionRequest): unknown {
    const obj: any = {};
    if (message.transactionId !== 0) {
      obj.transactionId = Math.round(message.transactionId);
    }
    if (message.walletId !== undefined) {
      obj.walletId = Math.round(message.walletId);
    }
    if (message.categoryId !== undefined) {
      obj.categoryId = Math.round(message.categoryId);
    }
    if (message.amount !== undefined) {
      obj.amount = Money.toJSON(message.amount);
    }
    if (message.date !== undefined) {
      obj.date = Math.round(message.date);
    }
    if (message.note !== undefined) {
      obj.note = message.note;
    }
    return obj;
  },

  create(base?: DeepPartial<UpdateTransactionRequest>): UpdateTransactionRequest {
    return UpdateTransactionRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<UpdateTransactionRequest>): UpdateTransactionRequest {
    const message = createBaseUpdateTransactionRequest();
    message.transactionId = object.transactionId ?? 0;
    message.walletId = object.walletId ?? undefined;
    message.categoryId = object.categoryId ?? undefined;
    message.amount = (object.amount !== undefined && object.amount !== null)
      ? Money.fromPartial(object.amount)
      : undefined;
    message.date = object.date ?? undefined;
    message.note = object.note ?? undefined;
    return message;
  },
};

function createBaseDeleteTransactionRequest(): DeleteTransactionRequest {
  return { transactionId: 0 };
}

export const DeleteTransactionRequest: MessageFns<DeleteTransactionRequest> = {
  encode(message: DeleteTransactionRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.transactionId !== 0) {
      writer.uint32(8).int32(message.transactionId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteTransactionRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteTransactionRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.transactionId = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeleteTransactionRequest {
    return { transactionId: isSet(object.transactionId) ? globalThis.Number(object.transactionId) : 0 };
  },

  toJSON(message: DeleteTransactionRequest): unknown {
    const obj: any = {};
    if (message.transactionId !== 0) {
      obj.transactionId = Math.round(message.transactionId);
    }
    return obj;
  },

  create(base?: DeepPartial<DeleteTransactionRequest>): DeleteTransactionRequest {
    return DeleteTransactionRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DeleteTransactionRequest>): DeleteTransactionRequest {
    const message = createBaseDeleteTransactionRequest();
    message.transactionId = object.transactionId ?? 0;
    return message;
  },
};

function createBaseGetTransactionResponse(): GetTransactionResponse {
  return { success: false, message: "", data: undefined, timestamp: "" };
}

export const GetTransactionResponse: MessageFns<GetTransactionResponse> = {
  encode(message: GetTransactionResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    if (message.message !== "") {
      writer.uint32(18).string(message.message);
    }
    if (message.data !== undefined) {
      Transaction.encode(message.data, writer.uint32(26).fork()).join();
    }
    if (message.timestamp !== "") {
      writer.uint32(34).string(message.timestamp);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetTransactionResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetTransactionResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.message = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.data = Transaction.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.timestamp = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetTransactionResponse {
    return {
      success: isSet(object.success) ? globalThis.Boolean(object.success) : false,
      message: isSet(object.message) ? globalThis.String(object.message) : "",
      data: isSet(object.data) ? Transaction.fromJSON(object.data) : undefined,
      timestamp: isSet(object.timestamp) ? globalThis.String(object.timestamp) : "",
    };
  },

  toJSON(message: GetTransactionResponse): unknown {
    const obj: any = {};
    if (message.success !== false) {
      obj.success = message.success;
    }
    if (message.message !== "") {
      obj.message = message.message;
    }
    if (message.data !== undefined) {
      obj.data = Transaction.toJSON(message.data);
    }
    if (message.timestamp !== "") {
      obj.timestamp = message.timestamp;
    }
    return obj;
  },

  create(base?: DeepPartial<GetTransactionResponse>): GetTransactionResponse {
    return GetTransactionResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetTransactionResponse>): GetTransactionResponse {
    const message = createBaseGetTransactionResponse();
    message.success = object.success ?? false;
    message.message = object.message ?? "";
    message.data = (object.data !== undefined && object.data !== null)
      ? Transaction.fromPartial(object.data)
      : undefined;
    message.timestamp = object.timestamp ?? "";
    return message;
  },
};

function createBaseListTransactionsResponse(): ListTransactionsResponse {
  return { success: false, message: "", transactions: [], pagination: undefined, timestamp: "" };
}

export const ListTransactionsResponse: MessageFns<ListTransactionsResponse> = {
  encode(message: ListTransactionsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    if (message.message !== "") {
      writer.uint32(18).string(message.message);
    }
    for (const v of message.transactions) {
      Transaction.encode(v!, writer.uint32(26).fork()).join();
    }
    if (message.pagination !== undefined) {
      PaginationResult.encode(message.pagination, writer.uint32(34).fork()).join();
    }
    if (message.timestamp !== "") {
      writer.uint32(42).string(message.timestamp);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListTransactionsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListTransactionsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.message = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.transactions.push(Transaction.decode(reader, reader.uint32()));
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.pagination = PaginationResult.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.timestamp = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListTransactionsResponse {
    return {
      success: isSet(object.success) ? globalThis.Boolean(object.success) : false,
      message: isSet(object.message) ? globalThis.String(object.message) : "",
      transactions: globalThis.Array.isArray(object?.transactions)
        ? object.transactions.map((e: any) => Transaction.fromJSON(e))
        : [],
      pagination: isSet(object.pagination) ? PaginationResult.fromJSON(object.pagination) : undefined,
      timestamp: isSet(object.timestamp) ? globalThis.String(object.timestamp) : "",
    };
  },

  toJSON(message: ListTransactionsResponse): unknown {
    const obj: any = {};
    if (message.success !== false) {
      obj.success = message.success;
    }
    if (message.message !== "") {
      obj.message = message.message;
    }
    if (message.transactions?.length) {
      obj.transactions = message.transactions.map((e) => Transaction.toJSON(e));
    }
    if (message.pagination !== undefined) {
      obj.pagination = PaginationResult.toJSON(message.pagination);
    }
    if (message.timestamp !== "") {
      obj.timestamp = message.timestamp;
    }
    return obj;
  },

  create(base?: DeepPartial<ListTransactionsResponse>): ListTransactionsResponse {
    return ListTransactionsResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListTransactionsResponse>): ListTransactionsResponse {
    const message = createBaseListTransactionsResponse();
    message.success = object.success ?? false;
    message.message = object.message ?? "";
    message.transactions = object.transactions?.map((e) => Transaction.fromPartial(e)) || [];
    message.pagination = (object.pagination !== undefined && object.pagination !== null)
      ? PaginationResult.fromPartial(object.pagination)
      : undefined;
    message.timestamp = object.timestamp ?? "";
    return message;
  },
};

function createBaseCreateTransactionResponse(): CreateTransactionResponse {
  return { success: false, message: "", data: undefined, newBalance: undefined, timestamp: "" };
}

export const CreateTransactionResponse: MessageFns<CreateTransactionResponse> = {
  encode(message: CreateTransactionResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    if (message.message !== "") {
      writer.uint32(18).string(message.message);
    }
    if (message.data !== undefined) {
      Transaction.encode(message.data, writer.uint32(26).fork()).join();
    }
    if (message.newBalance !== undefined) {
      Money.encode(message.newBalance, writer.uint32(34).fork()).join();
    }
    if (message.timestamp !== "") {
      writer.uint32(42).string(message.timestamp);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateTransactionResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateTransactionResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.message = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.data = Transaction.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.newBalance = Money.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.timestamp = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateTransactionResponse {
    return {
      success: isSet(object.success) ? globalThis.Boolean(object.success) : false,
      message: isSet(object.message) ? globalThis.String(object.message) : "",
      data: isSet(object.data) ? Transaction.fromJSON(object.data) : undefined,
      newBalance: isSet(object.newBalance) ? Money.fromJSON(object.newBalance) : undefined,
      timestamp: isSet(object.timestamp) ? globalThis.String(object.timestamp) : "",
    };
  },

  toJSON(message: CreateTransactionResponse): unknown {
    const obj: any = {};
    if (message.success !== false) {
      obj.success = message.success;
    }
    if (message.message !== "") {
      obj.message = message.message;
    }
    if (message.data !== undefined) {
      obj.data = Transaction.toJSON(message.data);
    }
    if (message.newBalance !== undefined) {
      obj.newBalance = Money.toJSON(message.newBalance);
    }
    if (message.timestamp !== "") {
      obj.timestamp = message.timestamp;
    }
    return obj;
  },

  create(base?: DeepPartial<CreateTransactionResponse>): CreateTransactionResponse {
    return CreateTransactionResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CreateTransactionResponse>): CreateTransactionResponse {
    const message = createBaseCreateTransactionResponse();
    message.success = object.success ?? false;
    message.message = object.message ?? "";
    message.data = (object.data !== undefined && object.data !== null)
      ? Transaction.fromPartial(object.data)
      : undefined;
    message.newBalance = (object.newBalance !== undefined && object.newBalance !== null)
      ? Money.fromPartial(object.newBalance)
      : undefined;
    message.timestamp = object.timestamp ?? "";
    return message;
  },
};

function createBaseUpdateTransactionResponse(): UpdateTransactionResponse {
  return { success: false, message: "", data: undefined, newBalance: undefined, timestamp: "" };
}

export const UpdateTransactionResponse: MessageFns<UpdateTransactionResponse> = {
  encode(message: UpdateTransactionResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    if (message.message !== "") {
      writer.uint32(18).string(message.message);
    }
    if (message.data !== undefined) {
      Transaction.encode(message.data, writer.uint32(26).fork()).join();
    }
    if (message.newBalance !== undefined) {
      Money.encode(message.newBalance, writer.uint32(34).fork()).join();
    }
    if (message.timestamp !== "") {
      writer.uint32(42).string(message.timestamp);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdateTransactionResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateTransactionResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.message = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.data = Transaction.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.newBalance = Money.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.timestamp = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateTransactionResponse {
    return {
      success: isSet(object.success) ? globalThis.Boolean(object.success) : false,
      message: isSet(object.message) ? globalThis.String(object.message) : "",
      data: isSet(object.data) ? Transaction.fromJSON(object.data) : undefined,
      newBalance: isSet(object.newBalance) ? Money.fromJSON(object.newBalance) : undefined,
      timestamp: isSet(object.timestamp) ? globalThis.String(object.timestamp) : "",
    };
  },

  toJSON(message: UpdateTransactionResponse): unknown {
    const obj: any = {};
    if (message.success !== false) {
      obj.success = message.success;
    }
    if (message.message !== "") {
      obj.message = message.message;
    }
    if (message.data !== undefined) {
      obj.data = Transaction.toJSON(message.data);
    }
    if (message.newBalance !== undefined) {
      obj.newBalance = Money.toJSON(message.newBalance);
    }
    if (message.timestamp !== "") {
      obj.timestamp = message.timestamp;
    }
    return obj;
  },

  create(base?: DeepPartial<UpdateTransactionResponse>): UpdateTransactionResponse {
    return UpdateTransactionResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<UpdateTransactionResponse>): UpdateTransactionResponse {
    const message = createBaseUpdateTransactionResponse();
    message.success = object.success ?? false;
    message.message = object.message ?? "";
    message.data = (object.data !== undefined && object.data !== null)
      ? Transaction.fromPartial(object.data)
      : undefined;
    message.newBalance = (object.newBalance !== undefined && object.newBalance !== null)
      ? Money.fromPartial(object.newBalance)
      : undefined;
    message.timestamp = object.timestamp ?? "";
    return message;
  },
};

function createBaseDeleteTransactionResponse(): DeleteTransactionResponse {
  return { success: false, message: "", newBalance: undefined, timestamp: "" };
}

export const DeleteTransactionResponse: MessageFns<DeleteTransactionResponse> = {
  encode(message: DeleteTransactionResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    if (message.message !== "") {
      writer.uint32(18).string(message.message);
    }
    if (message.newBalance !== undefined) {
      Money.encode(message.newBalance, writer.uint32(26).fork()).join();
    }
    if (message.timestamp !== "") {
      writer.uint32(34).string(message.timestamp);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteTransactionResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteTransactionResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.message = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.newBalance = Money.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.timestamp = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeleteTransactionResponse {
    return {
      success: isSet(object.success) ? globalThis.Boolean(object.success) : false,
      message: isSet(object.message) ? globalThis.String(object.message) : "",
      newBalance: isSet(object.newBalance) ? Money.fromJSON(object.newBalance) : undefined,
      timestamp: isSet(object.timestamp) ? globalThis.String(object.timestamp) : "",
    };
  },

  toJSON(message: DeleteTransactionResponse): unknown {
    const obj: any = {};
    if (message.success !== false) {
      obj.success = message.success;
    }
    if (message.message !== "") {
      obj.message = message.message;
    }
    if (message.newBalance !== undefined) {
      obj.newBalance = Money.toJSON(message.newBalance);
    }
    if (message.timestamp !== "") {
      obj.timestamp = message.timestamp;
    }
    return obj;
  },

  create(base?: DeepPartial<DeleteTransactionResponse>): DeleteTransactionResponse {
    return DeleteTransactionResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DeleteTransactionResponse>): DeleteTransactionResponse {
    const message = createBaseDeleteTransactionResponse();
    message.success = object.success ?? false;
    message.message = object.message ?? "";
    message.newBalance = (object.newBalance !== undefined && object.newBalance !== null)
      ? Money.fromPartial(object.newBalance)
      : undefined;
    message.timestamp = object.timestamp ?? "";
    return message;
  },
};

function createBaseGetCategoryRequest(): GetCategoryRequest {
  return { categoryId: 0 };
}

export const GetCategoryRequest: MessageFns<GetCategoryRequest> = {
  encode(message: GetCategoryRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.categoryId !== 0) {
      writer.uint32(8).int32(message.categoryId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetCategoryRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetCategoryRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.categoryId = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetCategoryRequest {
    return { categoryId: isSet(object.categoryId) ? globalThis.Number(object.categoryId) : 0 };
  },

  toJSON(message: GetCategoryRequest): unknown {
    const obj: any = {};
    if (message.categoryId !== 0) {
      obj.categoryId = Math.round(message.categoryId);
    }
    return obj;
  },

  create(base?: DeepPartial<GetCategoryRequest>): GetCategoryRequest {
    return GetCategoryRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetCategoryRequest>): GetCategoryRequest {
    const message = createBaseGetCategoryRequest();
    message.categoryId = object.categoryId ?? 0;
    return message;
  },
};

function createBaseListCategoriesRequest(): ListCategoriesRequest {
  return { pagination: undefined, type: undefined };
}

export const ListCategoriesRequest: MessageFns<ListCategoriesRequest> = {
  encode(message: ListCategoriesRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.pagination !== undefined) {
      PaginationParams.encode(message.pagination, writer.uint32(10).fork()).join();
    }
    if (message.type !== undefined) {
      writer.uint32(16).int32(message.type);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListCategoriesRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListCategoriesRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.pagination = PaginationParams.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.type = reader.int32() as any;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListCategoriesRequest {
    return {
      pagination: isSet(object.pagination) ? PaginationParams.fromJSON(object.pagination) : undefined,
      type: isSet(object.type) ? categoryTypeFromJSON(object.type) : undefined,
    };
  },

  toJSON(message: ListCategoriesRequest): unknown {
    const obj: any = {};
    if (message.pagination !== undefined) {
      obj.pagination = PaginationParams.toJSON(message.pagination);
    }
    if (message.type !== undefined) {
      obj.type = categoryTypeToJSON(message.type);
    }
    return obj;
  },

  create(base?: DeepPartial<ListCategoriesRequest>): ListCategoriesRequest {
    return ListCategoriesRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListCategoriesRequest>): ListCategoriesRequest {
    const message = createBaseListCategoriesRequest();
    message.pagination = (object.pagination !== undefined && object.pagination !== null)
      ? PaginationParams.fromPartial(object.pagination)
      : undefined;
    message.type = object.type ?? undefined;
    return message;
  },
};

function createBaseCreateCategoryRequest(): CreateCategoryRequest {
  return { name: "", type: 0 };
}

export const CreateCategoryRequest: MessageFns<CreateCategoryRequest> = {
  encode(message: CreateCategoryRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.type !== 0) {
      writer.uint32(16).int32(message.type);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateCategoryRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateCategoryRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.type = reader.int32() as any;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateCategoryRequest {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      type: isSet(object.type) ? categoryTypeFromJSON(object.type) : 0,
    };
  },

  toJSON(message: CreateCategoryRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.type !== 0) {
      obj.type = categoryTypeToJSON(message.type);
    }
    return obj;
  },

  create(base?: DeepPartial<CreateCategoryRequest>): CreateCategoryRequest {
    return CreateCategoryRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CreateCategoryRequest>): CreateCategoryRequest {
    const message = createBaseCreateCategoryRequest();
    message.name = object.name ?? "";
    message.type = object.type ?? 0;
    return message;
  },
};

function createBaseUpdateCategoryRequest(): UpdateCategoryRequest {
  return { categoryId: 0, name: "" };
}

export const UpdateCategoryRequest: MessageFns<UpdateCategoryRequest> = {
  encode(message: UpdateCategoryRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.categoryId !== 0) {
      writer.uint32(8).int32(message.categoryId);
    }
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdateCategoryRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateCategoryRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.categoryId = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateCategoryRequest {
    return {
      categoryId: isSet(object.categoryId) ? globalThis.Number(object.categoryId) : 0,
      name: isSet(object.name) ? globalThis.String(object.name) : "",
    };
  },

  toJSON(message: UpdateCategoryRequest): unknown {
    const obj: any = {};
    if (message.categoryId !== 0) {
      obj.categoryId = Math.round(message.categoryId);
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create(base?: DeepPartial<UpdateCategoryRequest>): UpdateCategoryRequest {
    return UpdateCategoryRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<UpdateCategoryRequest>): UpdateCategoryRequest {
    const message = createBaseUpdateCategoryRequest();
    message.categoryId = object.categoryId ?? 0;
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseDeleteCategoryRequest(): DeleteCategoryRequest {
  return { categoryId: 0 };
}

export const DeleteCategoryRequest: MessageFns<DeleteCategoryRequest> = {
  encode(message: DeleteCategoryRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.categoryId !== 0) {
      writer.uint32(8).int32(message.categoryId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteCategoryRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteCategoryRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.categoryId = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeleteCategoryRequest {
    return { categoryId: isSet(object.categoryId) ? globalThis.Number(object.categoryId) : 0 };
  },

  toJSON(message: DeleteCategoryRequest): unknown {
    const obj: any = {};
    if (message.categoryId !== 0) {
      obj.categoryId = Math.round(message.categoryId);
    }
    return obj;
  },

  create(base?: DeepPartial<DeleteCategoryRequest>): DeleteCategoryRequest {
    return DeleteCategoryRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DeleteCategoryRequest>): DeleteCategoryRequest {
    const message = createBaseDeleteCategoryRequest();
    message.categoryId = object.categoryId ?? 0;
    return message;
  },
};

function createBaseGetCategoryResponse(): GetCategoryResponse {
  return { success: false, message: "", data: undefined, timestamp: "" };
}

export const GetCategoryResponse: MessageFns<GetCategoryResponse> = {
  encode(message: GetCategoryResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    if (message.message !== "") {
      writer.uint32(18).string(message.message);
    }
    if (message.data !== undefined) {
      Category.encode(message.data, writer.uint32(26).fork()).join();
    }
    if (message.timestamp !== "") {
      writer.uint32(34).string(message.timestamp);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetCategoryResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetCategoryResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.message = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.data = Category.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.timestamp = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetCategoryResponse {
    return {
      success: isSet(object.success) ? globalThis.Boolean(object.success) : false,
      message: isSet(object.message) ? globalThis.String(object.message) : "",
      data: isSet(object.data) ? Category.fromJSON(object.data) : undefined,
      timestamp: isSet(object.timestamp) ? globalThis.String(object.timestamp) : "",
    };
  },

  toJSON(message: GetCategoryResponse): unknown {
    const obj: any = {};
    if (message.success !== false) {
      obj.success = message.success;
    }
    if (message.message !== "") {
      obj.message = message.message;
    }
    if (message.data !== undefined) {
      obj.data = Category.toJSON(message.data);
    }
    if (message.timestamp !== "") {
      obj.timestamp = message.timestamp;
    }
    return obj;
  },

  create(base?: DeepPartial<GetCategoryResponse>): GetCategoryResponse {
    return GetCategoryResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetCategoryResponse>): GetCategoryResponse {
    const message = createBaseGetCategoryResponse();
    message.success = object.success ?? false;
    message.message = object.message ?? "";
    message.data = (object.data !== undefined && object.data !== null) ? Category.fromPartial(object.data) : undefined;
    message.timestamp = object.timestamp ?? "";
    return message;
  },
};

function createBaseListCategoriesResponse(): ListCategoriesResponse {
  return { success: false, message: "", categories: [], pagination: undefined, timestamp: "" };
}

export const ListCategoriesResponse: MessageFns<ListCategoriesResponse> = {
  encode(message: ListCategoriesResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    if (message.message !== "") {
      writer.uint32(18).string(message.message);
    }
    for (const v of message.categories) {
      Category.encode(v!, writer.uint32(26).fork()).join();
    }
    if (message.pagination !== undefined) {
      PaginationResult.encode(message.pagination, writer.uint32(34).fork()).join();
    }
    if (message.timestamp !== "") {
      writer.uint32(42).string(message.timestamp);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListCategoriesResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListCategoriesResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.message = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.categories.push(Category.decode(reader, reader.uint32()));
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.pagination = PaginationResult.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.timestamp = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListCategoriesResponse {
    return {
      success: isSet(object.success) ? globalThis.Boolean(object.success) : false,
      message: isSet(object.message) ? globalThis.String(object.message) : "",
      categories: globalThis.Array.isArray(object?.categories)
        ? object.categories.map((e: any) => Category.fromJSON(e))
        : [],
      pagination: isSet(object.pagination) ? PaginationResult.fromJSON(object.pagination) : undefined,
      timestamp: isSet(object.timestamp) ? globalThis.String(object.timestamp) : "",
    };
  },

  toJSON(message: ListCategoriesResponse): unknown {
    const obj: any = {};
    if (message.success !== false) {
      obj.success = message.success;
    }
    if (message.message !== "") {
      obj.message = message.message;
    }
    if (message.categories?.length) {
      obj.categories = message.categories.map((e) => Category.toJSON(e));
    }
    if (message.pagination !== undefined) {
      obj.pagination = PaginationResult.toJSON(message.pagination);
    }
    if (message.timestamp !== "") {
      obj.timestamp = message.timestamp;
    }
    return obj;
  },

  create(base?: DeepPartial<ListCategoriesResponse>): ListCategoriesResponse {
    return ListCategoriesResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListCategoriesResponse>): ListCategoriesResponse {
    const message = createBaseListCategoriesResponse();
    message.success = object.success ?? false;
    message.message = object.message ?? "";
    message.categories = object.categories?.map((e) => Category.fromPartial(e)) || [];
    message.pagination = (object.pagination !== undefined && object.pagination !== null)
      ? PaginationResult.fromPartial(object.pagination)
      : undefined;
    message.timestamp = object.timestamp ?? "";
    return message;
  },
};

function createBaseCreateCategoryResponse(): CreateCategoryResponse {
  return { success: false, message: "", data: undefined, timestamp: "" };
}

export const CreateCategoryResponse: MessageFns<CreateCategoryResponse> = {
  encode(message: CreateCategoryResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    if (message.message !== "") {
      writer.uint32(18).string(message.message);
    }
    if (message.data !== undefined) {
      Category.encode(message.data, writer.uint32(26).fork()).join();
    }
    if (message.timestamp !== "") {
      writer.uint32(34).string(message.timestamp);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateCategoryResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateCategoryResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.message = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.data = Category.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.timestamp = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateCategoryResponse {
    return {
      success: isSet(object.success) ? globalThis.Boolean(object.success) : false,
      message: isSet(object.message) ? globalThis.String(object.message) : "",
      data: isSet(object.data) ? Category.fromJSON(object.data) : undefined,
      timestamp: isSet(object.timestamp) ? globalThis.String(object.timestamp) : "",
    };
  },

  toJSON(message: CreateCategoryResponse): unknown {
    const obj: any = {};
    if (message.success !== false) {
      obj.success = message.success;
    }
    if (message.message !== "") {
      obj.message = message.message;
    }
    if (message.data !== undefined) {
      obj.data = Category.toJSON(message.data);
    }
    if (message.timestamp !== "") {
      obj.timestamp = message.timestamp;
    }
    return obj;
  },

  create(base?: DeepPartial<CreateCategoryResponse>): CreateCategoryResponse {
    return CreateCategoryResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CreateCategoryResponse>): CreateCategoryResponse {
    const message = createBaseCreateCategoryResponse();
    message.success = object.success ?? false;
    message.message = object.message ?? "";
    message.data = (object.data !== undefined && object.data !== null) ? Category.fromPartial(object.data) : undefined;
    message.timestamp = object.timestamp ?? "";
    return message;
  },
};

function createBaseUpdateCategoryResponse(): UpdateCategoryResponse {
  return { success: false, message: "", data: undefined, timestamp: "" };
}

export const UpdateCategoryResponse: MessageFns<UpdateCategoryResponse> = {
  encode(message: UpdateCategoryResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    if (message.message !== "") {
      writer.uint32(18).string(message.message);
    }
    if (message.data !== undefined) {
      Category.encode(message.data, writer.uint32(26).fork()).join();
    }
    if (message.timestamp !== "") {
      writer.uint32(34).string(message.timestamp);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdateCategoryResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateCategoryResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.message = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.data = Category.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.timestamp = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateCategoryResponse {
    return {
      success: isSet(object.success) ? globalThis.Boolean(object.success) : false,
      message: isSet(object.message) ? globalThis.String(object.message) : "",
      data: isSet(object.data) ? Category.fromJSON(object.data) : undefined,
      timestamp: isSet(object.timestamp) ? globalThis.String(object.timestamp) : "",
    };
  },

  toJSON(message: UpdateCategoryResponse): unknown {
    const obj: any = {};
    if (message.success !== false) {
      obj.success = message.success;
    }
    if (message.message !== "") {
      obj.message = message.message;
    }
    if (message.data !== undefined) {
      obj.data = Category.toJSON(message.data);
    }
    if (message.timestamp !== "") {
      obj.timestamp = message.timestamp;
    }
    return obj;
  },

  create(base?: DeepPartial<UpdateCategoryResponse>): UpdateCategoryResponse {
    return UpdateCategoryResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<UpdateCategoryResponse>): UpdateCategoryResponse {
    const message = createBaseUpdateCategoryResponse();
    message.success = object.success ?? false;
    message.message = object.message ?? "";
    message.data = (object.data !== undefined && object.data !== null) ? Category.fromPartial(object.data) : undefined;
    message.timestamp = object.timestamp ?? "";
    return message;
  },
};

function createBaseDeleteCategoryResponse(): DeleteCategoryResponse {
  return { success: false, message: "", timestamp: "" };
}

export const DeleteCategoryResponse: MessageFns<DeleteCategoryResponse> = {
  encode(message: DeleteCategoryResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    if (message.message !== "") {
      writer.uint32(18).string(message.message);
    }
    if (message.timestamp !== "") {
      writer.uint32(26).string(message.timestamp);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteCategoryResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteCategoryResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.message = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.timestamp = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeleteCategoryResponse {
    return {
      success: isSet(object.success) ? globalThis.Boolean(object.success) : false,
      message: isSet(object.message) ? globalThis.String(object.message) : "",
      timestamp: isSet(object.timestamp) ? globalThis.String(object.timestamp) : "",
    };
  },

  toJSON(message: DeleteCategoryResponse): unknown {
    const obj: any = {};
    if (message.success !== false) {
      obj.success = message.success;
    }
    if (message.message !== "") {
      obj.message = message.message;
    }
    if (message.timestamp !== "") {
      obj.timestamp = message.timestamp;
    }
    return obj;
  },

  create(base?: DeepPartial<DeleteCategoryResponse>): DeleteCategoryResponse {
    return DeleteCategoryResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DeleteCategoryResponse>): DeleteCategoryResponse {
    const message = createBaseDeleteCategoryResponse();
    message.success = object.success ?? false;
    message.message = object.message ?? "";
    message.timestamp = object.timestamp ?? "";
    return message;
  },
};

function createBaseGetAvailableYearsRequest(): GetAvailableYearsRequest {
  return {};
}

export const GetAvailableYearsRequest: MessageFns<GetAvailableYearsRequest> = {
  encode(_: GetAvailableYearsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetAvailableYearsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetAvailableYearsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): GetAvailableYearsRequest {
    return {};
  },

  toJSON(_: GetAvailableYearsRequest): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<GetAvailableYearsRequest>): GetAvailableYearsRequest {
    return GetAvailableYearsRequest.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<GetAvailableYearsRequest>): GetAvailableYearsRequest {
    const message = createBaseGetAvailableYearsRequest();
    return message;
  },
};

function createBaseGetAvailableYearsResponse(): GetAvailableYearsResponse {
  return { success: false, message: "", years: [], timestamp: "" };
}

export const GetAvailableYearsResponse: MessageFns<GetAvailableYearsResponse> = {
  encode(message: GetAvailableYearsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    if (message.message !== "") {
      writer.uint32(18).string(message.message);
    }
    writer.uint32(26).fork();
    for (const v of message.years) {
      writer.int32(v);
    }
    writer.join();
    if (message.timestamp !== "") {
      writer.uint32(34).string(message.timestamp);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetAvailableYearsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetAvailableYearsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.message = reader.string();
          continue;
        }
        case 3: {
          if (tag === 24) {
            message.years.push(reader.int32());

            continue;
          }

          if (tag === 26) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.years.push(reader.int32());
            }

            continue;
          }

          break;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.timestamp = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetAvailableYearsResponse {
    return {
      success: isSet(object.success) ? globalThis.Boolean(object.success) : false,
      message: isSet(object.message) ? globalThis.String(object.message) : "",
      years: globalThis.Array.isArray(object?.years) ? object.years.map((e: any) => globalThis.Number(e)) : [],
      timestamp: isSet(object.timestamp) ? globalThis.String(object.timestamp) : "",
    };
  },

  toJSON(message: GetAvailableYearsResponse): unknown {
    const obj: any = {};
    if (message.success !== false) {
      obj.success = message.success;
    }
    if (message.message !== "") {
      obj.message = message.message;
    }
    if (message.years?.length) {
      obj.years = message.years.map((e) => Math.round(e));
    }
    if (message.timestamp !== "") {
      obj.timestamp = message.timestamp;
    }
    return obj;
  },

  create(base?: DeepPartial<GetAvailableYearsResponse>): GetAvailableYearsResponse {
    return GetAvailableYearsResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetAvailableYearsResponse>): GetAvailableYearsResponse {
    const message = createBaseGetAvailableYearsResponse();
    message.success = object.success ?? false;
    message.message = object.message ?? "";
    message.years = object.years?.map((e) => e) || [];
    message.timestamp = object.timestamp ?? "";
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends { $case: string } ? { [K in keyof Omit<T, "$case">]?: DeepPartial<T[K]> } & { $case: T["$case"] }
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function longToNumber(int64: { toString(): string }): number {
  const num = globalThis.Number(int64.toString());
  if (num > globalThis.Number.MAX_SAFE_INTEGER) {
    throw new globalThis.Error("Value is larger than Number.MAX_SAFE_INTEGER");
  }
  if (num < globalThis.Number.MIN_SAFE_INTEGER) {
    throw new globalThis.Error("Value is smaller than Number.MIN_SAFE_INTEGER");
  }
  return num;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
